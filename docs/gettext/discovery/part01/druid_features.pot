# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, metatron team
# This file is distributed under the same license as the metatron discovery docs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: metatron discovery docs 0.4.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-11-19 14:45+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../discovery/part01/druid_features.rst:2
# faa8d3b487df45e585501a2bbe6afe3b
msgid "Druid 특징"
msgstr ""

#: ../../discovery/part01/druid_features.rst:5
# e9cd7c55b78f45b7aaa6ae477135ef14
msgid "데이터 테이블 형태"
msgstr ""

#: ../../discovery/part01/druid_features.rst:7
# 62e79bcd47704966ab0e2c91af54473e
msgid "Druid의 데이터 테이블(Druid에서는 '데이터 소스'라고 함)은 OLAP 쿼리용으로 설계된 시계열 이벤트들로 구성됩니다. 데이터 소스는 세 종류의 컬럼으로 구성됩니다(여기서는 온라인 광고 데이터를 예시로 사용)."
msgstr ""

#: ../../discovery/part01/druid_features.rst:13
# fc8d71e2cb9841a497dab23bdad1cda8
msgid "Source: http://druid.io"
msgstr ""

#: ../../discovery/part01/druid_features.rst:15
# 51a518bc611a4ec79d3d041d6f23b7c7
msgid "**타임스탬프 컬럼(Timestamp column):** Druid는 데이터 소스에서 타임스탬프 컬럼을 별도로 구성함으로써 모든 쿼리가 시간 축을 중심으로 이루어지게 합니다(시계열 속성이 없는 데이터를 일괄적으로 ingestion할 경우에는 현재 시간을 기준으로 타임스탬프가 부여되어 Druid에서 활용할 수 있는 형태가 됩니다)."
msgstr ""

#: ../../discovery/part01/druid_features.rst:16
# 2ed911ff6f4246f99543b693d13ce616
msgid "**차원 컬럼(Dimension columns):** 차원 컬럼은 각 이벤트의 문자열 속성들을 담고 있으며, 데이터 필터링 시 가장 흔히 사용됩니다. 위 데이터셋 예시에서는 publisher, advertiser, gender, country가 차원 컬럼입니다. 데이터 탐색 시에는 이러한 차원 컬럼들을 축으로 하여 데이터를 slice하게 됩니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:17
# d07c6f1aa80941b88b986ee0b61b9d21
msgid "**측정값 컬럼(Metric columns):** 측정값 컬럼들은 집계 및 연산에 사용됩니다. 위 예에서는 clicks 및 price가 측정값 컬럼입니다. 측정값 컬럼의 자료형은 대체로 수치 값이며, 이들은 계수, 합산, 평균 등의 방식으로 집계할 수 있습니다(Metatron에서는 지원되는 자료형을 증대하였습니다)."
msgstr ""

#: ../../discovery/part01/druid_features.rst:20
# d6aad4ce74cf4bf6937af29a36ffc745
msgid "데이터 ingestion"
msgstr ""

#: ../../discovery/part01/druid_features.rst:22
# 2dea0f8c0c2f44f7957e136d6ab7adeb
msgid "Druid는 실시간 및 일괄(batch) ingestion을 지원합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:24
# c11ddf801abd444db72c4c28797088be
msgid "이 중에서 실시간 ingestion은 Druid의 주요 특징 중 하나인데, 이를 전담하는 real-time 노드군이 있기 때문에 가능한 것입니다(자세한 설명은 :ref:`realtime_nodes` 참조). 실시간으로 ingestion되는 데이터 스트림 내 이벤트들은 발생 후 수 초 이내에 Druid 클러스터에서 쿼리가 가능한 포맷으로 인덱싱됩니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:29
# 1f28b729d8094421a3731eda81aef10e
msgid "데이터 roll-up"
msgstr ""

#: ../../discovery/part01/druid_features.rst:31
# bea3f9d2039941e6a4ce0555ae66c845
msgid "무수히 많은 개별 이벤트를 단순히 열거하기만 해서는 중요한 의미를 찾을 수 없습니다. 하지만 이러한 데이터를 적절한 시간대를 기준으로 취합하면 유용한 인사이트를 얻을 수 있습니다. Druid는 roll-up이라는 옵션을 통해 ingestion되는 원천 데이터를 취합할 수 있습니다. 아래는 roll-up의 예시를 나타낸 것입니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:37
# 5bb06c1f8b534795bd183b310c0b981f
msgid "Source: Interactive Exploratory Analytics with Druid | DataEngConf SF '17"
msgstr ""

#: ../../discovery/part01/druid_features.rst:39
# 85c3743a847346b9b0ea65f1bfd044ea
msgid "왼쪽의 원본 이벤트 목록은 2011년 1월 1일 00:00:00~01:00:00 사이에 발생한 도메인 클릭 이벤트를 열거한 것입니다. 하지만 분석가 입장에서는 분 이하 단위의 개별 이벤트가 별다른 의미를 갖지 못하기 때문에 1시간의 granularity를 기준으로 데이터를 취합했습니다. 그 결과 오른쪽 테이블에 나타난 것처럼 2011년 1월 1일 00~01시 시간대에 각 도메인을 남성과 여성이 각각 클릭한 횟수를 보여주는 보다 의미 있는 결과물이 도출되었습니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:41
# 50b1c425a0274f678f1ddf9a4a99e2a3
msgid "또한 데이터 roll-up은 원천 데이터의 저장 용량을 최소함으로써(많게는 100배까지도 축소 가능), 스토리지 리소스를 절약하고 쿼리 속도를 빠르게 합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:43
# 03779d5415414334b4bf021d6a48cdc0
msgid "그러나 데이터를 roll-up하면 개별 이벤트들에 대해 쿼리할 수 없게 됩니다. roll-up granularity는 데이터를 탐색할 수 있는 최소 단위가 되며 이벤트들은 이러한 granularity 단위로 배열됩니다. granularity 단위는 사용자가 원하는 대로 설정할 수 있으며, 원치 않으면 roll-up을 비활성화하고 모든 개별 이벤트를 전부 ingestion할 수도 있습니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:47
# ea24241668d0454a9aae38ab2c40c934
msgid "데이터 sharding"
msgstr ""

#: ../../discovery/part01/druid_features.rst:49
# 869c4573fed342368bee2af2b03b3adf
msgid "데이터 소스는 시계열 이벤트들의 집합으로서 여러 shard로 분할 저장되는데, Druid에서는 이를 '세그먼트'라고 부르며 각 세그먼트는 대개 500~1,000만 행으로 이루어집니다. Druid는 데이터 소스들을 정의된 시간 간격(통상적으로 1시간이나 하루)을 기준으로 분할하며, 그 밖의 컬럼에 있는 값들을 기준으로 추가 분할을 실시함으로써 세그먼트 크기를 적절하게 맞출 수 있습니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:51
# bef82f59571b4d8b8409437c789621af
msgid "아래는 1시간 단위로 분할된 데이터 테이블을 예시로 나타낸 것입니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:53
# 5d1af95c9a144e9bb3ab92afc701ab62
msgid "세그먼트 ``sampleData_2011-01-01T01:00:00:00Z_2011-01-01T02:00:00:00Z_v1_0``: ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:58
# 963b480e5fcf44ffb3ac1f5af50b909a
msgid "세그먼트 ``sampleData_2011-01-01T02:00:00:00Z_2011-01-01T03:00:00:00Z_v1_0``: ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:63
# 0c728eb2d4c047698c9a5a15f21a7fd3
msgid "이와 같이 시간 단위로 세그먼트를 구분하는 것은 데이터 소스 내의 모든 이벤트에 타임스탬프가 포함되기 때문에 가능합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:65
# 89bf94ed1cca4401bbd9554365bcc124
msgid "세그먼트는 Druid 테이블의 기본 저장 단위에 해당하며, 클러스터 내 데이터의 복제(replication) 및 분산은 세그먼트 단위로 이루어집니다. 세그먼트 내 데이터는 변경할 수 없도록 되어 있습니다. 이렇게 함으로써 읽기와 쓰기 동작 사이에 경합이 발생하지 않게 됩니다. Druid의 세그먼트는 매우 신속하게 읽히기 위한 읽기 전용 데이터셋입니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:67
# 7e4c6bcb73c746e2a9a265f57abb189b
msgid "뿐만 아니라, 이러한 데이터 세그먼트 분할은 Druid 분산 환경에서의 병렬 처리를 위한 핵심 역할을 합니다. 각 CPU가 한 번에 하나의 세그먼트를 스캔할 수 있기 때문에 데이터를 여러 세그먼트로 분할하면 이를 여러 CPU가 동시에 병렬적으로 스캔할 수 있으므로, 쿼리 결과를 신속하게 반환하고 부하를 안정적으로 분산시킬 수 있게 됩니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:72
# 0dfbd4b84b394142957e95e732a04f72
msgid "데이터 저장 포맷 및 인덱싱"
msgstr ""

#: ../../discovery/part01/druid_features.rst:74
# 4bfbd2332c9c4a469076dcd4f68efccd
msgid "Druid의 데이터 구조를 분석 쿼리에 최적화시키는 주요 요소 중 하나는 Druid가 데이터를 저장하는 방식입니다. 본 절에서는 설명을 위해 아래의 Druid 테이블 예시를 사용합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:80
# 7feb57d5d9af47cdaa1d92062f1de0f5
msgid "Source: Druid: A Real-time Analytical Data Store"
msgstr ""

#: ../../discovery/part01/druid_features.rst:83
# df4408eed5aa420e97dab9afbaa4a4f8
msgid "컬럼 기반 저장 및 인덱싱"
msgstr ""

#: ../../discovery/part01/druid_features.rst:85
# daae21b4ee2b4ffbaf8fab62a898ca69
msgid "Druid는 컬럼들을 각각 따로 저장합니다. Druid가 주로 이벤트 스트림을 집계하는 데 사용된다는 점을 고려할 때, 이러한 컬럼 기반 저장 방식을 취하면 각 쿼리에 관련된 컬럼만을 로드·스캔하므로 CPU 리소스를 보다 효율적으로 사용할 수 있습니다. 행 기반 데이터 스토어에서는 집계 시 대상 행과 관련된 모든 컬럼을 컬럼별로 상이한 방식으로 압축할 수 있으며 그에 따라 각기 다른 인덱스를 활용함으로써 컬럼을 메모리나 디스크에 저장하는 데 드는 리소스 비용을 줄일 수 있습니다. 위 예에서 page, user, gender, city 컬럼은 문자열만을 포함합니다. 직접 문자열들을 저장하는 것은 불필요한 비용을 발생시키므로 이들을 고유한 정수 식별자로 매핑할 수 있습니다. 예를 들면, ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:90
# ef49cee3b397451387ed3624944a3acc
msgid "이 매핑을 사용하면 page 컬럼을 정수 배열로 나타낼 수 있는데, 여기서 배열 인덱스 각각은 원본 데이터셋의 각 행에 해당합니다. page 컬럼의 경우, 각 행의 page 값을 아래와 같이 표시할 수 있습니다. ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:94
# 78b8d292680c475e81d170aa013428b0
msgid "이처럼 문자열들이 고정 길이 정수들로 바뀌어 저장되므로 압축하기가 훨씬 더 수월합니다. Druid는 각 shard(세그먼트) 단위로 데이터를 인덱싱합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:98
# 6353e95123b847618ca441c609f03826
msgid "데이터 필터링을 위한 인덱싱"
msgstr ""

#: ../../discovery/part01/druid_features.rst:100
# f37a4769f6b346098259ce40b70425ee
msgid "Druid는 검색 인덱스를 추가로 만들어서 문자열 컬럼에 대한 필터링을 용이하게 할 수 있습니다. 위 예시 테이블을 다시 보자. 가령 \"샌프란시스코에 사는 남성 사용자들이 Wikipedia 편집을 한 횟수는?\"과 같은 쿼리가 있을 수 있습니다. 이 쿼리 예시에는 도시(San Francisco)와 성별(Male)이라는 두 가지 차원이 포함됩니다. 각 차원별로 아래와 같은 바이너리 배열이 생성되는데, 여기서 배열 인덱스 각각은 해당 행이 쿼리 필터 조건에 부합하는지 여부를 나타냅니다. ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:105
# 245f4754b18c4fd5a7e6c5e9e9bb74ac
msgid "그런 다음 쿼리 필터는 이러한 두 배열에 대해 AND 연산을 실시합니다. ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:109
# aaef41fbcf024bcdaa7790b1f2bb8593
msgid "그 결과, 행 1만 스캔 대상이 됩니다. 이런 식으로 필터링된 행만 검색함으로써 불필요한 부하를 방지하는 것입니다. 이러한 바이너리 배열은 압축하기도 매우 쉽습니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:111
# 2b11ed30feaf4f19bd3622f85afe860e
msgid "이러한 검색 인덱싱은 OR 연산에도 사용할 수 있습니다. 어떤 쿼리가 San Francisco 또는 Calgary을 필터링하는 경우, 배열 인덱스들은 차원값별로 다음과 같을 것입니다. ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:116
# c7074b1b4d984d0dbba378d4cc8747ad
msgid "그런 다음 두 배열에 대해 OR 연산이 수행됩니다. ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:120
# 48c6bab443724d079914d579a4c0746d
msgid "그 결과, 쿼리는 행 1과 3만 스캔합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:122
# 8d95833769f4414b9dc07bcd37cad029
msgid "대형 비트맵 셋에 boolean 연산을 실시하는 이러한 접근방식은 검색 엔진에서 널리 사용됩니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:128
# 258eec7d58ef42a195a937f7c8ba08df
msgid "쿼리 언어"
msgstr ""

#: ../../discovery/part01/druid_features.rst:130
# 62cbd6b5eba647e795bf6b84d8edf77c
msgid "Druid의 네이티브 쿼리 언어는 JSON over HTTP이며, 주요 쿼리는 다음과 같습니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:132
# 492b5e370a124a3ca85830f50adb80eb
msgid "Group By"
msgstr ""

#: ../../discovery/part01/druid_features.rst:133
# b33d589c1eab44cbb2b1845b19cad9bc
msgid "시계열 기반 roll-up"
msgstr ""

#: ../../discovery/part01/druid_features.rst:134
# b4ba13bb555342f7a8d278e5e95d296c
msgid "임의적 boolean 필터링"
msgstr ""

#: ../../discovery/part01/druid_features.rst:135
# c7565ad83a8e4baab0948997f11c5be0
msgid "Sum, Min, Max, Avg 등의 집계 연산"
msgstr ""

#: ../../discovery/part01/druid_features.rst:136
# ccd1643108f0434fae42291545c17915
msgid "차원값 검색"
msgstr ""

#: ../../discovery/part01/druid_features.rst:138
# 1c1b7d5ee30b40b9af072ca9abcd534a
msgid "하지만 이 외에도 SQL을 비롯한 다양한 언어로 이루어진 쿼리 라이브러리가 생성·공유되고있습니다."
msgstr ""

