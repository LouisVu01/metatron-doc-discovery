# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, metatron team
# This file is distributed under the same license as the metatron discovery docs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: metatron discovery docs 0.4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-08 00:00+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../discovery/part01/druid_features.rst:2
# 1bf9a19d95ba4a1db8702adae2c01a69
msgid "Druid 특징"
msgstr ""

#: ../../discovery/part01/druid_features.rst:5
# c9fcf66c41244ea3809cbd0aac6271c7
msgid "데이터 테이블 형태"
msgstr ""

#: ../../discovery/part01/druid_features.rst:7
# 30c53675d8374e7fbddc16d3ba572c97
msgid "Druid의 데이터 테이블(Druid에서는 '데이터 소스'라고 함)은 OLAP 쿼리용으로 설계된 시계열 이벤트들로 구성됩니다. 데이터 소스는 세 종류의 컬럼으로 구성됩니다(여기서는 온라인 광고 데이터를 예시로 사용)."
msgstr ""

#: ../../discovery/part01/druid_features.rst:13
# 06116757f6844292962778d406113042
msgid "Source: http://druid.io"
msgstr ""

#: ../../discovery/part01/druid_features.rst:15
# 20094739de7c441eb5b403b077fce008
msgid "**타임스탬프 컬럼(Timestamp column):** Druid는 데이터 소스에서 타임스탬프 컬럼을 별도로 구성함으로써 모든 쿼리가 시간 축을 중심으로 이루어지게 합니다(시계열 속성이 없는 데이터를 일괄적으로 ingestion할 경우에는 현재 시간을 기준으로 타임스탬프가 부여되어 Druid에서 활용할 수 있는 형태가 됩니다)."
msgstr ""

#: ../../discovery/part01/druid_features.rst:16
# 507e1a82005e40f7a508c5978c3bae10
msgid "**차원 컬럼(Dimension columns):** 차원 컬럼은 각 이벤트의 문자열 속성들을 담고 있으며, 데이터 필터링 시 가장 흔히 사용됩니다. 위 데이터셋 예시에서는 publisher, advertiser, gender, country가 차원 컬럼입니다. 데이터 탐색 시에는 이러한 차원 컬럼들을 축으로 하여 데이터를 slice하게 됩니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:17
# 54f26406be9b468fb44ef476fed4c074
msgid "**측정값 컬럼(Metric columns):** 측정값 컬럼들은 집계 및 연산에 사용됩니다. 위 예에서는 clicks 및 price가 측정값 컬럼입니다. 측정값 컬럼의 자료형은 대체로 수치 값이며, 이들은 계수, 합산, 평균 등의 방식으로 집계할 수 있습니다(Metatron에서는 지원되는 자료형을 증대하였습니다)."
msgstr ""

#: ../../discovery/part01/druid_features.rst:20
# 361987d8f9fe445bad543dec9cb63cc2
msgid "데이터 ingestion"
msgstr ""

#: ../../discovery/part01/druid_features.rst:22
# c7d323020e2048d999da4d100d66c319
msgid "Druid는 실시간 및 일괄(batch) ingestion을 지원합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:24
# eb74924f67ce4a779982b307fda8a74f
msgid "이 중에서 실시간 ingestion은 Druid의 주요 특징 중 하나인데, 이를 전담하는 real-time 노드군이 있기 때문에 가능한 것입니다(자세한 설명은 :ref:`realtime_nodes` 참조). 실시간으로 ingestion되는 데이터 스트림 내 이벤트들은 발생 후 수 초 이내에 Druid 클러스터에서 쿼리가 가능한 포맷으로 인덱싱됩니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:29
# 210eacc3e44344349cec049de6871619
msgid "데이터 roll-up"
msgstr ""

#: ../../discovery/part01/druid_features.rst:31
# 684d9f8947794d00baa05983680e2d5e
msgid "무수히 많은 개별 이벤트를 단순히 열거하기만 해서는 중요한 의미를 찾을 수 없습니다. 하지만 이러한 데이터를 적절한 시간대를 기준으로 취합하면 유용한 인사이트를 얻을 수 있습니다. Druid는 roll-up이라는 옵션을 통해 ingestion되는 원천 데이터를 취합할 수 있습니다. 아래는 roll-up의 예시를 나타낸 것입니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:37
# ca1bad88ae4d4b88b82c645369bb39f7
msgid "Source: Interactive Exploratory Analytics with Druid | DataEngConf SF '17"
msgstr ""

#: ../../discovery/part01/druid_features.rst:39
# 84d80bb5adf242508ff9f83006cc5624
msgid "왼쪽의 원본 이벤트 목록은 2011년 1월 1일 00:00:00~01:00:00 사이에 발생한 도메인 클릭 이벤트를 열거한 것입니다. 하지만 분석가 입장에서는 분 이하 단위의 개별 이벤트가 별다른 의미를 갖지 못하기 때문에 1시간의 granularity를 기준으로 데이터를 취합했습니다. 그 결과 오른쪽 테이블에 나타난 것처럼 2011년 1월 1일 00~01시 시간대에 각 도메인을 남성과 여성이 각각 클릭한 횟수를 보여주는 보다 의미 있는 결과물이 도출되었습니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:41
# 0d4a188d55144beaa6d63a23db35ff9f
msgid "또한 데이터 roll-up은 원천 데이터의 저장 용량을 최소함으로써(많게는 100배까지도 축소 가능), 스토리지 리소스를 절약하고 쿼리 속도를 빠르게 합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:43
# 207022a65842492c99e6768aec52dace
msgid "그러나 데이터를 roll-up하면 개별 이벤트들에 대해 쿼리할 수 없게 됩니다. roll-up granularity는 데이터를 탐색할 수 있는 최소 단위가 되며 이벤트들은 이러한 granularity 단위로 배열됩니다. granularity 단위는 사용자가 원하는 대로 설정할 수 있으며, 원치 않으면 roll-up을 비활성화하고 모든 개별 이벤트를 전부 ingestion할 수도 있습니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:47
# bfc9aa9e01d545549664dd793ed5bc2d
msgid "데이터 sharding"
msgstr ""

#: ../../discovery/part01/druid_features.rst:49
# 3f96e2284fdb45468c55026ff1a0d76b
msgid "데이터 소스는 시계열 이벤트들의 집합으로서 여러 shard로 분할 저장되는데, Druid에서는 이를 '세그먼트'라고 부르며 각 세그먼트는 대개 500~1,000만 행으로 이루어집니다. Druid는 데이터 소스들을 정의된 시간 간격(통상적으로 1시간이나 하루)을 기준으로 분할하며, 그 밖의 컬럼에 있는 값들을 기준으로 추가 분할을 실시함으로써 세그먼트 크기를 적절하게 맞출 수 있습니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:51
# f8588438ef424d348320c422afa821d3
msgid "아래는 1시간 단위로 분할된 데이터 테이블을 예시로 나타낸 것입니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:53
# eaf7130cf228412ab16126e5391abdeb
msgid "세그먼트 ``sampleData_2011-01-01T01:00:00:00Z_2011-01-01T02:00:00:00Z_v1_0``: ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:58
# f3fc0690dadd44069dfadd7dfcdc3c0f
msgid "세그먼트 ``sampleData_2011-01-01T02:00:00:00Z_2011-01-01T03:00:00:00Z_v1_0``: ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:63
# bc9d542e216f4705924adb7bf09d68d7
msgid "이와 같이 시간 단위로 세그먼트를 구분하는 것은 데이터 소스 내의 모든 이벤트에 타임스탬프가 포함되기 때문에 가능합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:65
# 95df0ff8de604d5aae234e8bb7c6f403
msgid "세그먼트는 Druid 테이블의 기본 저장 단위에 해당하며, 클러스터 내 데이터의 복제(replication) 및 분산은 세그먼트 단위로 이루어집니다. 세그먼트 내 데이터는 변경할 수 없도록 되어 있습니다. 이렇게 함으로써 읽기와 쓰기 동작 사이에 경합이 발생하지 않게 됩니다. Druid의 세그먼트는 매우 신속하게 읽히기 위한 읽기 전용 데이터셋입니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:67
# e3201bd0c81143dcb8f5e3d3b474cbb0
msgid "뿐만 아니라, 이러한 데이터 세그먼트 분할은 Druid 분산 환경에서의 병렬 처리를 위한 핵심 역할을 합니다. 각 CPU가 한 번에 하나의 세그먼트를 스캔할 수 있기 때문에 데이터를 여러 세그먼트로 분할하면 이를 여러 CPU가 동시에 병렬적으로 스캔할 수 있으므로, 쿼리 결과를 신속하게 반환하고 부하를 안정적으로 분산시킬 수 있게 됩니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:72
# fbdba0438c664970ab556fc2b59b9ad7
msgid "데이터 저장 포맷 및 인덱싱"
msgstr ""

#: ../../discovery/part01/druid_features.rst:74
# 103e6cf11cb1483cbca4b10fbf2fe5ea
msgid "Druid의 데이터 구조를 분석 쿼리에 최적화시키는 주요 요소 중 하나는 Druid가 데이터를 저장하는 방식입니다. 본 절에서는 설명을 위해 아래의 Druid 테이블 예시를 사용합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:80
# 27e18d1aac2147939bc72d9b2f83828b
msgid "Source: Druid: A Real-time Analytical Data Store"
msgstr ""

#: ../../discovery/part01/druid_features.rst:83
# 2ef4cacd74ec4f6c8b49827cab4e23a0
msgid "컬럼 기반 저장 및 인덱싱"
msgstr ""

#: ../../discovery/part01/druid_features.rst:85
# 4c7fa65d8b704210a1d75b843368224d
msgid "Druid는 컬럼들을 각각 따로 저장합니다. Druid가 주로 이벤트 스트림을 집계하는 데 사용된다는 점을 고려할 때, 이러한 컬럼 기반 저장 방식을 취하면 각 쿼리에 관련된 컬럼만을 로드·스캔하므로 CPU 리소스를 보다 효율적으로 사용할 수 있습니다. 행 기반 데이터 스토어에서는 집계 시 대상 행과 관련된 모든 컬럼을 컬럼별로 상이한 방식으로 압축할 수 있으며 그에 따라 각기 다른 인덱스를 활용함으로써 컬럼을 메모리나 디스크에 저장하는 데 드는 리소스 비용을 줄일 수 있습니다. 위 예에서 page, user, gender, city 컬럼은 문자열만을 포함합니다. 직접 문자열들을 저장하는 것은 불필요한 비용을 발생시키므로 이들을 고유한 정수 식별자로 매핑할 수 있습니다. 예를 들면, ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:90
# 67c02e11f8aa42f0a33cf1f64eb02f94
msgid "이 매핑을 사용하면 page 컬럼을 정수 배열로 나타낼 수 있는데, 여기서 배열 인덱스 각각은 원본 데이터셋의 각 행에 해당합니다. page 컬럼의 경우, 각 행의 page 값을 아래와 같이 표시할 수 있습니다. ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:94
# b391784ae20c4dd393e0f8711e3927f4
msgid "이처럼 문자열들이 고정 길이 정수들로 바뀌어 저장되므로 압축하기가 훨씬 더 수월합니다. Druid는 각 shard(세그먼트) 단위로 데이터를 인덱싱합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:98
# 50bff07ac65f42c3ba2c0e2120378e54
msgid "데이터 필터링을 위한 인덱싱"
msgstr ""

#: ../../discovery/part01/druid_features.rst:100
# 85c50ab7a4234c0ab8a9554b6c0d177a
msgid "Druid는 검색 인덱스를 추가로 만들어서 문자열 컬럼에 대한 필터링을 용이하게 할 수 있습니다. 위 예시 테이블을 다시 보자. 가령 \"샌프란시스코에 사는 남성 사용자들이 Wikipedia 편집을 한 횟수는?\"과 같은 쿼리가 있을 수 있습니다. 이 쿼리 예시에는 도시(San Francisco)와 성별(Male)이라는 두 가지 차원이 포함됩니다. 각 차원별로 아래와 같은 바이너리 배열이 생성되는데, 여기서 배열 인덱스 각각은 해당 행이 쿼리 필터 조건에 부합하는지 여부를 나타냅니다. ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:105
# a6046ca7180346b9b0d5ade87b7379b6
msgid "그런 다음 쿼리 필터는 이러한 두 배열에 대해 AND 연산을 실시합니다. ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:109
# fd42e548e9c34e4cbb1c0eec11ddc887
msgid "그 결과, 행 1만 스캔 대상이 됩니다. 이런 식으로 필터링된 행만 검색함으로써 불필요한 부하를 방지하는 것입니다. 이러한 바이너리 배열은 압축하기도 매우 쉽습니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:111
# 1ad436d2ba814f5dad4fd86de44e44ef
msgid "이러한 검색 인덱싱은 OR 연산에도 사용할 수 있습니다. 어떤 쿼리가 San Francisco 또는 Calgary을 필터링하는 경우, 배열 인덱스들은 차원값별로 다음과 같을 것입니다. ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:116
# a2941211f2e14a53b7faad0abed69216
msgid "그런 다음 두 배열에 대해 OR 연산이 수행됩니다. ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:120
# 91bc53706c38451b992f808c2a436a14
msgid "그 결과, 쿼리는 행 1과 3만 스캔합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:122
# 84ba68a158d54eceba3068e8e2fe4e26
msgid "대형 비트맵 셋에 boolean 연산을 실시하는 이러한 접근방식은 검색 엔진에서 널리 사용됩니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:128
# 116ece7bd6664b2a84feaeb73a6efcee
msgid "쿼리 언어"
msgstr ""

#: ../../discovery/part01/druid_features.rst:130
# dc7913969bd54ed991d97fb8fe4a4c4c
msgid "Druid의 네이티브 쿼리 언어는 JSON over HTTP이며, 주요 쿼리는 다음과 같습니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:132
# f588b98e8b8b4f059dfcecbf9a31c638
msgid "Group By"
msgstr ""

#: ../../discovery/part01/druid_features.rst:133
# 14f64c21089b408b9c9a1d2f5b71c2b4
msgid "시계열 기반 roll-up"
msgstr ""

#: ../../discovery/part01/druid_features.rst:134
# 26d43c5a161c4ace8a40a9ff323bd41f
msgid "임의적 boolean 필터링"
msgstr ""

#: ../../discovery/part01/druid_features.rst:135
# cc9f2845e93a4297b8fe524b3414839a
msgid "Sum, Min, Max, Avg 등의 집계 연산"
msgstr ""

#: ../../discovery/part01/druid_features.rst:136
# 84efdd41d8e948eda07cfc83831dbc20
msgid "차원값 검색"
msgstr ""

#: ../../discovery/part01/druid_features.rst:138
# 741f03d786004f00bfb37ea88ac45f41
msgid "하지만 이 외에도 SQL을 비롯한 다양한 언어로 이루어진 쿼리 라이브러리가 생성·공유되고있습니다."
msgstr ""

