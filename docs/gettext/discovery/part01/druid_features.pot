# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, metatron team
# This file is distributed under the same license as the metatron discovery docs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: metatron discovery docs 0.4.2\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-06 01:24+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../discovery/part01/druid_features.rst:2
# 7a7cdef0b15143f4a53449b596648b72
msgid "Druid 특징"
msgstr ""

#: ../../discovery/part01/druid_features.rst:5
# 1d13d608544f4dec9a848699890bd109
msgid "데이터 테이블 형태"
msgstr ""

#: ../../discovery/part01/druid_features.rst:7
# 226af06a1d044d9580934ada33c16b17
msgid "Druid의 데이터 테이블(Druid에서는 '데이터 소스'라고 함)은 OLAP 쿼리용으로 설계된 시계열 이벤트들로 구성됩니다. 데이터 소스는 세 종류의 컬럼으로 구성됩니다(여기서는 온라인 광고 데이터를 예시로 사용)."
msgstr ""

#: ../../discovery/part01/druid_features.rst:13
# 7d0fa440311d4a98b395414aa61731b8
msgid "Source: http://druid.io"
msgstr ""

#: ../../discovery/part01/druid_features.rst:15
# 00f7952be28c43ab90ab532563f39eed
msgid "**타임스탬프 컬럼(Timestamp column):** Druid는 데이터 소스에서 타임스탬프 컬럼을 별도로 구성함으로써 모든 쿼리가 시간 축을 중심으로 이루어지게 합니다(시계열 속성이 없는 데이터를 일괄적으로 ingestion할 경우에는 현재 시간을 기준으로 타임스탬프가 부여되어 Druid에서 활용할 수 있는 형태가 됩니다)."
msgstr ""

#: ../../discovery/part01/druid_features.rst:16
# 2ba9c5f859514cfc9091e84acf6bbb80
msgid "**차원 컬럼(Dimension columns):** 차원 컬럼은 각 이벤트의 문자열 속성들을 담고 있으며, 데이터 필터링 시 가장 흔히 사용됩니다. 위 데이터셋 예시에서는 publisher, advertiser, gender, country가 차원 컬럼입니다. 데이터 탐색 시에는 이러한 차원 컬럼들을 축으로 하여 데이터를 slice하게 됩니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:17
# 85888d2d702c4bb498a229f955647267
msgid "**측정값 컬럼(Metric columns):** 측정값 컬럼들은 집계 및 연산에 사용됩니다. 위 예에서는 clicks 및 price가 측정값 컬럼입니다. 측정값 컬럼의 자료형은 대체로 수치 값이며, 이들은 계수, 합산, 평균 등의 방식으로 집계할 수 있습니다(Metatron에서는 지원되는 자료형을 증대하였습니다)."
msgstr ""

#: ../../discovery/part01/druid_features.rst:20
# ee5a8c21d3094631acef5866d9cdaba3
msgid "데이터 ingestion"
msgstr ""

#: ../../discovery/part01/druid_features.rst:22
# f9f7667e13524908b629c34031c800b3
msgid "Druid는 실시간 및 일괄(batch) ingestion을 지원합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:24
# 2f04113fc55f44d78c0abdacf26b7c9c
msgid "이 중에서 실시간 ingestion은 Druid의 주요 특징 중 하나인데, 이를 전담하는 real-time 노드군이 있기 때문에 가능한 것입니다(자세한 설명은 :ref:`realtime_nodes` 참조). 실시간으로 ingestion되는 데이터 스트림 내 이벤트들은 발생 후 수 초 이내에 Druid 클러스터에서 쿼리가 가능한 포맷으로 인덱싱됩니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:29
# cbf56680b7474a1eaa658d26c54c0f29
msgid "데이터 roll-up"
msgstr ""

#: ../../discovery/part01/druid_features.rst:31
# 38dfbda5b12c4fa096bc4d2093154d33
msgid "무수히 많은 개별 이벤트를 단순히 열거하기만 해서는 중요한 의미를 찾을 수 없습니다. 하지만 이러한 데이터를 적절한 시간대를 기준으로 취합하면 유용한 인사이트를 얻을 수 있습니다. Druid는 roll-up이라는 옵션을 통해 ingestion되는 원천 데이터를 취합할 수 있습니다. 아래는 roll-up의 예시를 나타낸 것입니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:37
# d5b4bdcea71446c1b62e771ebdd033db
msgid "Source: Interactive Exploratory Analytics with Druid | DataEngConf SF '17"
msgstr ""

#: ../../discovery/part01/druid_features.rst:39
# c409bdf9afb34e2aa955273a1030473b
msgid "왼쪽의 원본 이벤트 목록은 2011년 1월 1일 00:00:00~01:00:00 사이에 발생한 도메인 클릭 이벤트를 열거한 것입니다. 하지만 분석가 입장에서는 분 이하 단위의 개별 이벤트가 별다른 의미를 갖지 못하기 때문에 1시간의 granularity를 기준으로 데이터를 취합했습니다. 그 결과 오른쪽 테이블에 나타난 것처럼 2011년 1월 1일 00~01시 시간대에 각 도메인을 남성과 여성이 각각 클릭한 횟수를 보여주는 보다 의미 있는 결과물이 도출되었습니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:41
# f57e7f0dbbda4130a01dfd02b3ad9732
msgid "또한 데이터 roll-up은 원천 데이터의 저장 용량을 최소함으로써(많게는 100배까지도 축소 가능), 스토리지 리소스를 절약하고 쿼리 속도를 빠르게 합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:43
# be10c9fb832845d0b5666756754393fa
msgid "그러나 데이터를 roll-up하면 개별 이벤트들에 대해 쿼리할 수 없게 됩니다. roll-up granularity는 데이터를 탐색할 수 있는 최소 단위가 되며 이벤트들은 이러한 granularity 단위로 배열됩니다. granularity 단위는 사용자가 원하는 대로 설정할 수 있으며, 원치 않으면 roll-up을 비활성화하고 모든 개별 이벤트를 전부 ingestion할 수도 있습니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:47
# e80f1eb0b98a4f778c8a1dec098cbcff
msgid "데이터 sharding"
msgstr ""

#: ../../discovery/part01/druid_features.rst:49
# 1b4603f134c14ccca7f94f16679ea96f
msgid "데이터 소스는 시계열 이벤트들의 집합으로서 여러 shard로 분할 저장되는데, Druid에서는 이를 '세그먼트'라고 부르며 각 세그먼트는 대개 500~1,000만 행으로 이루어집니다. Druid는 데이터 소스들을 정의된 시간 간격(통상적으로 1시간이나 하루)을 기준으로 분할하며, 그 밖의 컬럼에 있는 값들을 기준으로 추가 분할을 실시함으로써 세그먼트 크기를 적절하게 맞출 수 있습니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:51
# b9ab540279a742efbc5e02823f7b703f
msgid "아래는 1시간 단위로 분할된 데이터 테이블을 예시로 나타낸 것입니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:53
# 1dc7e134c0cf413597062a9f95b45e08
msgid "세그먼트 ``sampleData_2011-01-01T01:00:00:00Z_2011-01-01T02:00:00:00Z_v1_0``: ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:58
# 8d910331f3734029b31d8625ed10226e
msgid "세그먼트 ``sampleData_2011-01-01T02:00:00:00Z_2011-01-01T03:00:00:00Z_v1_0``: ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:63
# ece8e0b2335e41fba9e184e8ad2bb1b7
msgid "이와 같이 시간 단위로 세그먼트를 구분하는 것은 데이터 소스 내의 모든 이벤트에 타임스탬프가 포함되기 때문에 가능합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:65
# 52a0b01b37304a2daaa8c6911af55a6e
msgid "세그먼트는 Druid 테이블의 기본 저장 단위에 해당하며, 클러스터 내 데이터의 복제(replication) 및 분산은 세그먼트 단위로 이루어집니다. 세그먼트 내 데이터는 변경할 수 없도록 되어 있습니다. 이렇게 함으로써 읽기와 쓰기 동작 사이에 경합이 발생하지 않게 됩니다. Druid의 세그먼트는 매우 신속하게 읽히기 위한 읽기 전용 데이터셋입니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:67
# c78400a0d1704d3baf889aa02fb09c18
msgid "뿐만 아니라, 이러한 데이터 세그먼트 분할은 Druid 분산 환경에서의 병렬 처리를 위한 핵심 역할을 합니다. 각 CPU가 한 번에 하나의 세그먼트를 스캔할 수 있기 때문에 데이터를 여러 세그먼트로 분할하면 이를 여러 CPU가 동시에 병렬적으로 스캔할 수 있으므로, 쿼리 결과를 신속하게 반환하고 부하를 안정적으로 분산시킬 수 있게 됩니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:72
# 43d4155b50434055bb53bf1538f543db
msgid "데이터 저장 포맷 및 인덱싱"
msgstr ""

#: ../../discovery/part01/druid_features.rst:74
# f6a7255835a64bc2a7cce1c64ea96f34
msgid "Druid의 데이터 구조를 분석 쿼리에 최적화시키는 주요 요소 중 하나는 Druid가 데이터를 저장하는 방식입니다. 본 절에서는 설명을 위해 아래의 Druid 테이블 예시를 사용합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:80
# 3f73d4f65d9442abbaa761d34dcaac58
msgid "Source: Druid: A Real-time Analytical Data Store"
msgstr ""

#: ../../discovery/part01/druid_features.rst:83
# 66330a48c51742c5a283f15648be3251
msgid "컬럼 기반 저장 및 인덱싱"
msgstr ""

#: ../../discovery/part01/druid_features.rst:85
# 269f2ca2413a4801a36529bc73a88ba4
msgid "Druid는 컬럼들을 각각 따로 저장합니다. Druid가 주로 이벤트 스트림을 집계하는 데 사용된다는 점을 고려할 때, 이러한 컬럼 기반 저장 방식을 취하면 각 쿼리에 관련된 컬럼만을 로드·스캔하므로 CPU 리소스를 보다 효율적으로 사용할 수 있습니다. 행 기반 데이터 스토어에서는 집계 시 대상 행과 관련된 모든 컬럼을 컬럼별로 상이한 방식으로 압축할 수 있으며 그에 따라 각기 다른 인덱스를 활용함으로써 컬럼을 메모리나 디스크에 저장하는 데 드는 리소스 비용을 줄일 수 있습니다. 위 예에서 page, user, gender, city 컬럼은 문자열만을 포함합니다. 직접 문자열들을 저장하는 것은 불필요한 비용을 발생시키므로 이들을 고유한 정수 식별자로 매핑할 수 있습니다. 예를 들면, ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:90
# a9657c7c12f0499d93f4990a38e13c97
msgid "이 매핑을 사용하면 page 컬럼을 정수 배열로 나타낼 수 있는데, 여기서 배열 인덱스 각각은 원본 데이터셋의 각 행에 해당합니다. page 컬럼의 경우, 각 행의 page 값을 아래와 같이 표시할 수 있습니다. ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:94
# 5d82688b6aa948eabdad680d589acb80
msgid "이처럼 문자열들이 고정 길이 정수들로 바뀌어 저장되므로 압축하기가 훨씬 더 수월합니다. Druid는 각 shard(세그먼트) 단위로 데이터를 인덱싱합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:98
# e935bd1e12804ecea2134507fac51a63
msgid "데이터 필터링을 위한 인덱싱"
msgstr ""

#: ../../discovery/part01/druid_features.rst:100
# b262463f7f754c4a8e4a5756cbc39eb2
msgid "Druid는 검색 인덱스를 추가로 만들어서 문자열 컬럼에 대한 필터링을 용이하게 할 수 있습니다. 위 예시 테이블을 다시 보자. 가령 \"샌프란시스코에 사는 남성 사용자들이 Wikipedia 편집을 한 횟수는?\"과 같은 쿼리가 있을 수 있습니다. 이 쿼리 예시에는 도시(San Francisco)와 성별(Male)이라는 두 가지 차원이 포함됩니다. 각 차원별로 아래와 같은 바이너리 배열이 생성되는데, 여기서 배열 인덱스 각각은 해당 행이 쿼리 필터 조건에 부합하는지 여부를 나타냅니다. ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:105
# 81add1686fa24080ad90dc9a20c15d32
msgid "그런 다음 쿼리 필터는 이러한 두 배열에 대해 AND 연산을 실시합니다. ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:109
# 764b4ea586af4859ae3abbfe0c4ecb7b
msgid "그 결과, 행 1만 스캔 대상이 됩니다. 이런 식으로 필터링된 행만 검색함으로써 불필요한 부하를 방지하는 것입니다. 이러한 바이너리 배열은 압축하기도 매우 쉽습니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:111
# 4bca1b41dd6440acbe4bf0bada1fb828
msgid "이러한 검색 인덱싱은 OR 연산에도 사용할 수 있습니다. 어떤 쿼리가 San Francisco 또는 Calgary을 필터링하는 경우, 배열 인덱스들은 차원값별로 다음과 같을 것입니다. ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:116
# 09fae6efee0a4a8088846cb909a9a7bf
msgid "그런 다음 두 배열에 대해 OR 연산이 수행됩니다. ::"
msgstr ""

#: ../../discovery/part01/druid_features.rst:120
# 17b3030bd5ec4e87b3eca81364b4a456
msgid "그 결과, 쿼리는 행 1과 3만 스캔합니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:122
# f6215e766ce345028469dbdfe01648e7
msgid "대형 비트맵 셋에 boolean 연산을 실시하는 이러한 접근방식은 검색 엔진에서 널리 사용됩니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:128
# b399e8dc0c954feaa71ad711b4387700
msgid "쿼리 언어"
msgstr ""

#: ../../discovery/part01/druid_features.rst:130
# d0e58e4e5d294c95a82e0bcee42a4795
msgid "Druid의 네이티브 쿼리 언어는 JSON over HTTP이며, 주요 쿼리는 다음과 같습니다."
msgstr ""

#: ../../discovery/part01/druid_features.rst:132
# 5dbe700fc75a431aa76a8d6dc1ee9e9b
msgid "Group By"
msgstr ""

#: ../../discovery/part01/druid_features.rst:133
# a841dcd2c6b9410395aca287370e41e0
msgid "시계열 기반 roll-up"
msgstr ""

#: ../../discovery/part01/druid_features.rst:134
# 99f88fda5cc549f0ab201c1a32b685f8
msgid "임의적 boolean 필터링"
msgstr ""

#: ../../discovery/part01/druid_features.rst:135
# 0b99ee20836c44a6b43e36d4e023d156
msgid "Sum, Min, Max, Avg 등의 집계 연산"
msgstr ""

#: ../../discovery/part01/druid_features.rst:136
# 49e39aa23d7b400690cb2ecf3dd6d7a3
msgid "차원값 검색"
msgstr ""

#: ../../discovery/part01/druid_features.rst:138
# c2b94374ad5f42c5856499254393cfc7
msgid "하지만 이 외에도 SQL을 비롯한 다양한 언어로 이루어진 쿼리 라이브러리가 생성·공유되고있습니다."
msgstr ""

