# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, SK Telecom
# This file is distributed under the same license as the Metatron User Manual package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Metatron User Manual 0.4.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-11 16:43+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../discovery/part01/druid_nodes.rst:2
# f97983a026d542539c23f3174fa4151a
msgid "Druid 기본 클러스터 아키텍쳐"
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:4
# 50fe2ce143894fce8931db25089565ad
msgid "Druid 클러스터는 여러 유형의 노드군으로 구성되며, 각 유형의 노드군별로 고유의 역할을 수행합니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:13
# 273b2442bd7e4228b464b3720195c54e
msgid "Real-time 노드"
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:15
# b7c30c13ddf44cb1896da79e746c4494
msgid "real-time 노드군은 이벤트 스트림을 ingestion하고 쿼리하는 기능을 합니다. 이 노드들은 최근 발생한 짧은 시간 범위 내 이벤트들만을 처리하며, 주기적으로 이들을 딥 스토리지로 넘기는데, 그 절차는 다음과 같습니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:21
#: ../../discovery/part01/druid_nodes.rst:45
#: ../../discovery/part01/druid_nodes.rst:66
# ffe201b31e804e04984f7b3e7d3d68f7
# 14dfdfe78f8d445f9f601e9a9b0604df
# 70e29e7940fe4d1fa25df41eee420a16
msgid "Source: Druid: A Real-time Analytical Data Store"
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:23
# 1937d09a38c842449b224fc39703aa61
msgid "유입되는 이벤트들은 메모리에 인덱싱되면서 즉시 쿼리에 사용될 수 있습니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:24
# ac3fef1f47ed47ea9a36113bad3d0c96
msgid "메모리 상의 데이터는 정기적으로 디스크에 저장되면서 수정 불가능한(읽기 전용) 컬럼형 포맷으로 변환됩니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:25
# d15afbc902b74ffab9b1c99f27cf6207
msgid "저장된 데이터는 off-heap 메모리로 로드되기 때문에 쿼리 가능한 상태가 유지됩니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:26
# 64711305aed54bbca79d15bc530eea3d
msgid "디스크에 저장된 인덱스들을 주기적으로 병합되어 데이터 '세그먼트'를 구성한 후 딥 스토리지로 이관됩니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:28
# dad9b56584844aa792f5c599d0d6cb58
msgid "이런 식으로 real-time 노드로 ingestion된 모든 이벤트는 디스크 저장 전후를 막론하고 on-heap 또는 off-heap 메모리 상에 존재하므로 쿼리가 가능한 상태를 유지합니다(쿼리는 메모리 상의 인덱스와 디스크에 저장된 인덱스 모두에 전달됩니다). 이러한 real-time 노드 기능을 통해 Druid는 실시간 데이터 ingestion을 수행할 수 있습니다. 즉, 이벤트들이 발생하면 곧 이어서 쿼리 대상이 됩니다. 그리고 이러한 과정에서 데이터 손실이 발생하지 않습니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:30
# 89f44e27a221403681b15273edb9adc3
msgid "real-time 노드는 Druid 클러스터 내 다른 노드들과의 유기적인 동작을 위해 자신의 온라인 상태와 처리 중인 데이터를 Zookeeper(:ref:`external_dependencies` 참조)에 보고합니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:35
# b5e94399b7d54d629f933ce4c34c808e
msgid "Historical 노드"
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:37
# ccc20603ccb447148c12fc6f0959ff00
msgid "historical 노드군은 real-time 노드가 생성한 읽기 전용 데이터 블록(세그먼트)을 로드하고 처리하는 기능을 합니다. 이 노드들은 딥 스토리지에서 읽기 전용 세그먼트를 다운로드하고 이에 대한 쿼리를 처리합니다(예: 데이터 집계/필터링). 이 노드들은 shared-nothing 아키텍쳐에 기반하며 동작이 단순합니다. 이들 간에는 경합이 발생하지 않으며 단순히 Zookeeper의 지시에 따라 세그먼트를 로드, 드롭, 처리할 뿐입니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:39
# cdf88e898d034d878075e906403642de
msgid "historical 노드가 쿼리를 처리하는 프로세스는 다음과 같습니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:47
# 7bfbb4d151a34860a684678728957bc4
msgid "쿼리를 받으면 historical 노드는 우선 자신에게 이미 어떤 세그먼트가 존재하는지에 관한 정보를 보관하는 로컬 캐시를 확인합니다. 어떤 세그먼트에 관한 정보가 캐시에 없으면 노드는 딥 스토리지에서 해당 세그먼트를 다운로드합니다. 그런 다음, 해당 세그먼트는 Zookeeper에서 선언되어 쿼리가 가능한 대상이 되며, 노드는 이 세그먼트에 대해 요청된 쿼리를 수행합니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:49
# cf25b951af204617b10d351bd825e989
msgid "historical 노드는 읽기 전용 데이터만을 다루므로 read consistency를 보장할 수 있습니다. 읽기 전용 데이터 블록들은 또한 단순한 병렬 모델을 가능케 합니다. 즉, historical 노드들은 읽기 전용 데이터 블록들을 서로 간섭하지 않고 동시에 스캔·집계할 수 있습니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:51
# 644f26f4617a4d5395ea0ba4f7d8ca4d
msgid "real-time 노드와 마찬가지로 historical 노드들도 자신들의 온라인 상태와 처리 중인 데이터를 Zookeeper에 보고합니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:56
# 44afca728bff4413a21ed3ccb4118a75
msgid "Broker 노드"
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:58
# 1210f7c80ab2413086cc347b2a57ebaf
msgid "broker 노드군은 Zookeeper에 보고된 메타데이터를 통해 어떤 세그먼트들이 쿼리 가능한지와 이 세그먼트들이 각각 어디에 저장되어 있는지를 파악합니다. broker 노드들은 입력된 쿼리들의 경로를 지정함으로써 각 쿼리가 올바른 historical 또는 real-time 노드에 도달되게끔 합니다. 그런 다음 historical 및 real-time 노드 각각에서 산출된 결과들을 취합하여 최종 쿼리 결과를 호출자에게 반환합니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:60
# e88bd39ecf16481d81e85b4a0cb3de1f
msgid "broker 노드는 리소스 효율성을 높이기 위해 다음과 같이 캐시를 사용합니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:68
# 711e56072f7e42f6bdbdb4c6a15fe1c6
msgid "어떤 쿼리가 여러 세그먼트를 포괄할 경우 broker 노드는 캐시에 이미 존재하는 세그먼트들을 우선 확인합니다. 그리고 캐시에 없는 세그먼트들에 대해서는 그것이 보관된 historical 및 real-time 노드로 쿼리를 전달합니다. historical 노드들이 결과를 반환하면, broker 노드는 이 결과를 나중에 사용할 수 있도록 세그먼트별로 캐시에 저장합니다. real-time 노드의 데이터는 캐시에 저장되지 않으며, 따라서 real-time 데이터에 대한 요청은 항상 real-time 노드로 전달됩니다. real-time 노드의 데이터는 가변적이기 때문에 그 결과를 캐시에 저장하는 것은 안정적이지 않기 때문입니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:73
# 05f2a905cc2444afa07df5c70f0fc581
msgid "Coordinator 노드"
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:75
# 79fb08100cdf429ea255f7848c501db1
msgid "coordinator 노드군은 주로 historical 노드 데이터의 관리 및 분산을 담당합니다. coordinator 노드는 어떤 historical 노드가 어떤 세그먼트에 대해 쿼리를 수행할지 결정하고 이들에게 새 데이터를 로드하고, 기한이 지난 데이터를 드롭하고, 데이터를 복제하고, 데이터를 이동하여 부하 밸런스를 맞추도록 지시합니다. 이렇게 함으로써 분산형 historical 노드 그룹에서 빠르고 효율적이며 안정으로 데이터를 처리할 수 있습니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:77
# 27aac92dab1145eabdbaf67e5fe6a5f5
msgid "다른 모든 Druid 노드와 마찬가지로, coordinator 노드들도 Zookeeper 연결을 유지함으로써 클러스터의 현황을 파악합니다. coordinator 노드들은 MySQL 데이터베이스와의 연결도 유지하는데, 이 데이터베이스에서는 클러스터 내 세그먼트의 생성, 소멸, 복제 규칙과 같은 추가적인 연산 매개변수 및 구성 정보를 관리합니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:79
# b5ef2bd876414bbf99355c7e6ba23c12
msgid "Druid 클러스터의 안정성을 위해 coordinator 노드는 이중화되며 일반적으로 하나의 coordinator 노드만 활성 상태를 유지합니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:84
# aa3e0a4d9eac49799ddc972c7496d30c
msgid "외부 종속 모듈"
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:86
# 365c4691d5f446fb8b71669189d343e0
msgid "Druid는 클러스터 동작을 위해 몇 가지 외부 종속 모듈을 사용합니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:88
# 19643a2b055648049cd55d9367e7c932
msgid "**Zookeeper:** Druid는 Zookeeper를 통해 클러스터 내부 통신을 합니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:89
# dd64f8c80a71480fab40688668c343b2
msgid "**메타데이터 스토리지:** Druid는 메타데이터 스토리지를 통해 데이터 세그먼트 및 구성에 관한 메타데이터를 저장합니다. 메타데이터 스토리지로는 주로 MySQL과 PostgreSQL이 사용됩니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:90
# a69e1e0f821b40259dad8087f0a1ce39
msgid "**딥 스토리지:** Druid 세그먼트들을 영구적으로 백업 저장하는 공간입니다. Druid에 ingestion되는 데이터는 세그먼트 형태로 딥 스토리지에 업로드되고, historical 노드들이 필요한 세그먼트를 여기서 다운로드합니다. 딥 스토리지로는 주로 S3 및 HDFS가 사용됩니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:95
# 8829130e12ad4fff8c23bf492c6f520a
msgid "High Availability 특성"
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:97
# 74bcefbb256d402daa87b8952ab6198b
msgid "Druid는 어느 한 노드가 고장난다고 해서 클러스터의 동작이 중단되지 않도록 설계되었습니다. 또한 서로 다른 유형의 노드군끼리도 상호 간에 상당히 독립적이기 때문에, 클러스터 내부에 통신 장애가 생겨도 데이터 가용성에는 최소한의 영향만을 미칩니다. Druid 클러스터에서 highly availability를 확보하려면, 노드군별로 2개 이상의 노드가 구성되어야 합니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:102
# b82ef041051a4677a499d5ebbe3d4caa
msgid "아키텍쳐 확장성"
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:104
# 896d445eea89483a991fe2e5a9ad93d8
msgid "Druid는 위에서 소개한 기본 아키텍쳐에 다양한 외부 모듈을 추가할 수 있는 모듈 확장형 플랫폼을 지향합니다. 아래는 Druid의 확장성을 활용한 모듈 조합의 예시입니다."
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:110
# c2b94f77ec774fdfa2ce7a07ce968a77
msgid "Source: MetaMarkets - Introduction to Druid by Fangjin Yang"
msgstr ""

#: ../../discovery/part01/druid_nodes.rst:112
# ec7112a8969948ee9331001d93895b4a
msgid "Metatron Discovery 엔진도 역시 비즈니스 인텔리전스를 위한 end-to-end 솔루션으로서 기능하기 위해 Druid 엔진 전후단에 다양한 모듈을 추가한 것입니다."
msgstr ""

