%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\renewcommand{\baselinestretch}{1.4}
\usepackage[cjk]{kotex}
\setmainfont{NanumBarunGothic}[
	BoldFont       = *Bold,
]
\setsansfont{NanumBarunGothic}[
	BoldFont       = *Bold,
]
\setmonofont{NanumGothicCoding}[
	BoldFont       = *-Bold,
]


\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Metatron Discovery}}

\usepackage{sphinxmessages}




\title{metatron-doc-user Documentation}
\date{2019년 11월 20일}
\release{0.4.3}
\author{metatron team}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{출시 버전}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\part{Metatron Discovery}
\label{\detokenize{index:metatron-discovery}}

\chapter{디스커버리 퀵가이드}
\label{\detokenize{discovery/part00/index:id1}}\label{\detokenize{discovery/part00/index::doc}}
Metatron Discovery는 대용량 데이터를 동일한 환경에서 적재, 전처리, 분석까지 빠르게 처리할 수 있는 툴입니다. 데이터 분석을 위한 기술적인 지식이 없는 비즈니스 현업 사용자도 Metatron Discovery를 이용하면 직접 데이터를 다뤄보고 빠르게 시각화해 보면서 인사이트를 얻을 수 있습니다.

Metatron Discovery로 즉시 데이터 분석을 시작할 수 있는 방법은 두 가지가 있습니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{방법 1:} \sphinxhref{https://metatron.app}{Metatron Discovery 데모 사이트}를 실행하세요. ID와 password는 'metatron'이라고 입력하면 됩니다.

\item {} 
\sphinxstylestrong{방법 2:} 싱글 모드용 Metatron Discovery를 로컬 PC에 다운로드 받으세요. \sphinxhref{https://metatron.app/download/}{다운로드}는 세 가지 방법으로 제공됩니다.
\begin{itemize}
\item {} 
\sphinxhref{https://metatron.app/download/installation-guide-custom-install/}{Custom install}: Github 레파지토리로부터 소스코드를 다운받거나 빌드 파일을 직접 실행하세요.

\item {} 
\sphinxhref{https://metatron.app/download/guide\_vm/}{Virtual machine}: 가상 머신 이미지로 바로 실행하세요. Windows OS에서도 사용할 수 있습니다.

\item {} 
\sphinxhref{https://metatron.app/download/installation-guide-docker/}{Docker}: Docker 이미지로 빠르게 설치하고 즉시 실행할 수 있습니다.

\end{itemize}

\end{itemize}

아래와 같은 화면을 보고 계신가요? 축하합니다! 이제부터 메타트론 디스커버리와 함께 쉽고 빠르게 데이터 분석을 시작해보세요.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{discovery-main}.png}
\end{figure}
\end{quote}

빠른 시작을 위해서 아래의 세 단계의 스텝으로 튜토리얼을 진행해보세요.


\section{Step1. 데이터 소스 만들기}
\label{\detokenize{discovery/part00/step1:step1}}\label{\detokenize{discovery/part00/step1::doc}}
데이터 분석을 하기 위해 가장 먼저 해야할 일은 데이터를 시스템에 적재하는 것 입니다. Metatron Discovery는 다양한 원천 데이터를 쉽게 적재할 수 있도록 지원합니다.

본 튜토리얼 예제에서는 로컬 파일에 있는 데이터를 적재하는 방법을 소개합니다. 먼저 데이터를 준비하세요. 흔히 쓰이는 엑셀 파일(.xls, .xlsx)또는 .csv 형식의 파일이면 충분합니다. 여기서는 판매 현황 데이터를 활용합니다. 아래 링크에서 다운로드 받으세요.
\begin{quote}

\sphinxcode{\sphinxupquote{sample data (.csv)}}
\end{quote}

데이터 소스는 \sphinxstylestrong{Management} \textgreater{} \sphinxstylestrong{데이터 스토리지} \textgreater{} \sphinxstylestrong{데이터 소스}에서 조회하고 적재할 수 있습니다. 새로운 데이터 소스를 만들기 위해서 데이터 소스 리스트 우측 상단의 \sphinxstylestrong{new} 버튼을 클릭합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{s1-1}.png}
\end{figure}
\end{quote}

일단 튜토리얼에서는 \sphinxstylestrong{파일}을 눌러 로컬 폴더에서 데이터를 가져옵니다. 다른 원천에서 데이터 소스를 만드는 방법은 {\hyperref[\detokenize{discovery/part02/create_a_data_source::doc}]{\sphinxcrossref{\DUrole{doc}{데이터 소스 만들기}}}} 문서를 참조하세요.

분석하고 싶은 데이터를 drag \& drop하거나 디렉토리로부터 불러올 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{s1-2}.png}
\end{figure}
\end{quote}

판매 현황 데이터를 드래그하면 컬럼과 라인 구분자에 따라 나타나는 데이터 샘플을 최대 100행까지 조회할 수 있습니다. 이 데이터는 기본적으로 설정된 구분자로 충분히 데이터를 잘 나타내는 것 같네요! \sphinxstylestrong{다음}을 누릅니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{s1-3}.png}
\end{figure}
\end{quote}

이제 실제로 데이터를 보면서 컬럼의 타입을 알맞게 조정해야 합니다. 이 작업을 \sphinxstylestrong{데이터 스키마 구성}이라고 부릅니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{s1-4}.png}
\end{figure}
\end{quote}

각 컬럼은 '차원값'(dimension) 또는 '측정값'(measure)이라는 역할로 나뉩니다. 자세한 내용은 {\hyperref[\detokenize{discovery/part02/dimension_and_measures::doc}]{\sphinxcrossref{\DUrole{doc}{'차원값'과 '측정값'의 개념}}}} 문서를 참조하세요. 이 데이터에서는 \sphinxcode{\sphinxupquote{Discount}}, \sphinxcode{\sphinxupquote{Profit}}, \sphinxcode{\sphinxupquote{Quantity}}, \sphinxcode{\sphinxupquote{Sales}}, \sphinxcode{\sphinxupquote{DaystoShipActual}}, \sphinxcode{\sphinxupquote{SalesForecast}}, \sphinxcode{\sphinxupquote{DaystoShipScheduled}}, \sphinxcode{\sphinxupquote{SalesperCustomer}}, \sphinxcode{\sphinxupquote{ProfitRatio}} 컬럼들을 측정값으로 변경해야 합니다.

그 다음은 컬럼의 데이터 타입을 적절하게 변경해 주어야 합니다. 기본적으로 차원값은 문자로, 측정값은 정수로 설정되어 있습니다. 데이터 샘플을 보면서 가장 알맞는 형식으로 변경해주세요. 아래에 이 데이터에서 변경할 사항들을 나열했습니다.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{Orderdate}} : 날짜/시간

\item {} 
\sphinxcode{\sphinxupquote{Discount}} : 소수

\item {} 
\sphinxcode{\sphinxupquote{ShipDate}} : 날짜/시간 (시간 표현을 yyyy. MM. dd. 로 변경한 후 체크박스 클릭하여 유효성 확인)

\item {} 
\sphinxcode{\sphinxupquote{SalesperCustomer}} : 소수

\item {} 
\sphinxcode{\sphinxupquote{ProfitRatio}} : 소수

\item {} 
\sphinxcode{\sphinxupquote{latitude}} : 위도

\item {} 
\sphinxcode{\sphinxupquote{longitude}} : 경도

\end{itemize}

마지막으로 새로운 컬럼을 만들어 줄 차례입니다. 우리는 위도와 경도 컬럼을 갖고 있으므로 Point 타입의 컬럼을 새로 만들 수 있습니다. 우측 상단의 \sphinxstylestrong{컬럼 추가} 버튼을 누르세요. \sphinxstylestrong{위도} 컬럼에 \sphinxcode{\sphinxupquote{latitude}} 컬럼을 선택하고, \sphinxstylestrong{경도} 컬럼에 \sphinxcode{\sphinxupquote{longitude}} 컬럼을 선택합니다. 컬럼 이름을 적절하게 입력한 후 \sphinxstylestrong{추가}를 누르세요. 새로운 Point 타입 컬럼이 생성되었습니다!
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{s1-5}.png}
\end{figure}
\end{quote}

스키마 구성 작업이 마무리되었으면 \sphinxstylestrong{다음}을 누릅니다. 필요한 경우 Druid의 수집 설정을 변경하는 작업입니다. 지금은 기본 설정으로도 충분합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{s1-6}.png}
\end{figure}
\end{quote}

마지막으로 데이터 소스의 \sphinxstylestrong{이름}과 \sphinxstylestrong{설명}을 입력합니다. \sphinxstylestrong{마침}을 누르면 즉시 데이터 소스 상세로 넘어갑니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{s1-7}.png}
\end{figure}
\end{quote}

데이터 소스 상세에서는 적재 현황을 실시간으로 볼 수 있습니다. 몇 분 기다리면 아래와 같이 적재가 성공했음을 알리며 히스토그램이 나타납니다. 혹시 다른 데이터 소스를 적재하다 에러가 났을 경우 \sphinxstylestrong{상세} 링크를 클릭하여 Druid 적재 로그를 조회할 수 있습니다. 컬럼명 중복, 컬럼 타입과 불일치하는 데이터 등으로 인해 적재가 실패할 수 있습니다. 이 경우 원인을 찾아 다시 적재를 시도해보아야 합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{s1-8}.png}
\end{figure}
\end{quote}

이 데이터 소스를 다른 사용자들에게 오픈하려면 \sphinxstylestrong{할당}에서 \sphinxstylestrong{모든 워크스페이스에 데이터소스를 사용하도록 허용} 체크박스에 체크합니다. 모든 사용자가 아니라 특정 사용자들에게만 오픈하고 싶으면 \sphinxstylestrong{수정}을 클릭하여 할당하고자 하는 개인 사용자들 또는 팀 워크스페이스를 선택합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{s1-9}.png}
\end{figure}
\end{quote}

이 예제에서는 모든 사용자가 사용할 수 있도록 \sphinxstylestrong{Open Data}로 설정하겠습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{s1-10}.png}
\end{figure}
\end{quote}

적재된 데이터는 \sphinxstylestrong{데이터} 탭에서 조회할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{s1-11}.png}
\end{figure}
\end{quote}

축하합니다! 이제 데이터 소스를 사용해 볼 차례네요. 다음 스텝으로 넘어가볼까요?
\begin{itemize}
\item {} 
{\hyperref[\detokenize{discovery/part00/step2::doc}]{\sphinxcrossref{\DUrole{doc}{Step2. 워크북 만들기}}}}

\end{itemize}


\section{Step2. 워크북 만들기}
\label{\detokenize{discovery/part00/step2:step2}}\label{\detokenize{discovery/part00/step2::doc}}
분석을 위한 데이터가 준비되었나요? 그럼 이제 워크북을 만들 차례입니다. 워크북은 데이터 시각화 기능을 포함하는 모듈입니다. 좌측 상단의 Metatron Discovery 로고를 클릭하면 메인 화면인 내 개인 워크스페이스로 이동합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{tt02}.png}
\end{figure}
\end{quote}

우측 하단의 \sphinxstylestrong{+ 워크북} 버튼을 눌러 워크북을 만들어 볼까요? 만들 워크북의 이름과 설명을 입력합니다. 워크북을 만드는 즉시 이어서 대시보드를 만들도록 체크박스에 표시가 되어 있습니다. 여기서 각 워크북은 여러 개의 대시보드를 포함하고, 각 대시보드는 또 여러 개의 차트를 포함하는 구조입니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{tt03}.png}
\end{figure}
\end{quote}

이어서 대시보드를 만들어야 합니다. 대시보드에는 시각화할 데이터 소스가 있어야 합니다. 이 데이터 소스는 단일 소스이거나, join으로 연결된 데이터 소스일 수도 있습니다. 더 자세한 내용은 {\hyperref[\detokenize{discovery/part04/create_a_dashboard::doc}]{\sphinxcrossref{\DUrole{doc}{대시보드 만들기}}}} 문서를 참고하세요. 본 튜토리얼에서는 Step1에서 적재한 \sphinxcode{\sphinxupquote{판매현황 데이터}} 하나만 사용합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{tt03-2}.png}
\end{figure}
\end{quote}

\sphinxstylestrong{+데이터 소스 추가} 버튼을 누르면 데이터 소스 선택 팝업이 나타납니다. \sphinxcode{\sphinxupquote{판매현황 데이터}}를 검색하거나 \sphinxstylestrong{오픈 데이터만 보기}에 체크하여 공개된 데이터 중에서 찾아냅니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{tt04}.png}
\end{figure}
\end{quote}

마지막으로 대시보드의 \sphinxstylestrong{이름}과 \sphinxstylestrong{설명}을 입력합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{tt03-3}.png}
\end{figure}
\end{quote}

워크북 내에 대시보드가 생성되었습니다! 이제 이 위젯들을 추가해서 대시보드를 구성하는 일만 남았네요.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{tt06}.png}
\end{figure}
\end{quote}

다음 단계로 넘어가 볼까요?
\begin{itemize}
\item {} 
{\hyperref[\detokenize{discovery/part00/step3::doc}]{\sphinxcrossref{\DUrole{doc}{Step3. 대시보드 구성하기}}}}

\end{itemize}


\section{Step3. 대시보드 구성하기}
\label{\detokenize{discovery/part00/step3:step3}}\label{\detokenize{discovery/part00/step3::doc}}
마지막 단계는 빈 대시보드에 차트 위젯, 텍스트 위젯, 필터 위젯을 생성하여 대시보드를 구성하는 작업입니다. 대시보드 편집은 아래와 같은 순서로 진행됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_chart}.png}
\end{figure}
\end{quote}

이제 앞서 만든 \sphinxcode{\sphinxupquote{판매현황 데이터}}를 이용해 아래와 같이 핵심지표 차트와 선형 차트를 그려 대시보드를 만들어보겠습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ttd}.png}
\end{figure}
\end{quote}

빈 대시보드에서 \sphinxstylestrong{차트} 버튼을 눌러서 차트를 만들어봅시다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ttd-1}.png}
\end{figure}
\end{quote}


\subsection{핵심지표 차트 만들기}
\label{\detokenize{discovery/part00/step3:id1}}
처음 만들어 볼 차트는 핵심지표(KPI) 차트입니다. 핵심지표 차트는 조직의 목표를 가장 직관적으로 보여주는 가장 단순하면서도 강력한 차트입니다. 우리가 만들 대시보드는 판매 현황을 잘 나타내는 것이 목표입니다. 따라서 총 판매액, 예상 총 판매액, 총 이익을 핵심지표 차트로 보여주려고 합니다. 어떻게 해야 할까요? 단순히 Sales, SalesForcast, Profit 세 개의 측정값 컬럼을 데이터 메뉴에서 클릭하세요. 이 작업을 피봇팅(pivoting)이라고 합니다. 피봇된 칼럼들은 자동으로 집계되어 선반에 올라갑니다. 컬럼을 선반에 올리면 즉시 알맞는 차트 종류가 추천됩니다. 추천된 \sphinxstylestrong{핵심지표} 차트를 클릭해 볼까요?
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ttd-3}.png}
\end{figure}
\end{quote}

아래와 같이 핵심지표 차트가 만들어졌습니다. 조금 더 보기 좋게 만들기 위해서 우측의 차트 속성 메뉴를 이용해봅시다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ttd-4}.png}
\end{figure}
\end{quote}

\sphinxincludegraphics{{icon_common}.png}을 눌러 \sphinxstylestrong{공통 설정} 패널에서 각 측정값 컬럼에 아이콘을 추가하고
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ttd-5}.png}
\end{figure}
\end{quote}

\sphinxincludegraphics{{icon_number}.png}을 눌러 \sphinxstylestrong{숫자 포멧} 패널에서 소수점 표기 방식과 약어 표기 방식을 변경해주었습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ttd-6}.png}
\end{figure}
\end{quote}

핵심지표 차트에서 특히 중요한 건 이전 대비 얼마나 성과가 있는지를 파악하는 것 입니다. \sphinxincludegraphics{{icon_aux}.png}을 눌러 \sphinxstylestrong{보조 지표 설정} 패널에서 보조 지표를 설정하고 전월 대비 몇 \%나 잘하고 있는지 확인해보겠습니다. 원한다면 원 지표 대신 보조 지표를 강조할 수도 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ttd-7}.png}
\end{figure}
\end{quote}

\sphinxstylestrong{저장}을 누르면 차트가 대시보드에 나타납니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ttd-8}.png}
\end{figure}
\end{quote}


\subsection{선형 차트 만들기}
\label{\detokenize{discovery/part00/step3:id2}}
그 다음으로 가장 기본적인 차트인 선형 차트를 그려보겠습니다. 시간에 따라 매출과 수익이 어떻게 변하는지 한 눈에 볼 수 있도록 해 볼까요? 다시 \sphinxstylestrong{차트} 버튼을 눌러 새 차트 그리기로 들어갑니다. \sphinxcode{\sphinxupquote{OrderDate}}, \sphinxcode{\sphinxupquote{Profit}}, \sphinxcode{\sphinxupquote{Sales}} 컬럼을 눌러 시간 차원에 따라 값들이 변하는 모습을 보고자 합니다. 추천된 \sphinxstylestrong{선형 차트}를 클릭해보세요.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ttd-9}.png}
\end{figure}
\end{quote}

선형 차트가 그려졌습니다. 차트 속성창을 열어서 라인의 모양을 둥글게 변경해주었습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ttd-10}.png}
\end{figure}
\end{quote}

지금은 \sphinxcode{\sphinxupquote{OrderDate}}의 집계 단위가 시간이라 너무 데이터가 많습니다. 월 단위로 보기 위해서 선반에 올라간 \sphinxcode{\sphinxupquote{OrderDate}} 컬럼의 메뉴에서 \sphinxstylestrong{Granularity}를 \sphinxstylestrong{월(Month)}로 선택해줍니다. 이제 모든 데이터가 보이네요! 우측 상단의 \sphinxstylestrong{미니맵}을 클릭해서 차트에서 미니맵을 제거해줍니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ttd-13}.png}
\end{figure}
\end{quote}

우측 메뉴에서 \sphinxincludegraphics{{icon_coloring}.png}을 눌러 \sphinxstylestrong{색상 설정} 패널에서 색상 설정도 변경해줍니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ttd-16}.png}
\end{figure}
\end{quote}

저장을 누르고 차트를 drag \& drop하여 적절하게 위치를 바꿔주세요. \sphinxstylestrong{텍스트 위젯}도 추가하여 대시보드에 적절한 정보를 추가합니다. \sphinxstylestrong{마침}을 누르면 대시보드 편집이 완료됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ttd-15}.png}
\end{figure}
\end{quote}

본 튜토리얼을 통해 간단한 차트 두 가지를 완성해보았습니다. 대시보드는 인터랙티브하게 동작하여 차트를 선택하거나 필터를 추가하면 원하는 방식으로 프레젠테이션할 수 있습니다. 또 필요할 때마다 언제든지 차트를 수정하거나 추가·삭제할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ttd}.png}
\end{figure}
\end{quote}

이제 Metatron Discovery에 대해 더 알아보시겠어요?
\begin{itemize}
\item {} 
{\hyperref[\detokenize{discovery/part01/overview::doc}]{\sphinxcrossref{\DUrole{doc}{Metatron Discovery 개요}}}}

\item {} 
{\hyperref[\detokenize{discovery/part01/structure::doc}]{\sphinxcrossref{\DUrole{doc}{Metatron Discovery 구성}}}}

\item {} 
{\hyperref[\detokenize{discovery/part01/engine::doc}]{\sphinxcrossref{\DUrole{doc}{Metatron 기본 엔진: Druid}}}}

\end{itemize}


\chapter{Metatron Discovery 소개}
\label{\detokenize{discovery/part01/index:metatron-discovery}}\label{\detokenize{discovery/part01/index::doc}}
Metatron Discovery는 Metatron 운용 서버 클러스터에 적재된 데이터를 단순하면서도 고도화된 방식으로 분석한 후 그 결과를 다양한 형식의 차트와 보고서로 사용자 PC에 출력해주는 솔루션입니다. 웹 템플릿 형식으로 구성되어 있으며 계정이 발급되면 아무 PC에서나 원격으로 접속할 수 있기 때문에 매우 편리한 접근성을 보장합니다.

본 장에서는 Metatron Discovery의 기술 기반과 구조, 그리고 Metatron 기본 엔진인 Druid에 대해 소개합니다.


\section{Metatron Discovery 개요}
\label{\detokenize{discovery/part01/overview:metatron-discovery}}\label{\detokenize{discovery/part01/overview::doc}}
Metatron Discovery는 OLAP, 시각화, 머신러닝 기술이 융합하여 비전문가도 데이터로부터 상위 레벨의 가치를 빠르고 손쉽게 얻을 수 있는 4세대 OLAP 기반 Business Intelligence (BI) 솔루션입니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{intro}.png}
\end{figure}
\end{quote}


\subsection{4세대 BI 솔루션}
\label{\detokenize{discovery/part01/overview:bi}}
아래 그림은 1세대부터 4세대까지의 BI의 흐름을 나타낸 그림입니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{bi}.png}
\end{figure}
\end{quote}

현재 BI 시장은 2세대, 3세대 제품이 주류를 이루고 있으며, 4세대 제품이 주목받고 있습니다. Metatron Discovery는 4세대 BI 솔루션으로서, Self \& Ad-hoc Discovery를 지향하며 빅데이터에 대해서도 빠른 응답 속도를 보장합니다.


\subsection{Big OLAP 기반}
\label{\detokenize{discovery/part01/overview:big-olap}}
Metatron Discovery는 대용량 Fact 데이터를 기준으로 다양한 차원(Dimension) 데이터를 결합하여 하나의 Big OLAP Cube(Mart)를 생성할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{big_olap_cube}.png}
\end{figure}
\end{quote}

Big OLAP Cube로 사용 시, 다음과 같은 장점이 있습니다.
\begin{itemize}
\item {} 
데이터 마트(data mart)의 개수를 최소화
\begin{itemize}
\item {} 
데이터 마트 생성을 위한 ETL 비용 감소

\item {} 
구조 변경에 따른 영향도를 최소화 할 수 있음

\item {} 
Fact 데이터를 모두 저장하므로, 다양한 요구사항에 대응 가능

\end{itemize}

\item {} 
분산 아키텍처 기반으로 큰 규모의 데이터도 저장 가능하며, 빠른 속도로 결과 출력

\item {} 
Dynamic 스키마 채용으로 스키마 변경 시에도 별도의 스키마 재정의가 필요치 않음

\item {} 
실시간 처리 테이블을 원본 그대로 저장하므로 레코드 단위의 실시간 처리 가능

\end{itemize}


\subsection{Metatron Discovery 아키텍처}
\label{\detokenize{discovery/part01/overview:id1}}
Metatron Discovery는 대용량 데이터에 대한 프리퍼레이션(preparation)부터 시각화 기반 데이터 탐색, 고급 분석까지 Data Discovery의 전 과정을 지원하는 End-to-End 솔루션입니다. 아래 그림은 Metatron의 아키텍쳐와 주요 특징을 정리한 것입니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{single_solution}.png}
\end{figure}
\end{quote}


\section{Metatron Discovery 구성}
\label{\detokenize{discovery/part01/structure:metatron-discovery}}\label{\detokenize{discovery/part01/structure::doc}}
Metatron Discovery는 Metatron 운용 서버에 적재된 데이터 소스나 그 밖의 외부 데이터 소스로부터 원하는 데이터를 불러와서 각종 고급 분석 기능을 통해 분석한 후, 그 결과를 다양한 형식의 차트와 보고서로 출력하는 기능을 합니다. 본 모듈을 이용하려면 다음과 같은 전반적인 구조를 이해해야 합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{diagram}.png}
\end{figure}
\end{quote}


\subsection{데이터 프리퍼레이션}
\label{\detokenize{discovery/part01/structure:id1}}
데이터 프리퍼레이션은 원천 데이터에서부터 데이터를 정제 및 가공하여 Metatron으로 적재하는 기능을 제공합니다. 데이터 프리퍼레이션에 대한 자세한 설명은 {\hyperref[\detokenize{discovery/part07/index::doc}]{\sphinxcrossref{\DUrole{doc}{데이터 프리퍼레이션}}}} 항목을 참조하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{prep}.png}
\end{figure}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{prep2}.png}
\end{figure}
\end{quote}


\subsection{데이터 스토리지}
\label{\detokenize{discovery/part01/structure:id2}}
데이터 스토리지는 분석·시각화를 위해 Metatron 엔진에 적재된 데이터를 관리합니다. 데이터 관리 기능에 대한 자세한 설명은 {\hyperref[\detokenize{discovery/part02/index::doc}]{\sphinxcrossref{\DUrole{doc}{데이터 관리}}}} 항목을 참조하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{datasource}.png}
\end{figure}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{datasource2}.png}
\end{figure}
\end{quote}


\subsection{데이터 분석 및 시각화}
\label{\detokenize{discovery/part01/structure:id3}}
아래 각 모듈은 데이터 스토리지에 저장한 데이터를 사용자가 시각화 기반 탐색, 분석하는 기능을 제공합니다.


\subsubsection{워크스페이스}
\label{\detokenize{discovery/part01/structure:id4}}
워크스페이스는 조직 내에서 사용할 워크북, 워크벤치, 노트북을 권한에 따라 관리할 수 있습니다. 워크스페이스 기능에 대한 자세한 설명은 {\hyperref[\detokenize{discovery/part03/index::doc}]{\sphinxcrossref{\DUrole{doc}{워크스페이스}}}} 항목을 참조하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workspace}.png}
\end{figure}
\end{quote}


\subsubsection{워크북, 대시보드, 차트}
\label{\detokenize{discovery/part01/structure:id5}}
워크북은 그 안에 담긴 여러 대시보드와 차트를 PPT처럼 작업하고 이를 공유·프리젠테이션할 수 있게 해주는 모듈입니다. 워크북 기능에 대한 자세한 설명은 {\hyperref[\detokenize{discovery/part04/index::doc}]{\sphinxcrossref{\DUrole{doc}{워크북}}}} 항목을 참조하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard}.png}
\end{figure}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{chart}.png}
\end{figure}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{map}.png}
\end{figure}
\end{quote}


\subsubsection{노트북}
\label{\detokenize{discovery/part01/structure:id6}}
노트북에서는 Machine Learning 기반 고급 분석을 수행할 수 있습니다. 노트북 기능에 대한 자세한 설명은 {\hyperref[\detokenize{discovery/part05/index::doc}]{\sphinxcrossref{\DUrole{doc}{노트북}}}} 항목을 참조하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{notebook_intro}.png}
\end{figure}
\end{quote}


\subsubsection{워크벤치}
\label{\detokenize{discovery/part01/structure:id7}}
SQL 기반 분석을 수행할 수 있습니다. 워크벤치 기능에 대한 자세한 설명은 {\hyperref[\detokenize{discovery/part06/index::doc}]{\sphinxcrossref{\DUrole{doc}{워크벤치}}}} 항목을 참조하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{sql}.png}
\end{figure}
\end{quote}


\subsection{데이터 모니터링}
\label{\detokenize{discovery/part01/structure:id8}}
데이터 쿼리 통계, 쿼리 로그 감사를 통해 데이터 사용에 대한 모니터링 기능을 제공합니다. 데이터 모니터링 기능에 대한 자세한 설명은 {\hyperref[\detokenize{discovery/part02/data_monitoring::doc}]{\sphinxcrossref{\DUrole{doc}{데이터 모니터링}}}} 항목을 참조하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{monitoring}.png}
\end{figure}
\end{quote}


\subsection{사용자 권한 및 계정}
\label{\detokenize{discovery/part01/structure:id9}}
사용자를 추가, 삭제하거나 사용자의 권한을 관리합니다.


\subsection{로그인/로그아웃}
\label{\detokenize{discovery/part01/structure:id10}}
계정을 부여받은 사용자는 Metatron Discovery에 로그인하여 사용 권한에 맞게 자유롭게 이용할 수 있습니다. 로그인 중인 계정은 외부 시스템에서도 로그아웃이 가능합니다.


\section{Metatron 기본 엔진: Druid}
\label{\detokenize{discovery/part01/engine:metatron-druid}}\label{\detokenize{discovery/part01/engine::doc}}
근래에 들어 정보통신 기술의 발전과 함께 데이터 발생량이 비약적으로 증가하였고, 이를 효율적으로 수집·관리·활용하는 것의 중요성이 대두되고 있습니다. 하지만 RDBMS 위주의 레거시 시스템들로는 대용량의 다차원 데이터를 온전히 처리할 수가 없기 때문에 차세대 빅데이터 수요를 충족시키기 위한 새로운 방법론과 솔루션들이 대거 등장하기 시작하였습니다.

미국 실리콘 밸리에 소재한 스타트업 Metamarkets사에서는 2011년 Druid라는 컬럼 기반 분산형 데이터 스토어를 출시하였고 2012년 10월 이를 오픈소스로 전환하였는데, 빠르고 효율적인 데이터 처리를 비롯한 여러 장점 때문에 많은 기업에서 Druid를 backend 기술로 활용하고 있습니다.

이러한 흐름에서 SK텔레콤도 B2C 이동통신 서비스 제공업체로서 매순간 이용자들로부터 발생하는 엄청난 양의 네트워크 데이터를 효과적으로 관리·분석할 필요가 있었으며, 2016년 Druid를 기본 엔진으로 활용한 end-to-end 비즈니스 인텔리전스 솔루션 Metatron을 개발·출시하였습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{druid_logo}.png}
\end{figure}
\end{quote}

본 단원에서는 시계열 데이터 처리에 적합한 Druid의 특징에 대해 알아본 후 SK텔레콤의 Metatron에서 이를 어떤 식으로 적용하고 추가 기능들을 개발하였는지 소개합니다.


\subsection{Druid 개발 배경}
\label{\detokenize{discovery/part01/druid_background:druid}}\label{\detokenize{discovery/part01/druid_background::doc}}
Druid는 대량의 트랜잭션 이벤트(로그 데이터)를 ingestion하고 탐색할 수 있도록 지원하는 엔진으로서 다음과 같은 니즈를 충족하기 위해 개발되었습니다.
\begin{itemize}
\item {} 
개발자들은 어떠한 차원들의 조합에 대한 쿼리라도 즉각적으로 결과가 반환되며, 데이터를 신속히 임의로 slice 및 dice하고 이를 아무 제약 없이 효과적으로 drill down하는 기능을 구현하고자 했습니다. 이러한 기능들은 사용자들이 데이터 대시보드에서 이벤트 스트림들을 interactive한 방식으로 자유롭게 탐색하고 시각화하는 데 필요하였습니다.

\item {} 
개발자들은 이벤트들이 발생하는 즉시 해당 데이터를 ingestion하여 쿼리 가능하도록 인덱싱하는 기능을 원했습니다. 이러한 기능은 사용자들이 데이터를 실시간으로 수집·분석함으로써 시의적절하게 상황을 판단·예측하고 비즈니스 의사 결정을 내릴 수 있도록 하는 데 반드시 필요했습니다. 당시에 Hadoop 등의 유명한 오픈소스 데이터 웨어하우스 시스템들은 sub-second 데이터 ingestion이 불가능했습니다.

\item {} 
개발자들은 multitenancy와 high availability를 보장하고자 했습니다. 이들이 제공하는 서비스의 기반 시스템은 많은 사용자들의 동시 접속을 보장하고, 항상 가동 상태를 유지하며 downtime 없이 모든 고장에 견딜 수 있어야 했습니다. downtime의 존재는 비용을 발생시키며, 소프트웨어 업그레이드나 네트워크 장애 발생 시 사용할 수 없는 시스템으로는 많은 기업의 비즈니스가 불가능합니다.

\end{itemize}


\subsection{Druid 특징}
\label{\detokenize{discovery/part01/druid_features:druid}}\label{\detokenize{discovery/part01/druid_features::doc}}

\subsubsection{데이터 테이블 형태}
\label{\detokenize{discovery/part01/druid_features:id1}}
Druid의 데이터 테이블(Druid에서는 '데이터 소스'라고 함)은 OLAP 쿼리용으로 설계된 시계열 이벤트들로 구성됩니다. 데이터 소스는 세 종류의 컬럼으로 구성됩니다(여기서는 온라인 광고 데이터를 예시로 사용).
\begin{quote}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics{{druid-features-time-series}.png}
\caption{Source: \sphinxurl{http://druid.io}}\label{\detokenize{discovery/part01/druid_features:id6}}\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{타임스탬프 컬럼(Timestamp column):} Druid는 데이터 소스에서 타임스탬프 컬럼을 별도로 구성함으로써 모든 쿼리가 시간 축을 중심으로 이루어지게 합니다(시계열 속성이 없는 데이터를 일괄적으로 ingestion할 경우에는 현재 시간을 기준으로 타임스탬프가 부여되어 Druid에서 활용할 수 있는 형태가 됩니다).

\item {} 
\sphinxstylestrong{차원 컬럼(Dimension columns):} 차원 컬럼은 각 이벤트의 문자열 속성들을 담고 있으며, 데이터 필터링 시 가장 흔히 사용됩니다. 위 데이터셋 예시에서는 publisher, advertiser, gender, country가 차원 컬럼입니다. 데이터 탐색 시에는 이러한 차원 컬럼들을 축으로 하여 데이터를 slice하게 됩니다.

\item {} 
\sphinxstylestrong{측정값 컬럼(Metric columns):} 측정값 컬럼들은 집계 및 연산에 사용됩니다. 위 예에서는 clicks 및 price가 측정값 컬럼입니다. 측정값 컬럼의 자료형은 대체로 수치 값이며, 이들은 계수, 합산, 평균 등의 방식으로 집계할 수 있습니다(Metatron에서는 지원되는 자료형을 증대하였습니다).

\end{itemize}
\end{quote}


\subsubsection{데이터 ingestion}
\label{\detokenize{discovery/part01/druid_features:ingestion}}
Druid는 실시간 및 일괄(batch) ingestion을 지원합니다.

이 중에서 실시간 ingestion은 Druid의 주요 특징 중 하나인데, 이를 전담하는 real-time 노드군이 있기 때문에 가능한 것입니다(자세한 설명은 {\hyperref[\detokenize{discovery/part01/druid_nodes:realtime-nodes}]{\sphinxcrossref{\DUrole{std,std-ref}{Real-time 노드}}}} 참조). 실시간으로 ingestion되는 데이터 스트림 내 이벤트들은 발생 후 수 초 이내에 Druid 클러스터에서 쿼리가 가능한 포맷으로 인덱싱됩니다.


\subsubsection{데이터 roll-up}
\label{\detokenize{discovery/part01/druid_features:roll-up}}\label{\detokenize{discovery/part01/druid_features:data-rollup}}
무수히 많은 개별 이벤트를 단순히 열거하기만 해서는 중요한 의미를 찾을 수 없습니다. 하지만 이러한 데이터를 적절한 시간대를 기준으로 취합하면 유용한 인사이트를 얻을 수 있습니다. Druid는 roll-up이라는 옵션을 통해 ingestion되는 원천 데이터를 취합할 수 있습니다. 아래는 roll-up의 예시를 나타낸 것입니다.
\begin{quote}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics{{druid-features-rollup}.png}
\caption{Source: Interactive Exploratory Analytics with Druid \textbar{} DataEngConf SF '17}\label{\detokenize{discovery/part01/druid_features:id7}}\end{figure}
\end{quote}

왼쪽의 원본 이벤트 목록은 2011년 1월 1일 00:00:00\textasciitilde{}01:00:00 사이에 발생한 도메인 클릭 이벤트를 열거한 것입니다. 하지만 분석가 입장에서는 분 이하 단위의 개별 이벤트가 별다른 의미를 갖지 못하기 때문에 1시간의 granularity를 기준으로 데이터를 취합했습니다. 그 결과 오른쪽 테이블에 나타난 것처럼 2011년 1월 1일 00\textasciitilde{}01시 시간대에 각 도메인을 남성과 여성이 각각 클릭한 횟수를 보여주는 보다 의미 있는 결과물이 도출되었습니다.

또한 데이터 roll-up은 원천 데이터의 저장 용량을 최소함으로써(많게는 100배까지도 축소 가능), 스토리지 리소스를 절약하고 쿼리 속도를 빠르게 합니다.

그러나 데이터를 roll-up하면 개별 이벤트들에 대해 쿼리할 수 없게 됩니다. roll-up granularity는 데이터를 탐색할 수 있는 최소 단위가 되며 이벤트들은 이러한 granularity 단위로 배열됩니다. granularity 단위는 사용자가 원하는 대로 설정할 수 있으며, 원치 않으면 roll-up을 비활성화하고 모든 개별 이벤트를 전부 ingestion할 수도 있습니다.


\subsubsection{데이터 sharding}
\label{\detokenize{discovery/part01/druid_features:sharding}}
데이터 소스는 시계열 이벤트들의 집합으로서 여러 shard로 분할 저장되는데, Druid에서는 이를 '세그먼트'라고 부르며 각 세그먼트는 대개 500\textasciitilde{}1,000만 행으로 이루어집니다. Druid는 데이터 소스들을 정의된 시간 간격(통상적으로 1시간이나 하루)을 기준으로 분할하며, 그 밖의 컬럼에 있는 값들을 기준으로 추가 분할을 실시함으로써 세그먼트 크기를 적절하게 맞출 수 있습니다.

아래는 1시간 단위로 분할된 데이터 테이블을 예시로 나타낸 것입니다.

세그먼트 \sphinxcode{\sphinxupquote{sampleData\_2011-01-01T01:00:00:00Z\_2011-01-01T02:00:00:00Z\_v1\_0}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2011}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01}\PYG{n}{T01}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{n}{Z}   \PYG{n}{ultratrimfast}\PYG{o}{.}\PYG{n}{com}   \PYG{n}{google}\PYG{o}{.}\PYG{n}{com}   \PYG{n}{Male}   \PYG{n}{USA}   \PYG{l+m+mi}{1800}   \PYG{l+m+mi}{25}   \PYG{l+m+mf}{15.70}
\PYG{l+m+mi}{2011}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01}\PYG{n}{T01}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{n}{Z}   \PYG{n}{bieberfever}\PYG{o}{.}\PYG{n}{com}     \PYG{n}{google}\PYG{o}{.}\PYG{n}{com}   \PYG{n}{Male}   \PYG{n}{USA}   \PYG{l+m+mi}{2912}   \PYG{l+m+mi}{42}   \PYG{l+m+mf}{29.18}
\end{sphinxVerbatim}

세그먼트 \sphinxcode{\sphinxupquote{sampleData\_2011-01-01T02:00:00:00Z\_2011-01-01T03:00:00:00Z\_v1\_0}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2011}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01}\PYG{n}{T02}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{n}{Z}   \PYG{n}{ultratrimfast}\PYG{o}{.}\PYG{n}{com}   \PYG{n}{google}\PYG{o}{.}\PYG{n}{com}   \PYG{n}{Male}   \PYG{n}{UK}    \PYG{l+m+mi}{1953}   \PYG{l+m+mi}{17}   \PYG{l+m+mf}{17.31}
\PYG{l+m+mi}{2011}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01}\PYG{n}{T02}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{n}{Z}   \PYG{n}{bieberfever}\PYG{o}{.}\PYG{n}{com}     \PYG{n}{google}\PYG{o}{.}\PYG{n}{com}   \PYG{n}{Male}   \PYG{n}{UK}    \PYG{l+m+mi}{3194}   \PYG{l+m+mi}{170}  \PYG{l+m+mf}{34.01}
\end{sphinxVerbatim}

이와 같이 시간 단위로 세그먼트를 구분하는 것은 데이터 소스 내의 모든 이벤트에 타임스탬프가 포함되기 때문에 가능합니다.

세그먼트는 Druid 테이블의 기본 저장 단위에 해당하며, 클러스터 내 데이터의 복제(replication) 및 분산은 세그먼트 단위로 이루어집니다. 세그먼트 내 데이터는 변경할 수 없도록 되어 있습니다. 이렇게 함으로써 읽기와 쓰기 동작 사이에 경합이 발생하지 않게 됩니다. Druid의 세그먼트는 매우 신속하게 읽히기 위한 읽기 전용 데이터셋입니다.

뿐만 아니라, 이러한 데이터 세그먼트 분할은 Druid 분산 환경에서의 병렬 처리를 위한 핵심 역할을 합니다. 각 CPU가 한 번에 하나의 세그먼트를 스캔할 수 있기 때문에 데이터를 여러 세그먼트로 분할하면 이를 여러 CPU가 동시에 병렬적으로 스캔할 수 있으므로, 쿼리 결과를 신속하게 반환하고 부하를 안정적으로 분산시킬 수 있게 됩니다.


\subsubsection{데이터 저장 포맷 및 인덱싱}
\label{\detokenize{discovery/part01/druid_features:id2}}
Druid의 데이터 구조를 분석 쿼리에 최적화시키는 주요 요소 중 하나는 Druid가 데이터를 저장하는 방식입니다. 본 절에서는 설명을 위해 아래의 Druid 테이블 예시를 사용합니다.
\begin{quote}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics{{druid-features-wiki}.png}
\caption{Source: Druid: A Real-time Analytical Data Store}\label{\detokenize{discovery/part01/druid_features:id8}}\end{figure}
\end{quote}


\paragraph{컬럼 기반 저장 및 인덱싱}
\label{\detokenize{discovery/part01/druid_features:id3}}
Druid는 컬럼들을 각각 따로 저장합니다. Druid가 주로 이벤트 스트림을 집계하는 데 사용된다는 점을 고려할 때, 이러한 컬럼 기반 저장 방식을 취하면 각 쿼리에 관련된 컬럼만을 로드·스캔하므로 CPU 리소스를 보다 효율적으로 사용할 수 있습니다. 행 기반 데이터 스토어에서는 집계 시 대상 행과 관련된 모든 컬럼을 컬럼별로 상이한 방식으로 압축할 수 있으며 그에 따라 각기 다른 인덱스를 활용함으로써 컬럼을 메모리나 디스크에 저장하는 데 드는 리소스 비용을 줄일 수 있습니다. 위 예에서 page, user, gender, city 컬럼은 문자열만을 포함합니다. 직접 문자열들을 저장하는 것은 불필요한 비용을 발생시키므로 이들을 고유한 정수 식별자로 매핑할 수 있습니다. 예를 들면,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Justin Bieber \PYGZhy{}\PYGZgt{} 0
Ke\PYGZdl{}ha \PYGZhy{}\PYGZgt{} 1
\end{sphinxVerbatim}

이 매핑을 사용하면 page 컬럼을 정수 배열로 나타낼 수 있는데, 여기서 배열 인덱스 각각은 원본 데이터셋의 각 행에 해당합니다. page 컬럼의 경우, 각 행의 page 값을 아래와 같이 표시할 수 있습니다.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

이처럼 문자열들이 고정 길이 정수들로 바뀌어 저장되므로 압축하기가 훨씬 더 수월합니다. Druid는 각 shard(세그먼트) 단위로 데이터를 인덱싱합니다.


\paragraph{데이터 필터링을 위한 인덱싱}
\label{\detokenize{discovery/part01/druid_features:id4}}
Druid는 검색 인덱스를 추가로 만들어서 문자열 컬럼에 대한 필터링을 용이하게 할 수 있습니다. 위 예시 테이블을 다시 보자. 가령 "샌프란시스코에 사는 남성 사용자들이 Wikipedia 편집을 한 횟수는?"과 같은 쿼리가 있을 수 있습니다. 이 쿼리 예시에는 도시(San Francisco)와 성별(Male)이라는 두 가지 차원이 포함됩니다. 각 차원별로 아래와 같은 바이너리 배열이 생성되는데, 여기서 배열 인덱스 각각은 해당 행이 쿼리 필터 조건에 부합하는지 여부를 나타냅니다.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{San} \PYG{n}{Francisco} \PYG{p}{(}\PYG{n}{City}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{rows} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{Male} \PYG{p}{(}\PYG{n}{Gender}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{rows} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\end{sphinxVerbatim}

그런 다음 쿼리 필터는 이러한 두 배열에 대해 AND 연산을 실시합니다.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{n}{AND} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{sphinxVerbatim}

그 결과, 행 1만 스캔 대상이 됩니다. 이런 식으로 필터링된 행만 검색함으로써 불필요한 부하를 방지하는 것입니다. 이러한 바이너리 배열은 압축하기도 매우 쉽습니다.

이러한 검색 인덱싱은 OR 연산에도 사용할 수 있습니다. 어떤 쿼리가 San Francisco 또는 Calgary을 필터링하는 경우, 배열 인덱스들은 차원값별로 다음과 같을 것입니다.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{San} \PYG{n}{Francisco} \PYG{p}{(}\PYG{n}{City}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{rows} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{Calgary} \PYG{p}{(}\PYG{n}{City}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{rows} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{sphinxVerbatim}

그런 다음 두 배열에 대해 OR 연산이 수행됩니다.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{n}{OR} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{sphinxVerbatim}

그 결과, 쿼리는 행 1과 3만 스캔합니다.

대형 비트맵 셋에 boolean 연산을 실시하는 이러한 접근방식은 검색 엔진에서 널리 사용됩니다.


\subsubsection{쿼리 언어}
\label{\detokenize{discovery/part01/druid_features:id5}}
Druid의 네이티브 쿼리 언어는 JSON over HTTP이며, 주요 쿼리는 다음과 같습니다.
\begin{itemize}
\item {} 
Group By

\item {} 
시계열 기반 roll-up

\item {} 
임의적 boolean 필터링

\item {} 
Sum, Min, Max, Avg 등의 집계 연산

\item {} 
차원값 검색

\end{itemize}

하지만 이 외에도 SQL을 비롯한 다양한 언어로 이루어진 쿼리 라이브러리가 생성·공유되고있습니다.


\subsection{Druid 기본 클러스터 아키텍쳐}
\label{\detokenize{discovery/part01/druid_nodes:druid}}\label{\detokenize{discovery/part01/druid_nodes::doc}}
Druid 클러스터는 여러 유형의 노드군으로 구성되며, 각 유형의 노드군별로 고유의 역할을 수행합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{druid_node_architecture}.png}
\end{figure}
\end{quote}


\subsubsection{Real-time 노드}
\label{\detokenize{discovery/part01/druid_nodes:real-time}}\label{\detokenize{discovery/part01/druid_nodes:realtime-nodes}}
real-time 노드군은 이벤트 스트림을 ingestion하고 쿼리하는 기능을 합니다. 이 노드들은 최근 발생한 짧은 시간 범위 내 이벤트들만을 처리하며, 주기적으로 이들을 딥 스토리지로 넘기는데, 그 절차는 다음과 같습니다.
\begin{quote}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics{{druid-archit-data-processing}.png}
\caption{Source: Druid: A Real-time Analytical Data Store}\label{\detokenize{discovery/part01/druid_nodes:id5}}\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
유입되는 이벤트들은 메모리에 인덱싱되면서 즉시 쿼리에 사용될 수 있습니다.

\item {} 
메모리 상의 데이터는 정기적으로 디스크에 저장되면서 수정 불가능한(읽기 전용) 컬럼형 포맷으로 변환됩니다.

\item {} 
저장된 데이터는 off-heap 메모리로 로드되기 때문에 쿼리 가능한 상태가 유지됩니다.

\item {} 
디스크에 저장된 인덱스들을 주기적으로 병합되어 데이터 '세그먼트'를 구성한 후 딥 스토리지로 이관됩니다.

\end{enumerate}
\end{quote}

이런 식으로 real-time 노드로 ingestion된 모든 이벤트는 디스크 저장 전후를 막론하고 on-heap 또는 off-heap 메모리 상에 존재하므로 쿼리가 가능한 상태를 유지합니다(쿼리는 메모리 상의 인덱스와 디스크에 저장된 인덱스 모두에 전달됩니다). 이러한 real-time 노드 기능을 통해 Druid는 실시간 데이터 ingestion을 수행할 수 있습니다. 즉, 이벤트들이 발생하면 곧 이어서 쿼리 대상이 됩니다. 그리고 이러한 과정에서 데이터 손실이 발생하지 않습니다.

real-time 노드는 Druid 클러스터 내 다른 노드들과의 유기적인 동작을 위해 자신의 온라인 상태와 처리 중인 데이터를 Zookeeper({\hyperref[\detokenize{discovery/part01/druid_nodes:external-dependencies}]{\sphinxcrossref{\DUrole{std,std-ref}{외부 종속 모듈}}}} 참조)에 보고합니다.


\subsubsection{Historical 노드}
\label{\detokenize{discovery/part01/druid_nodes:historical}}\label{\detokenize{discovery/part01/druid_nodes:historical-nodes}}
historical 노드군은 real-time 노드가 생성한 읽기 전용 데이터 블록(세그먼트)을 로드하고 처리하는 기능을 합니다. 이 노드들은 딥 스토리지에서 읽기 전용 세그먼트를 다운로드하고 이에 대한 쿼리를 처리합니다(예: 데이터 집계/필터링). 이 노드들은 shared-nothing 아키텍쳐에 기반하며 동작이 단순합니다. 이들 간에는 경합이 발생하지 않으며 단순히 Zookeeper의 지시에 따라 세그먼트를 로드, 드롭, 처리할 뿐입니다.

historical 노드가 쿼리를 처리하는 프로세스는 다음과 같습니다.
\begin{quote}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics{{druid-archit-historical}.png}
\caption{Source: Druid: A Real-time Analytical Data Store}\label{\detokenize{discovery/part01/druid_nodes:id6}}\end{figure}
\end{quote}

쿼리를 받으면 historical 노드는 우선 자신에게 이미 어떤 세그먼트가 존재하는지에 관한 정보를 보관하는 로컬 캐시를 확인합니다. 어떤 세그먼트에 관한 정보가 캐시에 없으면 노드는 딥 스토리지에서 해당 세그먼트를 다운로드합니다. 그런 다음, 해당 세그먼트는 Zookeeper에서 선언되어 쿼리가 가능한 대상이 되며, 노드는 이 세그먼트에 대해 요청된 쿼리를 수행합니다.

historical 노드는 읽기 전용 데이터만을 다루므로 read consistency를 보장할 수 있습니다. 읽기 전용 데이터 블록들은 또한 단순한 병렬 모델을 가능케 합니다. 즉, historical 노드들은 읽기 전용 데이터 블록들을 서로 간섭하지 않고 동시에 스캔·집계할 수 있습니다.

real-time 노드와 마찬가지로 historical 노드들도 자신들의 온라인 상태와 처리 중인 데이터를 Zookeeper에 보고합니다.


\subsubsection{Broker 노드}
\label{\detokenize{discovery/part01/druid_nodes:broker}}\label{\detokenize{discovery/part01/druid_nodes:broker-nodes}}
broker 노드군은 Zookeeper에 보고된 메타데이터를 통해 어떤 세그먼트들이 쿼리 가능한지와 이 세그먼트들이 각각 어디에 저장되어 있는지를 파악합니다. broker 노드들은 입력된 쿼리들의 경로를 지정함으로써 각 쿼리가 올바른 historical 또는 real-time 노드에 도달되게끔 합니다. 그런 다음 historical 및 real-time 노드 각각에서 산출된 결과들을 취합하여 최종 쿼리 결과를 호출자에게 반환합니다.

broker 노드는 리소스 효율성을 높이기 위해 다음과 같이 캐시를 사용합니다.
\begin{quote}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics{{druid-archit-broker}.png}
\caption{Source: Druid: A Real-time Analytical Data Store}\label{\detokenize{discovery/part01/druid_nodes:id7}}\end{figure}
\end{quote}

어떤 쿼리가 여러 세그먼트를 포괄할 경우 broker 노드는 캐시에 이미 존재하는 세그먼트들을 우선 확인합니다. 그리고 캐시에 없는 세그먼트들에 대해서는 그것이 보관된 historical 및 real-time 노드로 쿼리를 전달합니다. historical 노드들이 결과를 반환하면, broker 노드는 이 결과를 나중에 사용할 수 있도록 세그먼트별로 캐시에 저장합니다. real-time 노드의 데이터는 캐시에 저장되지 않으며, 따라서 real-time 데이터에 대한 요청은 항상 real-time 노드로 전달됩니다. real-time 노드의 데이터는 가변적이기 때문에 그 결과를 캐시에 저장하는 것은 안정적이지 않기 때문입니다.


\subsubsection{Coordinator 노드}
\label{\detokenize{discovery/part01/druid_nodes:coordinator}}\label{\detokenize{discovery/part01/druid_nodes:id1}}
coordinator 노드군은 주로 historical 노드 데이터의 관리 및 분산을 담당합니다. coordinator 노드는 어떤 historical 노드가 어떤 세그먼트에 대해 쿼리를 수행할지 결정하고 이들에게 새 데이터를 로드하고, 기한이 지난 데이터를 드롭하고, 데이터를 복제하고, 데이터를 이동하여 부하 밸런스를 맞추도록 지시합니다. 이렇게 함으로써 분산형 historical 노드 그룹에서 빠르고 효율적이며 안정으로 데이터를 처리할 수 있습니다.

다른 모든 Druid 노드와 마찬가지로, coordinator 노드들도 Zookeeper 연결을 유지함으로써 클러스터의 현황을 파악합니다. coordinator 노드들은 MySQL 데이터베이스와의 연결도 유지하는데, 이 데이터베이스에서는 클러스터 내 세그먼트의 생성, 소멸, 복제 규칙과 같은 추가적인 연산 매개변수 및 구성 정보를 관리합니다.

Druid 클러스터의 안정성을 위해 coordinator 노드는 이중화되며 일반적으로 하나의 coordinator 노드만 활성 상태를 유지합니다.


\subsubsection{외부 종속 모듈}
\label{\detokenize{discovery/part01/druid_nodes:external-dependencies}}\label{\detokenize{discovery/part01/druid_nodes:id2}}
Druid는 클러스터 동작을 위해 몇 가지 외부 종속 모듈을 사용합니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{Zookeeper:} Druid는 Zookeeper를 통해 클러스터 내부 통신을 합니다.

\item {} 
\sphinxstylestrong{메타데이터 스토리지:} Druid는 메타데이터 스토리지를 통해 데이터 세그먼트 및 구성에 관한 메타데이터를 저장합니다. 메타데이터 스토리지로는 주로 MySQL과 PostgreSQL이 사용됩니다.

\item {} 
\sphinxstylestrong{딥 스토리지:} Druid 세그먼트들을 영구적으로 백업 저장하는 공간입니다. Druid에 ingestion되는 데이터는 세그먼트 형태로 딥 스토리지에 업로드되고, historical 노드들이 필요한 세그먼트를 여기서 다운로드합니다. 딥 스토리지로는 주로 S3 및 HDFS가 사용됩니다.

\end{itemize}


\subsubsection{High Availability 특성}
\label{\detokenize{discovery/part01/druid_nodes:high-availability}}\label{\detokenize{discovery/part01/druid_nodes:id3}}
Druid는 어느 한 노드가 고장난다고 해서 클러스터의 동작이 중단되지 않도록 설계되었습니다. 또한 서로 다른 유형의 노드군끼리도 상호 간에 상당히 독립적이기 때문에, 클러스터 내부에 통신 장애가 생겨도 데이터 가용성에는 최소한의 영향만을 미칩니다. Druid 클러스터에서 highly availability를 확보하려면, 노드군별로 2개 이상의 노드가 구성되어야 합니다.


\subsubsection{아키텍쳐 확장성}
\label{\detokenize{discovery/part01/druid_nodes:extensionability}}\label{\detokenize{discovery/part01/druid_nodes:id4}}
Druid는 위에서 소개한 기본 아키텍쳐에 다양한 외부 모듈을 추가할 수 있는 모듈 확장형 플랫폼을 지향합니다. 아래는 Druid의 확장성을 활용한 모듈 조합의 예시입니다.
\begin{quote}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics{{intro-to-druid}.png}
\caption{Source: MetaMarkets - Introduction to Druid by Fangjin Yang}\label{\detokenize{discovery/part01/druid_nodes:id8}}\end{figure}
\end{quote}

Metatron Discovery 엔진도 역시 비즈니스 인텔리전스를 위한 end-to-end 솔루션으로서 기능하기 위해 Druid 엔진 전후단에 다양한 모듈을 추가한 것입니다.


\subsection{Druid 성능 평가}
\label{\detokenize{discovery/part01/druid_tests:druid}}\label{\detokenize{discovery/part01/druid_tests::doc}}
Druid는 '실시간' 탐색이 가능한 데이터 스토어를 지향하는 만큼 수치화된 성능을 평가함에 있어서는 다음의 두 가지 측면에 초점이 맞춰집니다.
\begin{itemize}
\item {} 
Query latency

\item {} 
Ingestion latency

\end{itemize}

쿼리 처리와 ingestion에서 소요되는 시간을 최소화하는 것이 '실시간'을 이루는 핵심이 되기 때문입니다. 지금까지 Druid 개발진을 비롯한 여러 기관 및 개인이 이러한 기준으로 Druid 성능을 평가한 benchmark들을 산출하고 그 밖의 지표를 통해 Druid를 다른 데이터베이스 관리 시스템들과 비교한 결과를 공개하였습니다.


\subsubsection{Druid 개발진의 자체 평가}
\label{\detokenize{discovery/part01/druid_tests:id1}}
Druid 개발진이 2014년 발표한 백서 'Druid: A Real-time Analytical Data Store'%
\begin{footnote}[1]\sphinxAtStartFootnote
\begin{enumerate}
\def\theenumi{\Alph{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{5}
\item {} 
Yang, E. Tschetter, X. Léauté, N. Ray, G. Merlino, and D. Ganguli. (2014). \sphinxtitleref{Druid: a real-time analytical data store}. Retrieved from \sphinxurl{http://druid.io/docs/0.12.1/design/index.html}.

\end{enumerate}
%
\end{footnote}의 Chapter 6 Performance에서는 Druid의 query 및 ingestion latency를 다방면에서 평가한 결과를 상세하게 설명하고 있습니다. 본 절에서는 이 중에서 Druid의 성능을 직관적으로 살펴볼 수 있는 지표 위주로 간단히 소개합니다.


\paragraph{Query latency 성능}
\label{\detokenize{discovery/part01/druid_tests:query-latency}}
Druid의 query latency 성능에 대해 백서에서는 현장에서 실제 사용되는 데이터셋 8종과 TPC-H 데이터셋에 대한 쿼리 결과를 기준으로 평가하였는데, 여기서는 TPC-H 데이터셋에 대한 쿼리 결과를 소개합니다. TPC-H 데이터셋에 대한 query latency는 MySQL과의 비교 평가 방식으로 진행하였고, 이때 사용한 클러스터 사양은 다음과 같았습니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{Druid historical 노드:} Amazon EC2 m3.2xlarge instance types (Intel® Xeon® E5-2680 v2 @ 2.80GHz)

\item {} 
\sphinxstylestrong{Druid broker 노드:} c3.2xlarge instances (Intel® Xeon® E5-2670 v2 @ 2.50GHz)

\item {} 
\sphinxstylestrong{MySQL Amazon RDS instance} (Druid와 동일한 m3.2xlarge instance type)

\end{itemize}

아래는 단일 노드에서의 1GB 및 100GB TPC-H 데이터셋에 대한 Druid와 MySQL의 query latency를 비교한 결과를 정리한 그래프입니다.
\begin{quote}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics{{druid-mysql-benchmark}.png}
\caption{Source: Druid: A Real-time Analytical Data Store}\label{\detokenize{discovery/part01/druid_tests:id12}}\end{figure}
\end{quote}

이러한 결과는 Druid의 도입으로 기존 관계형 데이터베이스 시스템에 비해 획기적으로 빠른 쿼리 속도를 낼 수 있음을 시사합니다.

또한 여러 노드를 엮어서 클러스터를 구성할 경우 쿼리 처리 속도가 어느 정도 향상되는지도 측정하였습니다. 쿼리 대상 데이터셋으로서 100GB TPC-H를 사용하였으며 단일 노드(8개 코어)와 6개 노드 클러스터(48개 코어) 간의 성능 차이는 다음과 같았습니다.
\begin{quote}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics{{druid-scaling-benchmark}.png}
\caption{Source: Druid: A Real-time Analytical Data Store}\label{\detokenize{discovery/part01/druid_tests:id13}}\end{figure}
\end{quote}

모든 쿼리가 linear scalability를 달성하지는 않았으나 상대적으로 단순한 쿼리들의 경우에는 거의 코어 수에 정비례하는 처리 속도 증대를 보여주었습니다(SK텔레콤 Metatron에서는 더욱 뚜렷한 linear scalability를 달성할 수 있도록 기능을 보강하였습니다).


\paragraph{Ingestion latency 성능}
\label{\detokenize{discovery/part01/druid_tests:ingestion-latency}}
Druid의 ingestion 성능에 대해서도 평가하였는데, 이때 사용된 클러스터 환경은 다음과 같았습니다.
\begin{itemize}
\item {} 
6개 노드, 총 메모리 360GB 및 96개 코어(12 x Intel® Xeon® E5-2670)

\end{itemize}

ingestion 대상으로는 현장에서 실제 사용되는 데이터 소스 8종이었으며 데이터 소스 각각의 특징과 ingestion 결과는 아래와 같았습니다. 참고로 ingestion 측정을 하는 기간 동안 해당 클러스터에서는 그 외 다른 데이터 소스에 대한 ingestion 동작도 병행해서 실시하였습니다.
\begin{quote}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics{{druid-ingestion-test}.png}
\caption{Source: Druid: A Real-time Analytical Data Store}\label{\detokenize{discovery/part01/druid_tests:id14}}\end{figure}
\end{quote}

데이터 ingestion 속도는 데이터의 복잡성 등 여러 가지 변수의 영향을 받지만, 측정 결과를 놓고 볼 때 대체로 'interactivity'라는 Druid의 개발 목표에 부합한다고 할 수 있습니다.


\subsubsection{SK텔레콤의 Druid 성능 평가}
\label{\detokenize{discovery/part01/druid_tests:sk-druid}}
SK텔레콤에서는 다음과 같이 Druid의 query latency와 ingestion latency를 측정하였습니다.


\paragraph{Query latency 테스트}
\label{\detokenize{discovery/part01/druid_tests:id3}}
Query latency를 측정하는 조건은 다음과 같았습니다.
\begin{itemize}
\item {} 
데이터: TPC-H 100G dataset (9억 rows)

\item {} 
Pre-aggregation 기준: day

\item {} 
서버: r3.4xlarge nodes, (2.5GHz * 16, 122G, 320G SSD) * 6

\item {} 
Historical 노드 개수: 6개

\item {} 
Broker 노드 개수: 1개

\end{itemize}

그 결과 TPC-H 100G dataset의 5개 쿼리의 반환 속도는 다음과 같았습니다(Hive의 쿼리 처리 속도도 참조용으로 함께 측정하였습니다).
\begin{quote}
\begin{quote}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics{{druid-mysql-benchmark2}.png}
\caption{Source: SK Telecom T-DE WIKI Metatron Project}\label{\detokenize{discovery/part01/druid_tests:id15}}\end{figure}
\end{quote}

\begin{sphinxadmonition}{note}{참고:}
Hive의 benchmark가 현저하게 떨어지는 원인 중 일부는 Thrift로 측정한 것과 partition없이 test set이 구성되어 있기 때문입니다.
\end{sphinxadmonition}
\end{quote}


\paragraph{Ingestion latency 테스트}
\label{\detokenize{discovery/part01/druid_tests:id4}}
Ingestion latency를 측정하는 조건은 다음과 같았습니다.
\begin{itemize}
\item {} 
Ingestion data size: 1일 30억 rows, 10 columns

\item {} 
메모리: 512 GB

\item {} 
CPU: Intel (R) Xeon (R) Gold 5120 CPU @ 2.20 GHz (core 56개)

\item {} 
Historical 노드 개수: 100개

\item {} 
Broker 노드 개수: 2개

\item {} 
총 10개의 middle manager 노드 중 3개에서 job 수행

\item {} 
Ingestion 도구: Apache Kafka

\end{itemize}

이와 같은 조건으로 data ingestion을 100회 수행하였고 평균 ingestion latency는 1.623439초였습니다. 여기서 ingestion latency는 아래 도식화한 것과 같이 Kaka ingestion, Druid ingestion, Druid query 처리에 소요되는 시간을 모두 합산한 것입니다.
\begin{quote}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics{{druid-eval-by-sk}.png}
\caption{Source: SK Telecom T-DE WIKI Metatron Project}\label{\detokenize{discovery/part01/druid_tests:id16}}\end{figure}
\end{quote}


\subsubsection{Druid에 대한 제3자의 평가}
\label{\detokenize{discovery/part01/druid_tests:druid-3}}

\paragraph{Outlier의 Druid 평가}
\label{\detokenize{discovery/part01/druid_tests:outlier-druid}}
다음은 Outlier 블로그에 2016년 8월 26일에 게재된 Top 10 Time Series Databases라는 포스트%
\begin{footnote}[2]\sphinxAtStartFootnote
Steven Acreman. (2016, Aug 26). \sphinxtitleref{Top 10 Time Series Databases}. Retrieved from \sphinxurl{https://blog.outlyer.com/top10-open-source-time-series-databases}.
%
\end{footnote}에서는 20개의 주요 오픈소스 시계열 데이터베이스 시스템을 평가하였습니다. 기고자인 Steven Acreman이 개인적으로 매긴 성능 랭킹에서 Druid는 20개 중 9위를 차지하였는데, 여기서 밝힌 Druid의 주요 성능은 다음과 같습니다.
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Outlier의 주요 Druid 평가 내용}\label{\detokenize{discovery/part01/druid_tests:id17}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{35}{100}|\X{65}{100}|}
\hline
\sphinxstyletheadfamily 
평가 기준
&\sphinxstyletheadfamily 
Druid의 성능
\\
\hline
쓰기 성능 - 단일 노드
&
25k metrics/sec

출처: \sphinxurl{https://groups.google.com/forum/\#!searchin/druid-user/benchmark\%7Csort:relevance/druid-user/90BMCxz22Ko/73D8HidLCgAJ}
\\
\hline
쓰기 성능 - 5개 노드 클러스터
&
100k metrics/sec (추산 결과)
\\
\hline
쿼리 성능
&
양호
\\
\hline
개발 수준
&
안정적인 제품을 제공하는 단계에 이름
\\
\hline
장점
&
괜찮은 데이터 모델이면서 좋은 분석 도구 기능들을 갖추고 있음. 주로 batch 로드된 대량 데이터셋에 대해 신속하게 쿼리하는 데 사용되도록 설계되었으며, 이 점에서 탁월한 성능을 보임.
\\
\hline
단점
&
시스템 운용이 힘듦. 쓰기 처리 속도가 아주 빠르지는 않음. 실시간 ingestion 셋업이 까다로움
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\paragraph{DB-Engines의 Druid 평가}
\label{\detokenize{discovery/part01/druid_tests:db-engines-druid}}
온라인 웹사이트 DB Engines%
\begin{footnote}[3]\sphinxAtStartFootnote
DB-Engines website. \sphinxurl{https://db-engines.com}, July 2018.
%
\end{footnote}에서는 다양한 데이터베이스 관리 시스템(DBMS)의 시장 인기도를 매달 평가하며, 이때 다음과 같은 지표를 사용합니다.
\begin{itemize}
\item {} 
인터넷에서 언급되는 횟수: Google, Bing, Yandex에서의 검색 결과로 측정

\item {} 
일반적인 관심: Google Trends에서의 검색 빈도를 기준으로 측정

\item {} 
기술 토론 빈도: 유명 IT 관련 Q\&A 사이트인 Stack Overflow 및 DBA Stack Exchange 포스팅 현황을 기준으로 측정

\item {} 
구인 게시글 수: Indeed 및 Simply Hired의 게시글을 기준으로 측정

\item {} 
해당 커리어를 지닌 인재의 수: LinkedIn 및 Upwork에 게시된 프로필을 기준으로 측정

\item {} 
SNS에서의 언급 수: Twitter의 트윗수를 기준으로 측정

\end{itemize}

그 결과 Druid는 2018년 7월 기준으로 총 343개 시스템 중에서 118위를 차지하였고, 그 중 시계열 데이터베이스 시스템만을 두고 집계했을 때 총 25개 시스템 중 7위를 차지하였습니다.


\subsubsection{Apache Spark와의 비교}
\label{\detokenize{discovery/part01/druid_tests:apache-spark}}
Druid를 Apache Spark와 비교하는 것은 상당히 의미 있는 작업입니다. 둘 다 차세대 대용량 데이터 분석 솔루션으로 각광 받고 있으며, 서로 다른 장점을 가지고 있어 매우 상호보완적으로 조합이 가능하기 때문입니다. Metatron에서도 Druid를 데이터 저장/처리용 엔진으로 사용하고 Spark를 고급 분석용 모듈로 사용함으로써 이들 간의 시너지를 잘 활용하고 있습니다.

여기서는 Sparkline Data Inc.의 창업자 Harish Butani가 공개한 Druid vs Spark 성능 비교 보고서%
\begin{footnote}[4]\sphinxAtStartFootnote
Harish Butani. (2018, Sep 18). Combining Druid and Spark: Interactive and Flexible Analytics at Scale. Retrieved from \sphinxurl{https://www.linkedin.com/pulse/combining-druid-spark-interactiveflexible-analytics-scale-butani}.
%
\end{footnote}%
\begin{footnote}[5]\sphinxAtStartFootnote
Harish Butani. (2015, Aug 28). TPCH Benchmark. Retrieved from \sphinxurl{https://github.com/SparklineData/spark-druid-olap/blob/master/docs/benchmark/BenchMarkDetails.pdf}.
%
\end{footnote}의 내용을 간단히 소개합니다. 보고서에서는 애초에 두 솔루션이 경쟁 관계에 있다기 보다는 상보적인 역할을 한다고 상정을 하고 성능 비교를 시작합니다.


\paragraph{Apache Spark의 특징}
\label{\detokenize{discovery/part01/druid_tests:id9}}
Apache Spark는 오픈소스 클러스터 컴퓨팅 프레임워크로서 Java, Scala, Python, R 언어로 이루어진 다양한 API를 제공합니다. Spark의 프로그래밍 모델은 SQL, 머신러닝, 그래프 프로세싱을 결합한 분석 솔루션을 구축하는 것입니다. Spark는 규모가 크거나 복잡한 데이터를 가공할 수 있도록 강력한 기능들을 지원하지만, Druid와 같은 interactive한 쿼리 처리에 최적화되지는 않았습니다.


\paragraph{데이터셋, 쿼리, 성능 비교 결과}
\label{\detokenize{discovery/part01/druid_tests:id10}}
본 성능 비교를 위한 데이터셋으로 TPCH 10G benchmark data set을 이용했습니다. 본래 이 데이터셋은 관계형 데이터베이스에 적합한 스타 스키마 구조를 갖기 때문에 이를 역정규화시킨 후 Druid와 Spark에서 처리할 수 있도록 재구성하였습니다. 이러한 처리를 거친 데이터셋의 크기는 각각 다음과 같았습니다.
\begin{itemize}
\item {} 
TPCH Flat TSV: 46.80GB

\item {} 
Druid Index in HDFS: 17.04GB

\item {} 
TPCH Flat Parquet: 11.38GB

\item {} 
TPCH Flat Parquet Partition by Month: 11.56GB

\end{itemize}

그런 다음 두 솔루션의 쿼리 처리 속도를 다각도에서 분석할 수 있는 여러 쿼리를 아래와 같이 구성하였습니다.
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Druid와 Apache Spark의 query latency 비교 평가에 사용된 쿼리 내역}\label{\detokenize{discovery/part01/druid_tests:id18}}
\sphinxaftertopcaption
\begin{tabular}[t]{|\X{20}{105}|\X{20}{105}|\X{20}{105}|\X{20}{105}|\X{25}{105}|}
\hline
\sphinxstyletheadfamily 
Query
&\sphinxstyletheadfamily 
Interval
&\sphinxstyletheadfamily 
Filters
&\sphinxstyletheadfamily 
Group By
&\sphinxstyletheadfamily 
Aggregations
\\
\hline
Basic Aggregation.
&
None
&
None
&
ReturnFlag

LineStatus
&
Count(*)

Sum(exdPrice)

Avg(avlQty)
\\
\hline
Ship Date Range
&
1995-12/1997-09
&
None
&
ReturnFlag

LineStatus
&
Count(*)
\\
\hline
SubQry

Nation, pType

ShpDt Range
&
1995-12/1997-09
&
P\_Type

S\_Nation +

C\_Nation
&
S\_Nation
&
Count(*)

Sum(exdPrice)

Max(sCost)

Avg(avlQty)

Count(Distinct oKey)
\\
\hline
TPCH Q1
&
None
&
None
&
ReturnFlag

LineStatus
&
Count(*)

Sum(exdPrice)

Max(sCost)

Avg(avlQty)

Count(Distinct oKey)
\\
\hline
TPCH Q3
&
1995-03-15-
&
O\_Date

MktSegment
&
Okey

Odate

ShipPri
&
Sum(exdPrice)
\\
\hline
TPCH Q5
&
None
&
O\_Date

Region
&
S\_Nation
&
Sum(exdPrice)
\\
\hline
TPCH Q7
&
None
&
S\_Nation +

C\_Nation
&
S\_Nation

C\_Nation

ShipDate.Year
&
Sum(exdPrice)
\\
\hline
TPCH Q8
&
None
&
Region

Type

O\_Date
&
ODate.Year
&
Sum(exdPrice)
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\end{quote}

테스트 결과는 다음과 같았습니다.
\begin{quote}

\begin{figure}[H]
\centering
\capstart

\noindent\sphinxincludegraphics{{druid-vs-spark}.png}
\caption{Source: Combining Druid and Spark: Interactive and Flexible Analytics at Scale}\label{\detokenize{discovery/part01/druid_tests:id19}}\end{figure}
\begin{itemize}
\item {} 
Filters + Ship Date 쿼리는 Druid에 특화된 slice-and-dice 성능을 테스트하는 것이었고, 예상대로 무려 50배 이상 속도 상에 우위를 보였습니다. 마찬가지로 TPCH Q7 쿼리를 처리하는 데도 Druid에서 수 밀리초가 소요된 반면, Spark에서는 수초가 소요되었습니다.

\item {} 
TPCH Q3, Q5, Q8 쿼리의 경우에는 Druid가 위 경우와 같은 극대화된 효율성을 보여주지 못했습니다. OrderDate 술어는 Druid에서 JavaScript 필터로 번역이 되는데, 이는 네이티브 Java 필터에 비해 현저히 느리기 때문입니다.

\item {} 
Basic Aggregation 및 TPCH Q1 쿼리의 경우에도 Druid에서 훨씬 빠른 처리 속도를 보여주었습니다. Druid에서는 Count-Distinct 동작이 cardinality aggregator로 번역이 되는데, 이는 approximate count에 해당합니다. 이러한 장점 덕에 Druid는 cardinality가 큰 차원들을 탐색할 때 유리합니다.

\end{itemize}
\end{quote}

여러 가지 조건에 따라 결과는 달라질 수 있지만, 한 가지 분명한 것은 시간 파티셔닝(time partitioning) 또는 차원 술어(dimensional predicates)를 포함하는 쿼리는 Druid에서 현저히 빠르게 처리한다는 것입니다.


\paragraph{시사점}
\label{\detokenize{discovery/part01/druid_tests:id11}}
이러한 테스트 결과는 Druid의 초고속 쿼리 처리 능력과 Spark의 고급 분석 기능을 결합하면 아주 훌륭한 시너지 효과를 기대할 수 있음을 시사합니다. Druid를 통해 신속하고 효율적으로 분석에 필요한 데이터만 추려낸 후 Spark의 풍부한 프로그래밍 API들을 활용하여 심층적인 분석을 실시하는 것입니다. 이렇게 함으로써 강력하고 유연하며 쿼리 latency가 매우 낮은 분석 솔루션을 구축할 수 있습니다.
\subsubsection*{참고자료}


\subsection{Metatron 엔진으로서 Druid}
\label{\detokenize{discovery/part01/druid_to_metatron:metatron-druid}}\label{\detokenize{discovery/part01/druid_to_metatron::doc}}
앞서 설명한 바와 같이 Metatron은 Druid를 기본 엔진으로서 도입하였고, Metatron만의 용도에 맞게 자체적으로 기능을 개발·보강하였습니다. 본 절에서는 이에 관한 구체적인 배경과 과정, 그리고 결과에 대해 소개합니다.


\subsubsection{Metatron 개발 배경과 Druid 기술의 도입}
\label{\detokenize{discovery/part01/druid_to_metatron:id1}}

\paragraph{빅데이터 분석 솔루션으로서 Metatron의 니즈}
\label{\detokenize{discovery/part01/druid_to_metatron:metatron}}
SK텔레콤은 국내 최대 가입자를 보유하고 있는 이동통신 서비스 제공업체로서, 수많은 이용자들로부터 발생되는 엄청난 양의 네트워크 데이터 로그를 활용하여 안정적인 네트워크 환경을 구축하는데 많은 노력을 기울이고 있습니다.

기존의 IT 인프라로는 이런 대용량 데이터 처리에 한계가 있기 때문에 SK텔레콤은 대규모 빅데이터 시스템(Apache Hadoop)과 이를 활용하기 위한 빅데이터 분석 솔루션이 필요했습니다. SK텔레콤은 저비용으로 대용량 데이터의 저장하기 위해 대규모 Hadoop 인프라를 자체 구축하였지만 다음과 같은 한계가 있었습니다.
\begin{itemize}
\item {} 
수많은 사용자의 네트워크 데이터를 실시간으로 분석할 수 없었습니다. 빅데이터의 저장/처리는 가능했지만 데이터를 시각화하는 데는 한계가 있어 결국 과거와 같이 일부 필요한 데이터만 샘플링해서 확인해야 했습니다.

\item {} 
ETL, DW, BI 등 데이터 분석 단계별로 각기 다른 솔루션, 각기 다른 담당자가 지원하는 기존의 방식은 데이터 분석을 하는 데 시간과 비용이 많이 들며 데이터 접근성을 현저하게 떨어뜨렸습니다. 단순하면서도 신속하게 데이터를 분석할 수 있으려면 분석의 전 단계를 한꺼번에 처리할 수 있는 end-to-end 솔루션이 필요했습니다.

\end{itemize}


\paragraph{Druid를 엔진으로 채택한 이유}
\label{\detokenize{discovery/part01/druid_to_metatron:druid}}
Druid는 다음과 같은 특징들 때문에 위와 같은 니즈를 충족해야 하는 Metatron 솔루션의 엔진으로서 적합했습니다.
\begin{itemize}
\item {} 
Druid는 대용량의 데이터를 실시간으로 수집하여 즉시 쿼리 가능한 형태로 인덱싱하며, 분산 처리 기반을 통해 대용량의 데이터 집계를 아주 빠른 시간(최대 수초) 이내에 처리해줍니다.

\item {} 
Druid의 시계열 기반 OLAP Cube 데이터 포맷은 분석가가 원하는 대로 탐색, 필터링, 시각화하기 용이합니다. 실무자들이 쿼리 구성을 고민하지 않고 직관적으로 필요한 데이터를 선별하여 알고자 하는 상관 관계를 바로 출력할 수 있게 하려면 이러한 탐색 자유도와 유연성이 필수적입니다.

\item {} 
Druid는 확장성이 탁월하여 각종 모듈을 추가하기 용이합니다.

\end{itemize}

Metatron은 Druid의 이러한 특성을 활용하여 데이터 수집, 저장, 처리, 분석, 시각화 등의 모든 layer를 포괄하는 end-to-end 솔루션을 구축하였습니다.


\paragraph{Druid 응용 방식}
\label{\detokenize{discovery/part01/druid_to_metatron:id2}}
Metatron에서 Druid 엔진을 응용하는 방식은 다음과 같습니다.
\begin{itemize}
\item {} 
사용자(현업/빅데이터 분석가) 측면에서 Druid를 기본 처리/분석 엔진으로 사용하기 쉽도록 GUI 화면을 구성하여 데이터 전처리, 분석, 시각화 등 데이터 관련 업무를 수행하고 이를 공유할 수 있게 하였습니다.

\item {} 
IT 운영자는 Druid 내 데이터 소스를 관리/모니터링 할 수 있고, 필요시 데이터 전처리 작업을 통해 고품질의 데이터 소스를 제공할 수 있도록 지원합니다.

\end{itemize}


\subsubsection{Metatron에서 보강한 Druid 기능들}
\label{\detokenize{discovery/part01/druid_to_metatron:id3}}
Druid는 강력한 데이터 수집·처리 기능을 지원하지만, Metatron이 end-to-end 솔루션으로 온전히 기능하기 위해서는 기존의 오픈소스 Druid를 개선할 필요가 있었습니다. 본 절에서는 기존 오픈소스 Druid의 한계와 Metatron에서 보강한 기능들을 살펴보겠습니다.


\paragraph{오픈소스 Druid의 한계}
\label{\detokenize{discovery/part01/druid_to_metatron:id4}}
기존의 오픈소스 Druid의 한계는 다음과 같습니다.
\begin{itemize}
\item {} 
Druid는 데이터 테이블 join에 제약이 많습니다. 이런 이유로 Metatron은 데이터 전처리를 위해 다른 SQL 엔진으로 사용합니다.

\item {} 
Druid는 SQL 쿼리를 부분적으로만 지원합니다.

\item {} 
데이터 레이크용으로는 기존의 SQL 엔진을 사용하는 편이 더 낫습니다.

\item {} 
이미 인덱싱된 세그먼트를 수정하거나 행을 추가할 수 없습니다. 물론 incremental ingestion과 같은 특수한 상황에는 가능하지만 일반적이지 않습니다.

\item {} 
null 값이 지원되지 않습니다.

\item {} 
측정값에 대한 필터링이 지원되지 않습니다.

\item {} 
Linear scalability가 보장되지 않습니다. 서버의 수를 늘려도 성능이 크게 개선되지 않습니다.

\item {} 
Druid에서 지원하는 자료형은 제한적이며 추가하기가 어렵습니다.

\item {} 
관리 및 모니터링 도구가 성능이 우수하지 않습니다.

\end{itemize}


\paragraph{Metatron에서 보강한 Druid 기능들}
\label{\detokenize{discovery/part01/druid_to_metatron:id5}}
Metatron은 Druid에서 미비한 기능들을 다음과 같이 보강하였습니다.

\sphinxstylestrong{쿼리 성능 개선}
\begin{itemize}
\item {} 
groupBy 쿼리 성능 개선

\item {} 
기타 쿼리 성능 소폭 개선

\end{itemize}

\sphinxstylestrong{기능 추가}
\begin{itemize}
\item {} 
가상 컬럼(map, expression 등)

\item {} 
측정값 자료형 확장(double, string, array 등)

\item {} 
계산식 기능 확장

\item {} 
Druid 쿼리 결과를 HDFS 또는 파일로 내보낼 수 있음

\item {} 
데이터 테이블에 대한 메타 정보 및 통계용 쿼리 추가

\item {} 
집계 기능 추가(분산, 상관관계 등)

\item {} 
(제한적) 관계형 DB의 window 기능들 구현(lead, lar, running aggregations 등)

\item {} 
(제한적) join 기능 강화

\item {} 
(제한적) 서브 쿼리 추가

\item {} 
임시 데이터 소스

\item {} 
복합 쿼리 추가(데이터 소스 summarization, 데이터 소스 간 상관관계, k-평균 등)

\item {} 
사용자 정의 컬럼 grouping 지원

\item {} 
GIS(지도-GEO서버 연계 adaptor 제공) 기능 지원

\item {} 
컬럼별 histogram 제공

\item {} 
Bit-slice indexing 지원

\end{itemize}

\sphinxstylestrong{인덱스 구조 개선}
\begin{itemize}
\item {} 
측정값 필터링용 히스토그램

\item {} 
텍스트 필터링용 lucene 포맷 지원

\end{itemize}

\sphinxstylestrong{다른 시스템들과의 연동 지원}
\begin{itemize}
\item {} 
Hive 저장소 핸들러

\item {} 
Hive 테이블 ingestion(Hive 메타 스토어와 연결)

\item {} 
ORC 포맷 ingestion

\item {} 
JDBC를 통한 RDBMS 데이터 ingestion

\item {} 
(제한적) Backport된 SQL 지원

\end{itemize}

\sphinxstylestrong{기타 개선사항}
\begin{itemize}
\item {} 
버그 수정(50건 이상), 기능 추가 및 기타 경미한 사항들 개선

\end{itemize}


\chapter{데이터 관리}
\label{\detokenize{discovery/part02/index:id1}}\label{\detokenize{discovery/part02/index::doc}}
\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{datasource_management}.png}
\end{figure}

위 그림과 같이 Metatron Discovery의 3가지 분석 모듈(워크북, 노트북, 워크벤치)에서 사용하는 데이터는 다양한 원천 데이터 유형과 여러 엔진 및 저장소를 통해 마련됩니다. 따라서 이러한 데이터 흐름을 정형화 및 관리하고 여러 원천 데이터를 연결시켜주는 작업이 반드시 필요합니다.

데이터 분석 및 시각화에 필요한 원천 데이터는 Metatron 내부 엔진로 가져와 \sphinxstylestrong{데이터 소스} 단위로 저장하거나, 아니면 \sphinxstylestrong{데이터 커넥션}을 통해 외부 데이터베이스와 직접 연결하여 사용할 수 있습니다. 그리고 이러한 데이터의 사용 현황은 \sphinxstylestrong{데이터 모니터링}을 이용하여 감독하고 추적할 수 있습니다.


\section{데이터 소스}
\label{\detokenize{discovery/part02/data_source:id1}}\label{\detokenize{discovery/part02/data_source::doc}}
Metatron Discovery에서 '데이터 소스'는 Druid 엔진에 수집되는 데이터 단위를 의미합니다. 각 데이터 소스는 Druid 데이터베이스에서 하나의 테이블로서 저장됩니다. 이러한 데이터 소스들은 '워크북'이나 '노트북'에서 분석·시각화하는 데 사용됩니다.

데이터 소스 메뉴는 메인 화면 좌측 패널에서 \sphinxstylestrong{MANAGEMENT} \textgreater{} \sphinxstylestrong{데이터 스토리지} \textgreater{} \sphinxstylestrong{데이터 소스}를 통해 진입할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_1}.png}
\end{figure}
\end{quote}


\subsection{'차원값'과 '측정값'의 개념}
\label{\detokenize{discovery/part02/dimension_and_measures:id1}}\label{\detokenize{discovery/part02/dimension_and_measures::doc}}
대시보드에 연동된 데이터 소스의 컬럼들은 아래와 같이 \sphinxstylestrong{차원값} 컬럼과 \sphinxstylestrong{측정값} 컬럼으로 구분됩니다. Discovery의 데이터 분석·시각화 기능을 온전히 활용하기 위해서는 차원값과 측정값의 개념을 명확하게 이해해야 합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dimension_measure_01}.png}
\end{figure}
\end{quote}

\sphinxstylestrong{차원값(Dimension) 컬럼}

범주형 데이터 컬럼을 가리키며, 특징은 아래와 같습니다.
\begin{itemize}
\item {} 
집계(aggregated)보다는 분류(categorical)에 의미가 있는 데이터 필드(예: Category, Region, Organization 등)

\item {} 
측정값을 표시하는 데 기준이 됨.

\end{itemize}

\sphinxstylestrong{측정값(Measure) 컬럼}

수량적 데이터 필드를 가리키며, 특징은 아래와 같습니다.
\begin{itemize}
\item {} 
집계(aggregated)할 수 있거나 양적인(quantitative) 정보를 포함하는 필드(예: Sales 등)

\item {} 
차원값에 의해 제시된 기준을 토대로 차트에 표현되는 데이터

\end{itemize}


\subsection{데이터 소스 관리 홈 화면}
\label{\detokenize{discovery/part02/manage_data_sources:id1}}\label{\detokenize{discovery/part02/manage_data_sources::doc}}
본 화면에서는 데이터 소스의 신규 등록·편집·조회가 가능합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{manage_datasource_01}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{상태:} 현재 데이터 스토리지에 저장되어 있는 데이터 소스의 가용 여부로 선별하여 조회합니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{Enable:} 데이터 ingestion을 마쳐 워크북이나 워크벤치에서 사용 가능한 데이터 소스들이 출력됩니다.

\item {} 
\sphinxstylestrong{Preparing:} 아직 생성된 지 얼마 되지 않아서 데이터 ingestion이 진행 중인 데이터 소스들이 출력됩니다.

\item {} 
\sphinxstylestrong{Failed:} 생성이 제대로 되지 않은 데이터 소스들이 출력됩니다.

\item {} 
\sphinxstylestrong{Disabled:} 데이터 ingestion을 마쳤으나 Druid 엔진의 일부 프로세스에서 제대로 진행이 되지 않아 사용이 불가능한 데이터 소스들이 출력됩니다.

\end{itemize}

\item {} 
\sphinxstylestrong{공개:} 데이터 소스의 공개 대상여부로 선별하여 조회합니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{공개 데이터:} 모든 워크스페이스에서 사용이 허용된 데이터 소스들만 선별하여 조회합니다.

\item {} 
\sphinxstylestrong{Admin workspace:} 어드민 워크스페이스에서 사용이 허용된 데이터 소스들만 선별하여 조회합니다.

\item {} 
\sphinxstylestrong{Shared Workspace:} shared workspace에서 사용이 허용된 데이터 소스들만 선별하여 조회합니다.

\end{itemize}

\item {} 
\sphinxstylestrong{생성한 사람:} 해당 데이터 소스를 생성한 사용자 또는 그룹을 조회합니다.

\item {} 
\sphinxstylestrong{생성한 시간:} 데이터 소스 조회 시 적용되는 시간 기준입니다. 생성일과 수정일 중 원하는 기준으로 선택할 수 있으며 시간 범위는 전체/오늘/지난 7일/특정 날짜 기간 중 선택이 가능합니다.

\item {} 
\sphinxstylestrong{데이터 소스 이름으로 검색:} 현재 등록된 데이터 소스를 이름으로 검색합니다

\item {} 
\sphinxstylestrong{데이터 소스 목록:} 설정한 선별 조건에 맞는 데이터 소스들을 보여줍니다. 이 중 하나를 클릭하면 상세 내역을 볼 수 있습니다. ({\hyperref[\detokenize{discovery/part02/data_source_detail_view::doc}]{\sphinxcrossref{\DUrole{doc}{데이터 소스 상세 정보}}}} 참조)

\item {} 
\sphinxstylestrong{삭제:} 해당 데이터 소스에 마우스 오버 시 휴지통 아이콘이 나타납니다. 클릭하면 해당 데이터 소스를 삭제할 수 있습니다.

\end{enumerate}
\end{quote}


\subsection{데이터 소스 상세 정보}
\label{\detokenize{discovery/part02/data_source_detail_view:id1}}\label{\detokenize{discovery/part02/data_source_detail_view::doc}}
데이터 소스 관리 홈에 열거된 데이터 소스 중 하나를 클릭하면 해당 데이터 소스에 관한 다양한 속성을 확인할 수 있습니다. 아래 각 영역을 확인할 때에는 각 데이터 소스가 Metatron의 내부 Druid 데이터베이스에 하나의 테이블로 저장되며, Druid의 시계열 특성 때문에 반드시 타임스탬프 컬럼을 포함하게 됨을 유의하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{manage_datasource_02}.png}
\end{figure}
\end{quote}


\subsubsection{상단 공통 영역}
\label{\detokenize{discovery/part02/data_source_detail_view:id2}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{이름:} 해당 데이터 소스의 이름입니다. 클릭 시 수정 가능합니다.

\item {} 
\sphinxstylestrong{설명:} 해당 데이터 소스에 대한 설명입니다. 클릭 시 수정 가능합니다.

\item {} 
\sphinxstylestrong{마지막 수정정보:} 해당 데이터 소스를 누가 언제 마지막으로 수정했는지 보여줍니다.

\item {} 
\sphinxstylestrong{삭제:} 이 아이콘을 누르면 해당 데이터 소스를 삭제할 수 있는 메뉴가 나타납니다.

\item {} 
\sphinxstylestrong{탭 선택 영역:} 각 탭은 해당 데이터 소스에 관한 특정한 속성군을 보여줍니다. 데이터 소스의 종류에 따라 3개 탭이 모두 나오지 않을 수도 있습니다. 각각에 대한 자세한 설명은 아래의 각 절에서 확인하십시오.

\end{enumerate}


\subsubsection{데이터 정보 영역}
\label{\detokenize{discovery/part02/data_source_detail_view:id3}}
이 영역에서는 해당 데이터 소스의 기본 정보를 보여줍니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{manage_datasource_03}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{데이터 타입:} 해당 데이터 소스 생성 시 가져온 원천 데이터의 타입입니다.

\item {} 
\sphinxstylestrong{상태:} 해당 데이터 소스의 현재 사용 가능 여부를 나타냅니다.

\item {} 
\sphinxstylestrong{사이즈:} 해당 데이터 소스의 크기를 나타냅니다.

\item {} 
\sphinxstylestrong{인터벌:} 해당 데이터 소스에 포함된 타임스탬프의 시간 범위를 나타냅니다.

\item {} 
\sphinxstylestrong{타임스탬프 설정:} 해당 데이터 소스 생성 시 설정한 Granularity 주기를 나타냅니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{쿼리단위:} 분석에서 수행하고자 하는 최소 시간 단위를 결정합니다. 이는 최소 단위까지의 결과를 미리 생성하여 이후에 보다 빠른 응답을 얻을 수 있도록 하기 위함입니다.

\item {} 
\sphinxstylestrong{세그먼트단위:} 분산 환경에서 동작하는 Druid의 특성을 활용하기 위해 데이터를 분할하여 저장하게 되는데 이때 저장하는 단위를 결정합니다.

\item {} 
\sphinxstylestrong{히스토그램:} 각 시간대별로 저장된 데이터의 용량을 KByte 단위로 보여주는 그래프입니다. 이러한 히스토그램은 레코드별로 반드시 타임스탬프 기록을 남겨야하는 Druid 엔진의 특성에 따른 것입니다.

\end{itemize}

\end{enumerate}
\end{quote}

\sphinxstylestrong{데이터 소스에 Publish 권한주기}

이 영역에서는 해당 데이터 소스를 어느 워크스페이스에서 사용할 수 있는지를 확인·설정합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{manage_datasource_04}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{모든 워크스페이스에 데이터 소스를 사용하도록 허용:} 이 확인란에 체크하면 모든 워크스페이스에서 해당 데이터 소스를 사용할 수 있습니다.

\item {} 
\sphinxstylestrong{수정:} 해당 데이터 소스의 사용을 허용할 특정 워크스페이스를 지정할 때 사용합니다. 해당 데이터 소스를 오픈 데이터로 지정하면 이 버튼이 사라집니다.

\item {} 
\sphinxstylestrong{공유 워크스페이스 수:} 해당 데이터 소스를 사용할 수 있도록 허용된 워크스페이스의 수를 나타냅니다.

\end{enumerate}
\end{quote}


\subsubsection{데이터 스키마 변경하기}
\label{\detokenize{discovery/part02/data_source_detail_view:id4}}
컬럼 상세 탭의 상단부는 원하는 조건으로 컬럼을 선별하는 사용자 인터페이스를 제공합니다. 조건에 맞게 선별된 컬럼들은 좌측 영역에 조회됩니다. 또한 여기서는 컬럼 설정값을 수정할 수도 있습니다.

\sphinxstylestrong{컬럼 조회/설정 기능}
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{manage_datasource_05}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{데이터 검색:} 컬럼 이름으로 검색이 가능합니다.

\item {} 
\sphinxstylestrong{역할:} 데이터 테이블의 컬럼을 전체/차원값/측정값으로 선별하여 조회합니다.

\item {} 
\sphinxstylestrong{타입:} 데이터 테이블의 컬럼을 필드 타입별로 선별하여 조회합니다.

\item {} 
\sphinxstylestrong{전체 보기:} 데이터 검색, 역할, 타입 옵션에서 설정한 모든 선별 조건을 취소하고 전체 컬럼 보기로 회귀합니다.

\item {} 
\sphinxstylestrong{스키마구성:} 클릭하면 현재의 컬럼 설정값을 바꿀 수 있는 창이 출력됩니다.

\item {} 
\sphinxstylestrong{컬럼목록:} 해당 테이블을 구성하는 컬럼들을 열거합니다.

\item {} 
\sphinxstylestrong{컬럼정보:} 선택된 컬럼의 속성을 보여줍니다.

\item {} 
\sphinxstylestrong{컬럼설정:} 선택된 컬럼의 메타 데이터 정보를 보여줍니다.

\item {} 
\sphinxstylestrong{통계:} 선택된 컬럼에 입력된 값에 대해서 건수 및 통계값을 보여줍니다.

\end{enumerate}
\end{quote}

\sphinxstylestrong{스키마구성}

컬럼들의 명칭 및 타입 수정을 하는 사용자 인터페이스를 제공합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{manage_datasource_06}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{역할:} 해당 컬럼 차원값/측정값의 여부를 표시합니다.

\item {} 
\sphinxstylestrong{물리이름:} 해당 컬럼의 실제 명칭을 표시합니다.

\item {} 
\sphinxstylestrong{용어이름:} 해당 컬럼이 해당 시스템에서 표시될 용어 이름을 표시하고 수정할수 있습니다.

\item {} 
\sphinxstylestrong{논리타입:} 해당 컬럼의 논리타입( 문자/숫자/날짜등)을 표시하고 수정할수 있습니다.

\item {} 
\sphinxstylestrong{표시형식:} 해당 컬럼이 타임스탭프 등인 경우 표시 포맷을 표시합니다.

\item {} 
\sphinxstylestrong{설명:} 해당 컬럼의 상세 설명을 표시하고 수정할수 있습니다.

\end{enumerate}
\end{quote}


\subsubsection{데이터 통계 분석하기}
\label{\detokenize{discovery/part02/data_source_detail_view:id5}}
모니터링 탭에서는 데이터 소스가 사용된 로그를 볼 수 있습니다.

\sphinxstylestrong{트랙잭션 변경}

해당 데이터 소스의 시간에 따른 트랜잭션량 추이를 보여줍니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{manage_datasource_07}.png}
\end{figure}
\end{quote}

\sphinxstylestrong{데이터 사이즈 변경}

해당 데이터 소스의 시간에 따른 용량 추이를 보여줍니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{manage_datasource_08}.png}
\end{figure}
\end{quote}

\sphinxstylestrong{쿼리사용분포(지난 1주일 동안)}
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{manage_datasource_09}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{사용자별 쿼리사용 분포 (지난 1주일 동안):} 지난 한 주간 쿼리를 수행한 사용자별로 분류하여 그래프로 보여줍니다.

\item {} 
\sphinxstylestrong{응답 시간별 쿼리사용 분포 (지난 1주일 동안):} 지난 한 주간 쿼리를 수행한 소요시간별로 분류하여 그래프로 보여줍니다.

\end{itemize}
\end{quote}

\sphinxstylestrong{쿼리 로그}

수행된 각 쿼리에 대한 상세 이력을 확인할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{manage_datasource_10}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{날짜:} 확인하고자 하는 쿼리들의 실행 시간대를 설정합니다.

\item {} 
\sphinxstylestrong{쿼리 타입:} 실행한 쿼리를 타입별로 선별하여 출력합니다.

\item {} 
\sphinxstylestrong{상태:} 쿼리 결과를 성공/실패로 선별하여 출력합니다.

\item {} 
\sphinxstylestrong{쿼리 목록:} 설정한 조건에 부합하는 쿼리들이 나열됩니다.

\item {} 
\sphinxstylestrong{자세히:} 클릭하면 해당 쿼리문을 확인할 수 있습니다.

\end{enumerate}
\end{quote}


\subsection{데이터 소스 만들기}
\label{\detokenize{discovery/part02/create_a_data_source:id1}}\label{\detokenize{discovery/part02/create_a_data_source::doc}}
본 절에서는 다양한 형태의 원천 데이터를 Metatron 엔진으로 가져와 데이터 소스로 만드는 과정을 설명합니다.

데이터 소스를 생성하려면 \sphinxstylestrong{데이터 소스} 홈 화면 우측 상단에서 \sphinxstylestrong{+ 새로만들기} 버튼을 클릭합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_2}.png}
\end{figure}
\end{quote}

그런 다음 원천 데이터의 타입을 선택합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_3}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{파일:} 사용자의 로컬 PC에 저장되어 있는 파일을 가져와서 데이터 소스를 생성합니다(자세한 절차는 {\hyperref[\detokenize{discovery/part02/create_a_data_source:create-datasource-from-file}]{\sphinxcrossref{\DUrole{std,std-ref}{파일로 데이터 소스 만들기}}}} 참조).

\item {} 
\sphinxstylestrong{데이터베이스:} 외부 데이터베이스에서 데이터를 가져와서 데이터 소스를 생성합니다(자세한 절차는 {\hyperref[\detokenize{discovery/part02/create_a_data_source:create-datasource-from-db}]{\sphinxcrossref{\DUrole{std,std-ref}{DB로 데이터 소스 만들기}}}} 참조).

\item {} 
\sphinxstylestrong{Staging DB:} Metatron의 내부 Hive 데이터베이스에서 가져온 데이터를 기반으로 데이터 소스를 생성합니다(자세한 절차는 {\hyperref[\detokenize{discovery/part02/create_a_data_source:create-datasource-from-stagingdb}]{\sphinxcrossref{\DUrole{std,std-ref}{StagingDB로 데이터 소스 만들기}}}} 참조).

\item {} 
\sphinxstylestrong{실시간:} 현재 해당 기능은 지원하지 않습니다.

\item {} 
\sphinxstylestrong{데이터스냅샷:} 현재 해당 기능은 지원하지 않습니다.

\item {} 
\sphinxstylestrong{Metatron 엔진:} Metatron 이전 버전에 저장된 데이터 소스를 마이그레이션 합니다(자세한 절차는 {\hyperref[\detokenize{discovery/part02/create_a_data_source:create-datasource-from-metatron}]{\sphinxcrossref{\DUrole{std,std-ref}{Metatron 엔진을 통해 데이터 소스 추가하기}}}} 참조).

\end{itemize}
\end{quote}


\subsubsection{파일로 데이터 소스 만들기}
\label{\detokenize{discovery/part02/create_a_data_source:create-datasource-from-file}}\label{\detokenize{discovery/part02/create_a_data_source:id2}}
사용자의 로컬 PC에 저장되어 있는 파일을 가져와서 데이터 소스를 생성합니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
원천 데이터 타입 선택 화면에서 \sphinxstylestrong{파일}을 선택합니다.

\item {} 
사용자 로컬 PC에서 데이터 소스로 사용할 파일을 가져옵니다. \sphinxstylestrong{Import} 버튼을 클릭하여 파일을 선택할 수도 있고 화면 상으로 파일을 끌어다 놓을 수도 있습니다. 파일을 가져왔으면 다음 버튼을 누릅니다.

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_file_1}.png}
\end{figure}

\item {} 
가져온 파일에서 데이터 소스에 포함시킬 시트를 선택합니다.

\begin{sphinxadmonition}{note}{참고:}
데이터가 있음에도 불구하고 '미리보기 데이터가 없습니다'로 나오는 경우에는, \sphinxstylestrong{컬럼 구분자} 및 \sphinxstylestrong{라인 구분자}를 맞게 설정했는지 확인해야 합니다. 이 예제에서는 \sphinxstylestrong{라인 구분자}가 MS Windows의 carriage return인 'r'로 입력이 되어야 합니다.
\end{sphinxadmonition}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_file_3}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{파일 이름:} 가져온 파일의 이름입니다. 다른 파일을 다시 가져올 수도 있습니다.

\item {} 
\sphinxstylestrong{파일 시트 목록:} 가져온 파일에 포함된 시트들을 보여줍니다. 여기서 데이터 소스로 만들 시트를 선택합니다.

\item {} 
\sphinxstylestrong{파일 시트 이름:} 현재 선택된 시트 이름입니다.

\item {} 
\sphinxstylestrong{용량:} 가져온 파일의 용량입니다.

\item {} 
\sphinxstylestrong{컬럼:} 가져온 파일의 컬럼 개수입니다.

\item {} 
\sphinxstylestrong{행:} 가져온 파일의 행 개수입니다. 숫자를 입력하면 해당 숫자만큼의 행이 화면에 나타납니다.

\item {} 
\sphinxstylestrong{타입:} 각 컬럼으로부터 인식한 데이터 타입이 몇 종류인지 보여줍니다. 컬럼별 데이터 타입은 이후 화면에서 수정할 수 있습니다.

\item {} 
\sphinxstylestrong{첫째 행을 컬럼명으로 사용 여부 확인란:} 선택하면 파일 내의 첫번째 행의 내용이 컬럼명으로 사용됩니다. 선택하지 않을 경우 컬럼명을 기재할 행이 새로 생성됩니다.

\end{itemize}

\item {} 
데이터 소스에서 구현하고자 하는 스키마를 설정합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_file_4}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{컬럼명으로 검색:} 가져온 파일에 들어있는 컬럼을 이름으로 검색합니다.

\item {} 
\sphinxincludegraphics{{icon_bin}.png} \sphinxstylestrong{버튼(우측 상단):} 선택한 컬럼을 삭제합니다.

\item {} 
\sphinxstylestrong{역할:} 가져온 파일에 들어있는 컬럼을 전체/차원값/측정값으로 선별하여 조회합니다.

\item {} 
\sphinxstylestrong{추천 필터:} 최우선 추천 필터가 적용된 컬럼들만 선별하여 조회합니다.

\item {} 
\sphinxstylestrong{타입:} 가져온 파일에 들어있는 컬럼을 필드 타입별로 선별하여 조회합니다.

\item {} 
\sphinxstylestrong{컬럼 목록 영역:} 설정한 선별 조건에 맞는 컬럼들을 보여줍니다. 컬럼들을 선택하면 하단에 패널이 나타나는데, 여기서 원하는 일괄 동작을 선택한 후 \sphinxstylestrong{적용}을 클릭하면 선택한 컬럼들에 대한 일괄 동작이 수행됩니다.

\item {} 
\sphinxstylestrong{개별 컬럼 설정 영역:} 컬럼 목록에서 선택한 컬럼의 속성들을 설정할 수 있는 영역입니다. 여기서 \sphinxstylestrong{빈 값 설정}은 컬럼 내 Null 값을 처리하는 방식을 설정하는 항목입니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{대체:} 여기에 입력된 값으로 Null 값이 대체됩니다.

\item {} 
\sphinxstylestrong{버림:} Null 값을 버립니다.

\item {} 
\sphinxstylestrong{설정안함:} Null 값이 그대로 보여집니다. 단 데이터 소스의 타임스탬프의 Null 값은 무조건 버려지게 됩니다.

\end{itemize}

\item {} 
\sphinxstylestrong{타임스탬프 설정:} 각 행에 타임스탬프를 지정하는 방식을 결정합니다. 기존 데이터가 보유하고 있는 시간 타입 컬럼을 타임스탬프로 지정하거나, 아니면 현재 시간 값으로 이루어진 시간 타입 컬럼을 생성하여 타임스탬프로 지정할 수 있습니다.
\begin{quote}

\begin{sphinxadmonition}{note}{참고:}
Metatron 엔진은 데이터 소스 저장 시 무조건 시간 값을 보유해야 하는 시계열 엔진입니다.
\end{sphinxadmonition}
\end{quote}

\item {} 
\sphinxstylestrong{컬럼 추가:} 데이터에 위도, 경도 컬럼이 있는 경우 이를 결합하여 \sphinxcode{\sphinxupquote{Point}} 타입의 신규 컬럼을 추가할 수 있습니다. 이 컬럼을 지우면 다른 컬럼들과 동일하게 동작합니다.

\end{itemize}
\end{quote}

\item {} 
데이터 소스 수집 설정을 하고 다음 버튼을 누릅니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_file_10}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{세그먼트 단위:} 분산 노드 환경에서 동작하는 Druid의 특성을 활용하기 위해 데이터를 분할하여 저장하게 되는데 이때 저장하는 시간 단위를 결정합니다.

\item {} 
\sphinxstylestrong{쿼리 단위:} 분석에서 수행하고자 하는 최소 시간 단위를 결정합니다. 이는 최소 단위까지의 결과를 미리 생성하여 이후에 보다 빠른 응답을 얻을 수 있도록 하기 위함입니다.

\item {} 
\sphinxstylestrong{롤업:} '데이터 롤업'은 차원값을 기준으로 데이터를 요약하는 작업입니다('데이터 롤업'의 개념에 대한 보다 상세한 설명은 {\hyperref[\detokenize{discovery/part01/druid_features:data-rollup}]{\sphinxcrossref{\DUrole{std,std-ref}{데이터 roll-up}}}} 참조). 요약 규칙은 계층 구조를 따라 합계를 계산하거나 \sphinxcode{\sphinxupquote{profit=sales=expenses}}와 같은 수식 집합을 적용하는 것일 수 있습니다.

\item {} 
\sphinxstylestrong{고급설정:} 데이터 적재 성능을 설정합니다. 텍스트상자에 JSON 형식의 구문을 입력하십시오. 예,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{n}{maxRowsInMemory} \PYG{p}{:} \PYG{l+m+mi}{75000}\PYG{p}{,}
\PYG{n}{maxOccupationInMemory} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}
\PYG{n}{maxShardLength} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2147483648}\PYG{p}{,}
\PYG{n}{leaveIntermediate} \PYG{p}{:} \PYG{n}{false}\PYG{p}{,}
\PYG{n}{cleanupOnFailure} \PYG{p}{:} \PYG{n}{true}\PYG{p}{,}
\PYG{n}{overwriteFiles} \PYG{p}{:} \PYG{n}{false}\PYG{p}{,}
\PYG{n}{ignoreInvalidRows} \PYG{p}{:} \PYG{n}{false}\PYG{p}{,}
\PYG{n}{assumeTimeSorted} \PYG{p}{:} \PYG{n}{false}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}
\end{quote}

\item {} 
가져온 파일에서 설정한 데이터에 관한 정보를 확인한 뒤, \sphinxstylestrong{이름}과 \sphinxstylestrong{설명}을 입력하고 \sphinxstylestrong{완료} 버튼을 누르면 데이터 소스가 생성됩니다. 이때, 원천 데이터에서부터 Metatron 내장 엔진(Druid)으로 적재(ingestion)하기 때문에 데이터량에 따라 수 초\textasciitilde{}분의 시간이 소요될 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_file_12}.png}
\end{figure}
\end{quote}

\item {} 
데이터 적재가 완료된 후 상태를 확인해볼 수 있습니다. 아래 예시에서는 상태가 \sphinxstylestrong{ENABLED}로 되어 있으며 히스토그램이 보입니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_file_13}.png}
\end{figure}
\end{quote}

\item {} 
\sphinxstylestrong{데이터} 탭으로 이동을 하면 적재된 데이터를 테이블 형태로 확인할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_file_15}.png}
\end{figure}
\end{quote}

\item {} 
\sphinxstylestrong{데이터 소스} 관리 홈 화면으로 이동하면 생성된 데이터 소스를 화면에서 확인할 수 있습니다. 데이터 적재가 수행되는 중에는 아래와 같이 상태가 \sphinxstylestrong{Disabled}로 표시되게 되고 적재가 완료되면 \sphinxstylestrong{Enabled}로 변경됩니다. 이때부터 데이터 소스를 사용할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_file_16}.png}
\end{figure}
\end{quote}

\end{enumerate}


\subsubsection{DB로 데이터 소스 만들기}
\label{\detokenize{discovery/part02/create_a_data_source:db}}\label{\detokenize{discovery/part02/create_a_data_source:create-datasource-from-db}}
외부 데이터베이스에서 데이터를 가져와서 데이터 소스를 생성합니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
원천 데이터 타입 선택 화면에서 \sphinxstylestrong{데이터베이스}를 선택합니다.

\item {} 
연결할 데이터베이스의 정보를 입력합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_db_2}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{수집 타입:} 데이터 소스가 데이터를 수집하는 방식을 선택합니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{수집형 데이터(Ingested):} 데이터를 Metatron 서버에 직접 저장하는 방식으로 수집된 데이터 소스들이 출력됩니다.

\item {} 
\sphinxstylestrong{연결형 데이터(Linked):} 연결된 데이터베이스에서 필요한 시점마다 데이터를 가져오는 방식의 데이터 소스들이 출력됩니다.

\end{itemize}

\item {} 
\sphinxstylestrong{데이터 커넥션 로드:} 기존에 등록된 데이터 커넥션에 연결되어 있는 데이터베이스의 접근 정보를 자동으로 불러올 수 있습니다. 단, 이때도 \sphinxstylestrong{유효성 체크} 버튼을 눌러서 연결 검증은 반드시 실시해야 합니다.

\item {} 
\sphinxstylestrong{DB 타입:} 연결할 데이터베이스의 타입을 선택합니다.

\item {} 
\sphinxstylestrong{Host:} 연결할 호스트 값을 입력합니다.

\item {} 
\sphinxstylestrong{Port:} 연결할 포트 번호를 입력합니다.

\item {} 
\sphinxstylestrong{사용자이름:} 해당 데이터베이스의 username을 입력합니다.

\item {} 
\sphinxstylestrong{비밀번호:} 해당 데이터베이스의 비밀번호를 입력합니다.

\item {} 
\sphinxstylestrong{유효성 체크:} 모든 입력 항목을 다 작성하면 테스트 버튼이 활성화 됩니다. 클릭하면 커넥션이 정상적인지 여부가 버튼 하단에 나타납니다. 정상적이라면 \sphinxstylestrong{유효한 커넥션}, 비정상적이라면 \sphinxstylestrong{잘못된 커넥션}이라는 문구가 나타납니다.

\end{itemize}
\end{quote}

\item {} 
데이터를 선택합니다. 연결된 데이터베이스 계정에서 테이블을 선택할 수도 있고 쿼리문을 직접 작성할 수도 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_db_4}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{테이블:} 데이터베이스와 테이블명을 선택한 후 실제 저장될 데이터가 조회되면, 확인 후 \sphinxstylestrong{다음} 버튼을 누릅니다.

\item {} 
\sphinxstylestrong{쿼리:} 원하는 데이터를 가져올 수 있는 쿼리문을 직접 작성하고 \sphinxstylestrong{실행} 버튼을 클릭하면 하단에 데이터가 보여집니다. 데이터를 확인한 후 \sphinxstylestrong{다음} 버튼을 누르십시오.

\end{itemize}
\end{quote}

\item {} 
이후 절차는 {\hyperref[\detokenize{discovery/part02/create_a_data_source:create-datasource-from-file}]{\sphinxcrossref{\DUrole{std,std-ref}{파일로 데이터 소스 만들기}}}} 항목과 동일합니다. 단, 데이터베이스로부터 데이터 소스를 생성할 경우 수집 설정 시 아래와 같이 \sphinxstylestrong{적재 설정} 항목을 추가로 설정해야 합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_db_6}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{1회 수집:} 현재 데이터베이스에 있는 데이터를 이번 한번만 적재합니다. \sphinxstylestrong{최대 건 수}를 선택할 경우 제1행부터 몇 번째 행까지 적재할지 지정할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_db_7}.png}
\end{figure}
\end{quote}

\item {} 
\sphinxstylestrong{주기적 수집:} 기간을 두어 데이터 저장을 주기적으로 실행합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_db_8}.png}
\end{figure}
\end{quote}

\end{itemize}
\end{quote}

\end{enumerate}


\subsubsection{StagingDB로 데이터 소스 만들기}
\label{\detokenize{discovery/part02/create_a_data_source:stagingdb}}\label{\detokenize{discovery/part02/create_a_data_source:create-datasource-from-stagingdb}}
Metatron의 내부 Hive 데이터베이스에서 가져온 데이터를 기반으로 데이터 소스를 생성합니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
원천 데이터 타입 선택 화면에서 \sphinxstylestrong{Staging DB}를 선택합니다.

\item {} 
연결할 데이터베이스와 테이블을 선택하면 데이터가 출력됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_stagingdb_2}.png}
\end{figure}
\end{quote}

\item {} 
이후 절차는 {\hyperref[\detokenize{discovery/part02/create_a_data_source:create-datasource-from-db}]{\sphinxcrossref{\DUrole{std,std-ref}{DB로 데이터 소스 만들기}}}} 항목과 동일합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_stagingdb_3}.png}
\end{figure}
\end{quote}

\end{enumerate}


\subsubsection{Metatron 엔진을 통해 데이터 소스 추가하기}
\label{\detokenize{discovery/part02/create_a_data_source:metatron}}\label{\detokenize{discovery/part02/create_a_data_source:create-datasource-from-metatron}}
Metatron 이전 버전에 저장된 데이터 소스를 마이그레이션합니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
원천 데이터 타입 선택 화면에서 \sphinxstylestrong{Metatron 엔진}을 선택합니다.

\item {} 
아래와 같이 이전 버전의 Metatron에서 만든 데이터 소스가 좌측 화면에 나열되면, 그 중에서 현 버전으로 마이그레이션하고자 하는 데이터 소스들의 확인란에 체크합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_metatron_engine_2}.png}
\end{figure}
\end{quote}

\item {} 
\sphinxstylestrong{마침} 버튼을 누르면 선택한 데이터 소스들이 마이그레이션됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_metatron_engine_3}.png}
\end{figure}
\end{quote}

\end{enumerate}


\section{데이터 커넥션}
\label{\detokenize{discovery/part02/data_connection:id1}}\label{\detokenize{discovery/part02/data_connection::doc}}
Metatron Discovery는 외부 데이터베이스를 직접 연결하는 기능을 지원합니다. 외부 데이터베이스를 연결하려면 해당 데이터베이스에 대한 접근 정보가 담긴 데이터 커넥션을 생성·관리해야 합니다. 데이터 커넥션을 등록해 두면 새로운 데이터베이스 접속 정보를 다시 입력해야 하는 수고를 덜 수 있습니다.

데이터 커넥션 메뉴는 메인 화면 좌측 패널에서 \sphinxstylestrong{MANAGEMENT} \textgreater{} \sphinxstylestrong{데이터 스토리지} \textgreater{} \sphinxstylestrong{데이터 커넥션}을 통해 진입할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_datasource_1}.png}
\end{figure}
\end{quote}


\subsection{데이터 커넥션 관리 홈 화면}
\label{\detokenize{discovery/part02/data_connection:id2}}
\sphinxstylestrong{데이터 커넥션} 화면에서는 데이터베이스 커넥션의 신규 등록·편집·조회가 가능합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{data_connection_1}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{공개:} 데이터 커넥션을 공개 워크스페이스별로 선별하여 조회합니다.

\item {} 
\sphinxstylestrong{생성한 사람:} 데이터 커넥션을 생성한 사람별로 선별하여 조회합니다.

\item {} 
\sphinxstylestrong{DB 타입:} 데이터 커넥션을 DB 타입(MySQL, PostgreSQL, Hive, Presto)별로 선별하여 조회합니다.

\item {} 
\sphinxstylestrong{보안:} 데이터 커넥션을 보안 유형(항상 연결, 사용자 계정, 아이디와 비밀번호)별로 선별하여 조회합니다.

\item {} 
\sphinxstylestrong{생성한 시간:} 데이터 커넥션을 생성한 시간(오늘, 지난 7일, 사용자설정 기간)별로 선별하여 조회합니다.

\item {} 
\sphinxstylestrong{검색:} 데이터 커넥션을 데이터 커넥션의 이름으로 검색하여 조회합니다.

\item {} 
\sphinxstylestrong{데이터 커넥션 개수:} 현재 목록에 조회된 데이터 커넥션의 개수를 나타냅니다.

\item {} 
\sphinxstylestrong{새로 만들기:} 클릭하면 새로운 데이터 커넥션을 생성할 수 있습니다.

\item {} 
\sphinxstylestrong{삭제:} 데이터 커넥션에 마우스 오버 시 휴지통 아이콘이 나타납니다. 클릭하면 해당 데이터 커넥션을 삭제할 수 있습니다.

\end{itemize}
\end{quote}


\subsection{데이터 커넥션 만들기}
\label{\detokenize{discovery/part02/data_connection:create-data-connection}}\label{\detokenize{discovery/part02/data_connection:id3}}
\sphinxstylestrong{데이터커넥션 생성하기} 화면에서는 커넥션 생성에 필요한 정보를 입력하여 커넥션을 생성합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{data_connection_creation}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{DB 타입:} 현재 총 4개 타입의 데이터베이스를 지원합니다. (MySQL, PostgreSQL Hive, Presto)

\item {} 
\sphinxstylestrong{Host:} 연결할 호스트 값을 입력합니다.

\item {} 
\sphinxstylestrong{Port:} 연결할 포트 번호를 입력합니다.

\item {} 
\sphinxstylestrong{URL 만:} Host, Port 대신 DB URL을 입력합니다.

\item {} 
\sphinxstylestrong{사용자이름:} 데이터베이스의 사용자 이름을 입력합니다.

\item {} 
\sphinxstylestrong{비밀번호:} 데이터베이스의 비밀번호를 입력합니다.

\item {} 
\sphinxstylestrong{보안:} 데이터 커넥션을 이용할 때 적용할 보안 방식을 설정합니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{항상 연결:} 데이터 커넥션 생성 시 사용자가 직접 입력한 정보를 사용하여 로그인합니다.

\item {} 
\sphinxstylestrong{사용자의 계정으로 연결:} Metatron Discovery에 등록되어 있는 사용자 계정 정보를 사용하여 로그인합니다.

\item {} 
\sphinxstylestrong{아이디와 비밀번호로 연결:} 데이터 커넥션을 사용할 때마다 계정 정보를 입력 받아서 로그인합니다.

\end{itemize}

\item {} 
\sphinxstylestrong{유효성 체크:} 입력한 커넥션 정보가 유효한지 검사하며, 그 결과가 버튼 옆에 나타납니다. 정상적이라면 \sphinxstylestrong{유효한 커넥션}, 비정상적이라면 \sphinxstylestrong{잘못된 커넥션}이라는 문구가 나타납니다.

\item {} 
\sphinxstylestrong{고급설정:} 옵션으로 커스텀 프로퍼티 키와 값을 추가할 수 있습니다.

\item {} 
\sphinxstylestrong{할당:} 생성할 데이터 커넥션의 사용을 허용할 워크스페이스를 지정합니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{모든 워크스페이스에서 이 데이터 커넥션 사용을 허용:} 이 확인란에 체크하면 모든 워크스페이스에서 해당 데이터 커넥션을 사용할 수 있습니다.

\item {} 
\sphinxstylestrong{수정:} 해당 데이터 커넥션의 사용을 허용할 특정 워크스페이스를 지정할 때 사용합니다. 해당 데이터 커넥션을 오픈 데이터로 지정할 경우 이 버튼이 사라집니다.

\item {} 
\sphinxstylestrong{공유 워크스페이스 수:} 해당 데이터 커넥션을 사용할 수 있도록 허용된 워크스페이스의 수를 나타냅니다.

\end{itemize}

\end{itemize}
\end{quote}


\section{데이터 모니터링}
\label{\detokenize{discovery/part02/data_monitoring:id1}}\label{\detokenize{discovery/part02/data_monitoring::doc}}
데이터 모니터링은 Metatron Workbench에서 유저가 Staging DB(내부 Hive DB) 및 Metatron과 연결된 외부 데이터베이스에 질의하는 모든 로그를 관측하는 기능입니다.

데이터 모니터링 메뉴는 메인 화면 좌측 패널에서 \sphinxstylestrong{MANAGEMENT} \textgreater{} \sphinxstylestrong{데이터 스토리지} \textgreater{} \sphinxstylestrong{데이터 모니터링}을 통해 진입할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{data_monitoring_menu}.png}
\end{figure}
\end{quote}


\subsection{로그 통계}
\label{\detokenize{discovery/part02/data_monitoring:id2}}
로그 통계에서는 Metatron Discovery 내 쿼리 수행과 관련된 각종 통계치를 모아서 보여줍니다. 여기에서는 아래와 같이 총 9가지의 기본 통계를 조회할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{log-statistics}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{쿼리 성공/실패율:} Metatron에서 실행된 쿼리들의 성공률과 실패율이 나타납니다.

\item {} 
\sphinxstylestrong{사용자 별 쿼리 빈도 수:} 쿼리를 수행한 사용자별 빈도수를 나타낸 그래프입니다. 표시된 막대 중 하나를 클릭하면 해당 사용자가 실행한 Job Log를 볼 수 있습니다.

\item {} 
\sphinxstylestrong{오래 걸리는 순:} 수행한 쿼리들이 작업시간이 긴 순서대로 정렬되어 나타납니다.

\item {} 
\sphinxstylestrong{스캔 데이터량:} 수행한 쿼리들이 데이터를 제일 많이 스캔한 순서대로 정렬되어 나타납니다.

\item {} 
\sphinxstylestrong{성공한 쿼리 빈도:} 수행한 쿼리들이 성공한 빈도가 높은 순서대로 정렬되어 나타납니다.

\item {} 
\sphinxstylestrong{실패한 쿼리 빈도:} 수행한 쿼리들이 실패한 빈도가 높은 순서대로 정렬되어 나타납니다.

\item {} 
\sphinxstylestrong{총 메모리 사용량:} 수행한 쿼리들이 총 메모리 사용량이 큰 순서대로 정렬되어 나타납니다.

\item {} 
\sphinxstylestrong{총 CPU 사용량:} 수행한 쿼리들이 총 CPU 사용량이 큰 순서대로 정렬되어 나타납니다.

\item {} 
\sphinxstylestrong{Queue별 리소스 사용량:} Hadoop 환경의 각 YARN queue에서 소모되는 리소스량을 보여줍니다.

\end{enumerate}
\end{quote}


\subsection{잡 로그}
\label{\detokenize{discovery/part02/data_monitoring:id3}}
본 메뉴에서는 Metatron에서 수행된 모든 쿼리의 내역을 조회할 수 있습니다. 쿼리 이력을 원하는 조건으로 검색하여 기존에 발생한 job 이력을 손쉽게 찾아볼 수 있습니다. 아래는 검색이 가능한 job 조건들입니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{job-logs}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{상태:} 수행된 쿼리들을 성패 기준으로 선별하여 조회합니다.

\item {} 
\sphinxstylestrong{Limited elapsed time:} 수행 시간이 오래 소요된 쿼리들을 선별하여 조회합니다. 기준 시간은 원하는 대로 설정 가능합니다.

\item {} 
\sphinxstylestrong{Performed start Time:} 쿼리 조회 시 적용되는 시간 기준입니다. 여기서의 시간은 각 쿼리가 수행을 시작하는 시간을 기준으로 합니다.

\item {} 
\sphinxstylestrong{Job 또는 어플리케이션으로 검색:} 현재 이력으로 남은 쿼리들을 쿼리문 또는 Application ID로 검색합니다.

\item {} 
\sphinxstylestrong{데이터 개수:} 현재 목록에 조회된 쿼리의 개수를 나타냅니다.

\item {} 
\sphinxstylestrong{Job 목록:} 설정한 선별 조건에 맞는 쿼리들을 보여줍니다. 이 중 하나를 클릭하면 상세 내역을 볼 수 있습니다.

\end{enumerate}
\end{quote}


\subsubsection{쿼리 상세 정보}
\label{\detokenize{discovery/part02/data_monitoring:id4}}
잡 로그 홈에 열거된 쿼리 중 하나를 클릭하면 해당 쿼리에 관한 다양한 정보와 이력을 확인할 수 있습니다. 상세 내역에서 조회 가능한 정보는 다음과 같습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{job-log-detail}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{상태:} 해당 쿼리의 성공 여부를 나타냅니다.

\item {} 
\sphinxstylestrong{잡 이름:} 수행된 쿼리문입니다.

\item {} 
\sphinxstylestrong{시작시간:} 해당 쿼리가 수행되기 시작한 시간을 나타냅니다.

\item {} 
\sphinxstylestrong{작업시간:} 해당 쿼리가 수행되는 데 걸린 시간을 나타냅니다.

\item {} 
\sphinxstylestrong{사용자:} 해당 쿼리를 수행한 사용자 ID입니다.

\item {} 
\sphinxstylestrong{커넥션:} 워크벤치에서 실행된 쿼리일 경우, 대상 데이터 커넥션의 정보를 나타냅니다.

\item {} 
\sphinxstylestrong{동일 커넥션의 최근 사용 기록:} 워크벤치에서 실행된 쿼리일 경우, 해당 데이터베이스에서 수행된 최근 5건의 쿼리 내역과 그 결과가 나타납니다. Detail을 클릭하면 해당 쿼리문이 새 창에 출력됩니다.

\item {} 
\sphinxstylestrong{플랜:} 쿼리 수행 계획을 실행합니다.

\end{enumerate}
\end{quote}


\chapter{워크스페이스}
\label{\detokenize{discovery/part03/index:id1}}\label{\detokenize{discovery/part03/index::doc}}
\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workspace_overview}.png}
\end{figure}

워크스페이스는 Metatron Discovery의 분석 모듈인 워크북, 노트북, 워크벤치를 보관하는 작업 공간으로, 개인용 워크스페이스와 공유용 워크스페이스로 분류됩니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{개인 워크스페이스:} Discovery 회원별로 하나씩 할당되는 개인용 워크스페이스입니다. 이 워크스페이스는 본인만 접근 가능합니다.

\item {} 
\sphinxstylestrong{공유 워크스페이스:} 여러 사용자가 함께 사용할 수 있는 워크스페이스입니다. 분석 과정과 결과를 다른 사용자들과 공유하기 위한 공간입니다. 각 공유 워크스페이스의 소유자 또는 관리자는 Discovery 회원들에게 다양한 수준의 접근 권한을 부여할 수 있습니다.

\end{itemize}

본 단원에서는 \sphinxstylestrong{워크스페이스 홈 화면 구성과 UI}, 그리고 \sphinxstylestrong{공유 워크스페이스}를 활용하는 방식에 대해 소개합니다.


\section{워크스페이스 홈}
\label{\detokenize{discovery/part03/workspace_management:id1}}\label{\detokenize{discovery/part03/workspace_management::doc}}
워크스페이스 홈 화면에서는 Metatron Discovery의 분석 모듈(워크북, 노트북, 워크벤치)의 관리 기능을 수행할 수 있습니다.


\subsection{워크스페이스 홈 화면 구성}
\label{\detokenize{discovery/part03/workspace_management:id2}}
아래는 워크스페이스 홈 화면의 전반적인 구성을 설명한 것입니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workspace_home}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{메인 메뉴 버튼:} 해당 버튼을 클릭하면 다른 워크스페이스로 접근할 수 있는 패널이 열립니다.

\item {} 
\sphinxstylestrong{워크스페이스 정보:} 해당 워크스페이스의 이름과 설명을 보여줍니다. 로그인한 사용자가 소유하는 워크스페이스일 경우, 워크스페이스 이름 옆에 '소유자'라는 아이콘이 보입니다.

\item {} 
\sphinxstylestrong{등록 개체 현황:} 워크스페이스 내에 등록된 개체 타입별 개수를 보여줍니다.

\item {} 
\sphinxstylestrong{데이터 소스:} 해당 워크스페이스에서 사용 중인 데이터 소스의 개수를 보여주며, 이 영역을 클릭하면 사용 중인 데이터 소스들의 목록이 나타납니다.

\item {} 
\sphinxstylestrong{워크스페이스 목록:} 이 버튼을 클릭하면 공유 워크스페이스의 목록이 나타납니다. (자세한 내용은 {\hyperref[\detokenize{discovery/part03/shared_workspace:shared-workspace-list}]{\sphinxcrossref{\DUrole{std,std-ref}{공유 워크스페이스 목록}}}} 참조)

\item {} 
\sphinxstylestrong{생성 정보:} 해당 워크스페이스의 생성일과 만든 사용자 이름을 보여줍니다.

\item {} 
\sphinxstylestrong{더 보기:} 해당 워크스페이스의 정보를 수정합니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{이름 및 설명 수정:} 해당 워크스페이스의 이름과 설명을 수정합니다.

\item {} 
\sphinxstylestrong{공유 회원 및 그룹 설정:} 해당 워크스페이스에 접근할 수 있는 사용자와 그룹을 지정합니다. (자세한 사항은 {\hyperref[\detokenize{discovery/part03/shared_workspace:shared-workspace-permission}]{\sphinxcrossref{\DUrole{std,std-ref}{공유 워크스페이스 접근 권한 설정}}}} 참조)

\item {} 
\sphinxstylestrong{노트북 서버 설정:} 노트북 모듈이 사용하는 외부 분석 도구 서버 접근 정보를 설정합니다.

\item {} 
\sphinxstylestrong{권한 스키마 설정:} 해당 워크스페이스에서의 사용자 역할별 접근 권한을 설정합니다. (자세한 사항은 {\hyperref[\detokenize{discovery/part03/shared_workspace:shared-workspace-permission}]{\sphinxcrossref{\DUrole{std,std-ref}{공유 워크스페이스 접근 권한 설정}}}} 참조)

\item {} 
\sphinxstylestrong{소유자 변경:} 해당 워크스페이스의 소유자를 바꿉니다.

\item {} 
\sphinxstylestrong{워크스페이스 삭제:} 해당 워크스페이스를 삭제합니다.

\end{itemize}

\item {} 
\sphinxstylestrong{워크스페이스 경로:} 워크스페이스 내에서의 현재 위치를 확인합니다. 경로에 나열된 상위 폴더 중 하나를 클릭하면 해당 폴더로 이동합니다.

\item {} 
\sphinxstylestrong{폴더 생성:} 클릭하면 현재 위치에 새 폴더를 생성합니다.

\item {} 
\sphinxstylestrong{개체 목록 선별/정렬:}
\begin{itemize}
\item {} 
\sphinxstylestrong{검색:} 해당 워크스페이스 내에서 개체 또는 폴더를 이름으로 검색합니다.

\item {} 
\sphinxstylestrong{개체 타입:} 워크북, 노트북, 워크벤치 중 원하는 개체 타입만을 선별해서 조회합니다.

\item {} 
\sphinxstylestrong{정렬 순서:} 폴더 및 개체를 이름 또는 업데이트 시간 순서로 정렬합니다.

\item {} 
\sphinxstylestrong{뷰 형식:} 워크스페이스 내 개체들의 열거 방식을 카드뷰와 리스트뷰 중에서 선택합니다.

\end{itemize}

\item {} 
\sphinxstylestrong{폴더 목록:} 현재 위치에서 검색 조건에 부합하는 폴더들을 보여줍니다. 이중 하나를 클릭하면 해당 폴더 안으로 이동합니다. (개별 폴더 항목에 대한 자세한 설명은 {\hyperref[\detokenize{discovery/part03/workspace_management:folders}]{\sphinxcrossref{\DUrole{std,std-ref}{폴더 항목}}}} 참조)

\item {} 
\sphinxstylestrong{개체 목록:} 현재 위치에서 검색 또는 선별 조건에 부합하는 개체들을 보여줍니다. 이 중 하나를 클릭하면 해당 개체의 홈 화면으로 이동합니다. (개별 개체 항목에 대한 자세한 설명은 {\hyperref[\detokenize{discovery/part03/workspace_management:items}]{\sphinxcrossref{\DUrole{std,std-ref}{개체 항목}}}} 참조)

\item {} 
\sphinxstylestrong{개체 선택/복사/이동/삭제:} 개체 전체 선택, 복사, 이동, 삭제를 합니다. (자세한 내용은 {\hyperref[\detokenize{discovery/part03/workspace_management:actions}]{\sphinxcrossref{\DUrole{std,std-ref}{폴더 및 개체 선택/복사/이동/삭제}}}} 참조)

\item {} 
\sphinxstylestrong{개체 생성:} 해당 워크스페이스에서 원하는 타입의 개체를 만드는 데 사용되는 버튼들입니다. (구체적인 절차는 각각 {\hyperref[\detokenize{discovery/part04/create_a_workbook::doc}]{\sphinxcrossref{\DUrole{doc}{워크북 만들기}}}}, {\hyperref[\detokenize{discovery/part05/create_a_notebook::doc}]{\sphinxcrossref{\DUrole{doc}{신규 노트북 생성하기}}}}, {\hyperref[\detokenize{discovery/part06/06_02-create_a_workbench::doc}]{\sphinxcrossref{\DUrole{doc}{워크벤치 만들기}}}} 참조)

\end{enumerate}
\end{quote}


\subsection{폴더 항목}
\label{\detokenize{discovery/part03/workspace_management:folders}}\label{\detokenize{discovery/part03/workspace_management:id3}}
각 폴더에 마우스를 올렸을 때 다음과 같이 항목들이 표시됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workspace_entity_folder}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{확인란:} 해당 폴더를 선택할 때 사용합니다. 선택한 폴더는 복제, 이동, 삭제할 수 있습니다.

\item {} 
\sphinxstylestrong{이름:} 해당 폴더의 이름입니다.

\item {} 
\sphinxstylestrong{수정:} 클릭하면 폴더의 이름을 수정할 수 있습니다. 이 버튼은 해당 폴더 항목에 마우스를 오버할 때만 나타납니다.

\item {} 
\sphinxstylestrong{삭제:} 클릭하면 해당 폴더가 삭제됩니다. 이 버튼은 해당 폴더 항목에 마우스를 오버할 때만 나타납니다.

\end{itemize}
\end{quote}


\subsection{개체 항목}
\label{\detokenize{discovery/part03/workspace_management:items}}\label{\detokenize{discovery/part03/workspace_management:id4}}
각 개체에 마우스를 올렸을 때 다음과 같이 항목들이 표시됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workspace_entity_object}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{확인란:} 해당 개체를 선택할 때 사용됩니다. 선택한 개체는 복제, 이동, 삭제할 수 있습니다.

\item {} 
\sphinxstylestrong{개체 타입:} 해당 개체가 워크북/노트북/워크벤치 중에서 어느 타입인지 보여줍니다.

\item {} 
\sphinxstylestrong{삭제:} 클릭하면 해당 개체가 삭제됩니다. 이 버튼은 해당 개체 항목에 마우스를 오버할 때만 나타납니다.

\item {} 
\sphinxstylestrong{이름:} 해당 개체의 이름입니다.

\item {} 
\sphinxstylestrong{업데이트 시점:} 해당 개체가 마지막으로 업데이트된 시점을 보여줍니다.

\item {} 
\sphinxstylestrong{데이터 소스/대시보드 개수:} 이 영역은 워크북 개체에만 고유합니다.
\begin{itemize}
\item {} 
\sphinxincludegraphics{{icon_datasource}.png} 아이콘 옆 숫자는 해당 워크북에 연동된 데이터 소스의 개수를 가리킵니다.

\item {} 
\sphinxincludegraphics{{icon_dashboard}.png} 아이콘 옆 숫자는 해당 워크북에 등록된 대시보드의 개수를 가리킵니다.

\end{itemize}

\end{itemize}
\end{quote}


\subsection{폴더 및 개체 선택/복사/이동/삭제}
\label{\detokenize{discovery/part03/workspace_management:actions}}\label{\detokenize{discovery/part03/workspace_management:id5}}
워크스페이스 내 폴더와 개체는 복사/이동/삭제가 가능합니다. 복사/이동/삭제를 원하는 폴더 또는 개체를 선택하면 워크스페이스 홈 화면 좌측 하단의 동작 버튼들이 활성화됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workspace_entity_folder_and_object_manipulation}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{전체 선택:} 현재 폴더 목록과 개체 목록에 나타난 모든 항목을 선택합니다.

\item {} 
\sphinxstylestrong{워크북 복사:} 워크북에만 유효한 기능입니다. 이 버튼을 클릭하면 선택한 워크북이 복제됩니다.

\item {} 
\sphinxstylestrong{선택 이동:} 선택한 폴더 및 개체를 이동합니다. 워크북의 경우에는 다른 워크스페이스로 이동이 가능하고, 그 외의 항목들은 동일 워크스페이스 내 다른 폴더로 이동이 가능합니다. 워크북이 다른 개체와 함께 선택되어 있을 때는 이동을 실행할 수 없습니다.

\item {} 
\sphinxstylestrong{선택 삭제:} 선택한 폴더 및 개체를 삭제합니다.

\end{itemize}
\end{quote}


\section{공유 워크스페이스}
\label{\detokenize{discovery/part03/shared_workspace:id1}}\label{\detokenize{discovery/part03/shared_workspace::doc}}
공유 워크스페이스는 여러 사용자가 함께 열람하고 사용하는 워크스페이스입니다. 아래 각 절에서는 공유 워크스페이스를 조회하고 생성하는 법을 설명하고, 공유 워크스페이스에 접근 가능한 사용자나 그룹을 설정할 수 있는 권한 스키마에 대해서 살펴봅니다.


\subsection{공유 워크스페이스 목록}
\label{\detokenize{discovery/part03/shared_workspace:shared-workspace-list}}\label{\detokenize{discovery/part03/shared_workspace:id2}}
공유 워크스페이스 목록 화면에서는 로그인한 사용자가 접근할 수 있는 모든 공유 워크스페이스의 목록을 열람하고 원하는
워크스페이스로 이동할 수 있습니다. 이 화면은 다음과 같은 두 가지 방식으로 접근할 수 있습니다.
\begin{itemize}
\item {} 
Discovery 화면 좌측 상단에서 \sphinxincludegraphics{{icon_more2}.png} 버튼을 클릭하여 메인 패널을 연 후 \sphinxstylestrong{워크스페이스 목록 \textgreater{}\textgreater{}}을 클릭합니다.

\item {} 
워크스페이스 홈 화면 우측 상단의 \sphinxstylestrong{워크스페이스 목록} 버튼을 클릭합니다.

\end{itemize}

공유 워크스페이스 목록 화면은 다음과 같이 구성됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{shared_workspace_list}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{공유 워크스페이스 개수:} 목록에 나열된 공유 워크스페이스의 개수가 나타납니다.

\item {} 
\sphinxstylestrong{공유 워크스페이스 추가:} 이 버튼을 클릭하면 공유 워크스페이스를 추가하는 화면으로 이동합니다. (구체적인 절차는 {\hyperref[\detokenize{discovery/part03/shared_workspace:shared-workspace-creation}]{\sphinxcrossref{\DUrole{std,std-ref}{공유 워크스페이스 생성}}}} 참조)

\item {} 
\sphinxstylestrong{개인 워크스페이스:} 이 버튼을 클릭하면 로그인한 사용자의 개인 워크스페이스로 이동합니다.

\item {} 
\sphinxstylestrong{검색:} 공유 워크스페이스를 이름으로 검색합니다.

\item {} 
\sphinxstylestrong{즐겨찾기:} 즐겨찾기로 지정된 워크스페이스만 선별합니다.

\item {} 
\sphinxstylestrong{오직 공개만 보기:} 전체 공개 설정된 워크스페이스만 선별합니다.

\item {} 
\sphinxstylestrong{소유자만 보기:} 로그인한 사용자가 관리자로 설정되어 있는 워크스페이스 목록이 나타납니다.

\item {} 
\sphinxstylestrong{이름 내림차순/오름차순:} 공유 워크스페이스 이름을 내림차순/오름차순으로 정렬합니다.

\item {} 
\sphinxstylestrong{워크스페이스 목록:} 설정한 선별 조건에 맞는 워크스페이스들을 보여줍니다. 이 중 하나를 클릭하면 해당 워크스페이스에 입장합니다.

\end{enumerate}
\end{quote}


\subsection{공유 워크스페이스 생성}
\label{\detokenize{discovery/part03/shared_workspace:shared-workspace-creation}}\label{\detokenize{discovery/part03/shared_workspace:id3}}
다음의 순서로 새 공유 워크스페이스를 생성할 수 있습니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
공유 워크스페이스 목록에서 \sphinxincludegraphics{{icon_plus}.png} 버튼을 클릭하면 새 공유 워크스페이스를 생성하는 화면이 나타납니다.

\item {} 
\sphinxstylestrong{이름}과 \sphinxstylestrong{설명}을 입력한 후, 아래 설명을 참조하여 \sphinxstylestrong{Permission schema}를 설정합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{shared_workspace_creation}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{프리셋 스키마 사용:} 관리자가 기존에 정의해놓은 권한 스키마를 불러옵니다.

\item {} 
\sphinxstylestrong{커스텀 스키마 사용:} 새 권한 스키마를 정의합니다. (새 권한 스키마를 정의하는 방식은 {\hyperref[\detokenize{discovery/part03/shared_workspace:shared-workspace-permission}]{\sphinxcrossref{\DUrole{std,std-ref}{공유 워크스페이스 접근 권한 설정}}}} 참조)

\end{itemize}
\end{quote}

\item {} 
\sphinxstylestrong{마침} 버튼을 눌러 워크스페이스 생성을 완료합니다.

\end{enumerate}


\subsection{공유 워크스페이스 접근 권한 설정}
\label{\detokenize{discovery/part03/shared_workspace:shared-workspace-permission}}\label{\detokenize{discovery/part03/shared_workspace:id4}}
공유 워크스페이스 접근 권한 설정은 기본적으로 다음과 같은 두 단계로 이루어집니다.
\begin{itemize}
\item {} 
사용자 역할별 접근 권한 정의 ({\hyperref[\detokenize{discovery/part03/shared_workspace:permission-schema-setup}]{\sphinxcrossref{\DUrole{std,std-ref}{권한 스키마 설정}}}} 참조)

\item {} 
개별 사용자 또는 사용자 그룹 각각에게 적합한 사용자 역할 부여 ({\hyperref[\detokenize{discovery/part03/shared_workspace:shared-members-setup}]{\sphinxcrossref{\DUrole{std,std-ref}{공유 멤버 및 그룹 설정}}}} 참조)

\end{itemize}


\subsubsection{권한 스키마 설정}
\label{\detokenize{discovery/part03/shared_workspace:permission-schema-setup}}\label{\detokenize{discovery/part03/shared_workspace:id5}}

\paragraph{권한 스키마 조회하기}
\label{\detokenize{discovery/part03/shared_workspace:permission-schema-view}}\label{\detokenize{discovery/part03/shared_workspace:id6}}
공유 워크스페이스 홈 화면 우측 상단에 있는 \sphinxincludegraphics{{icon_more2}.png} 버튼을 클릭한 후, \sphinxstylestrong{권한 스키마 설정}을 누르면 아래와 같이 현재 정의된 권한 스키마를 보여줍니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{shared_workspace_permission_schema_view}.png}
\end{figure}
\end{quote}

위 예시 그림에서는 사용자 역할(User role)로서 Manager, Editor, Watcher, Guest가 정의되어 있습니다. '권한 스키마'란, 이와 같이 각각 고유한 접근 권한이 정의된 사용자 역할들의 집합을 일컫는 말입니다.

각 사용자 역할에 대한 컬럼별 속성은 다음과 같습니다.
\begin{quote}

\sphinxstylestrong{Default role}

새롭게 추가되는 개별 사용자나 사용자 그룹에게는 Default role로 지정된 사용자 역할이 기본적으로 부여됨

\sphinxstylestrong{워크북/노트북/워크벤치 개체 타입별 권한}
\begin{itemize}
\item {} 
\sphinxstylestrong{View:} 해당 타입의 개체에 접근하여 데이터를 열람할 수 있음

\item {} 
\sphinxstylestrong{Create:} 해당 타입의 개체를 생성, 수정, 삭제할 수 있음

\item {} 
\sphinxstylestrong{Edit any:} 다른 사용자가 생성한 해당 타입의 개체를 수정, 삭제할 수 있음

\end{itemize}

\sphinxstylestrong{워크스페이스 권한}
\begin{itemize}
\item {} 
Create folders: 워크스페이스 내 폴더를 생성, 수정, 삭제할 수 있음

\item {} 
Set config.: 워크스페이스의 이름과 설명을 수정하고 워크스페이스 권한 스키마를 바꿀 수 있음

\end{itemize}
\end{quote}


\paragraph{권한 스키마 설정 바꾸기}
\label{\detokenize{discovery/part03/shared_workspace:id7}}
권한 스키마 조회 화면에서 \sphinxstylestrong{스키마 변경} 버튼을 클릭하면 아래와 같이 기존에 정의된 권한 스키마를 변경할 수 있는 화면이 나타납니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{shared_workspace_permission_schema_change01}.png}
\end{figure}
\end{quote}

화면 우측에 있는 \sphinxstylestrong{Select Role Set} 콤보박스를 클릭하면 관리자가 정의해놓은 스키마들이 제시되고, 목록 맨 아래에는 새로운 사용자 역할을 정의할 수 있는 \sphinxstylestrong{커스텀 스키마} 항목이 있습니다. 이중 하나를 선택하면 아래와 같은 화면이 나타납니다. (\sphinxstylestrong{커스텀 스키마} 항목을 선택했을 경우 사용자 역할별 권한부터 정의해야 합니다. New schema 우측의 \sphinxincludegraphics{{icon_edit}.png} 버튼을 눌러 권한 설정 화면으로 이동한 후 {\hyperref[\detokenize{discovery/part03/shared_workspace:permission-schema-view}]{\sphinxcrossref{\DUrole{std,std-ref}{권한 스키마 조회하기}}}} 항목의 설명을 참조하여 사용자 역할별로 권한을 설정하십시오.)
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{shared_workspace_permission_schema_change02}.png}
\end{figure}
\end{quote}

여기서는 현 권한 스키마의 각 사용자 역할을 새로운 권한 스키마에 정의된 사용자 역할로 치환하는 작업을 합니다. 각 사용자 역할 이름 옆에 있는 \sphinxincludegraphics{{icon_info}.png} 아이콘에 마우스를 오버하면 해당 사용자 역할에 할당된 권한이 나타납니다. \sphinxstylestrong{마침} 버튼을 누르면 권한 스키마 설정이 완료됩니다.


\subsubsection{공유 멤버 및 그룹 설정}
\label{\detokenize{discovery/part03/shared_workspace:shared-members-setup}}\label{\detokenize{discovery/part03/shared_workspace:id8}}
공유 워크스페이스 홈 화면 우측 상단에 있는 더보기 아이콘을 클릭한 후 \sphinxstylestrong{공유 멤버 및 그룹 설정}을 누르면 아래와 같이 공유 멤버 및 그룹 설정 화면이 나타납니다. 여기서는 권한 스키마에서 정의된 각 사용자 역할을 개별 사용자 또는 사용자 그룹에 할당하는 작업을 합니다. 아래 설명을 참조하여 사용자 역할을 할당한 후 \sphinxstylestrong{마침} 버튼을 누르면 워크스페이스 접근 권한 설정이 완료됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{shared_workspace_shared_member_group_setting}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{사용자 역할 할당 단위 선택}
\begin{itemize}
\item {} 
\sphinxstylestrong{멤버 탭:} 사용자 역할을 개별 사용자 단위로 할당합니다.

\item {} 
\sphinxstylestrong{그룹 탭:} 사용자 역할을 사용자 그룹 단위로 할당합니다. (사용자 그룹은 관리자 권한으로 지정할 수 있습니다.)

\end{itemize}

\item {} 
\sphinxstylestrong{사용자 역할:} 클릭하면 권한 스키마(사용자 역할별 권한 정의) 정보가 팝업 창으로 나타납니다.

\item {} 
\sphinxstylestrong{멤버/그룹 목록:} Discovery에 등록된 사용자들(그룹 탭에서는 그룹들)이 나열됩니다. 목록에 있는 사용자(그룹) 중 하나를 클릭하면 우측 역할 부여 영역에 추가됩니다. 이미 추가된 사용자(그룹)을 클릭하면 해당 사용자(그룹)가 우측 영역에서 제거됩니다.

\item {} 
\sphinxstylestrong{사용자 역할 할당:} 이 콤보박스를 클릭하면 현재 적용 중인 권한 스키마에 정의된 사용자 역할들이 나타납니다. 이중에서 해당 사용자(그룹)에게 할당하고자 하는 역할을 선택하면 됩니다.

\end{enumerate}
\end{quote}


\chapter{워크북}
\label{\detokenize{discovery/part04/index:id1}}\label{\detokenize{discovery/part04/index::doc}}
\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workbook_overview_01}.png}
\end{figure}

워크북은 Metatron Discovery의 Druid 엔진을 기반으로 하는 비주얼 데이터 분석 모듈입니다.
위 그림과 같이 하나의 독립된 보고서 단위에 해당하는 각 \sphinxstylestrong{워크북}은 다양한 \sphinxstylestrong{대시보드}로 구성되며, 각 대시보드는 원천 데이터 분석 결과를 시각화해서 보여주는 각종 \sphinxstylestrong{차트}로 구성되어 있습니다.

워크북의 기본적인 특징은 다음과 같습니다.
\begin{itemize}
\item {} 
시계열 기반의 다차원 데이터 소스를 이용하여 신속하고 유연한 데이터 분석 가능.

\item {} 
각 대시보드에서 각종 차트와 텍스트 등의 시각화 위젯을 배치함으로써 프레젠테이션 형식의 보고서로 활용 가능.

\item {} 
클러스터링, 예측선, 추세선 등의 자주 쓰는 알고리즘을 GUI(Graphical User Interface)로 구현 가능.

\end{itemize}

본 단원의 구성은 아래와 같습니다.


\section{워크북 만들기}
\label{\detokenize{discovery/part04/create_a_workbook:id1}}\label{\detokenize{discovery/part04/create_a_workbook::doc}}
Metatron Discovery에서 \sphinxstylestrong{워크북}은 하나의 독립적인 데이터 분석 보고서로서 기능을 합니다. 하나의 워크북을 생성하면 그 안에 여러 \sphinxstylestrong{대시보드} 슬라이드를 담아서 적절한 순서대로 보여줄 수 있습니다.

워크북 생성 절차는 다음과 같습니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
워크스페이스 하단에 있는 \sphinxstylestrong{+ 워크북} 버튼을 클릭하면 워크북을 생성할 수 있는 화면이 나타납니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_workbook_01}.png}
\end{figure}
\end{quote}

\item {} 
생성하고자 하는 워크북의 이름(필수 사항)과 설명을 입력하고 \sphinxstylestrong{마침} 버튼을 누릅니다. \sphinxstylestrong{Continue to create a dashboard of a new workbook} 박스에 체크하면 워크북 생성과 동시에 \sphinxstylestrong{대시보드 생성하기} 화면으로 넘어갑니다. 워크북은 그 안에 대시보드가 있어야 비로소 기능을 할 수 있기 때문에 이렇게 연결되는 것입니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_workbook_02}.png}
\end{figure}
\end{quote}

\item {} 
화면 가운데의 '+ 데이터 소스 추가' 버튼을 클릭 후, 데이터 소스를 선택하여 대시보드를 생성합니다. 대시보드를 생성하는 절차에 관한 자세한 내용은 {\hyperref[\detokenize{discovery/part04/create_a_dashboard::doc}]{\sphinxcrossref{\DUrole{doc}{대시보드 만들기}}}} 항목을 참조하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_workbook_03}.png}
\end{figure}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_workbook_04}.png}
\end{figure}
\end{quote}

\item {} 
새로 생성된 워크북은 아래와 같이 워크스페이스 화면에서 확인할 수 있습니다. 클릭하면 해당 워크북을 사용할 수 있는 화면이 나타납니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{create_a_workbook_05}.png}
\end{figure}
\end{quote}

\end{enumerate}


\section{대시보드}
\label{\detokenize{discovery/part04/manage_dashboards:id1}}\label{\detokenize{discovery/part04/manage_dashboards::doc}}
\sphinxstylestrong{대시보드}는 워크북 안에 보관되며 특정한 데이터 소스를 사용자의 필요에 맞게 분석하고 시각화하는 기능을 제공합니다. 따라서 대시보드 생성 절차는 주로 데이터 소스를 연결하는 것부터 시작됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard_overview_01}.png}
\end{figure}
\end{quote}

여러 데이터 소스를 기반으로 차트와 텍스트 기반의 시각화 분석에 더해, 피봇, 맵차트, 필터링 기능을 통해 분석 작업을 커스터마이징할 수 있습니다.


\subsection{대시보드 만들기}
\label{\detokenize{discovery/part04/create_a_dashboard:id1}}\label{\detokenize{discovery/part04/create_a_dashboard::doc}}
대시보드 생성 절차는 다음과 같습니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
워크북 화면에서 \sphinxstylestrong{+ 데이터 소스 추가}를 클릭합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard.01}.png}
\end{figure}
\end{quote}

\item {} 
해당 워크스페이스에 공개된 데이터 소스 목록에서 대시보드에 연결할 마스터 데이터 소스들을 선택합니다. 이후 단계에서는 여기서 선택하는 마스터 데이터 소스들에 join시킬 다른 데이터 소스를 추가적으로 선택할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard.02}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{데이터 소스 이름 검색:} 해당 워크스페이스에 허용된 데이터 소스를 이름으로 검색합니다.

\item {} 
\sphinxstylestrong{오픈 데이터만 보기:} '오픈 데이터 소스'로 지정된 데이터 소스만 선별하여 볼 수 있습니다.

\item {} 
\sphinxstylestrong{타입:} 데이터 소스를 연결형 또는 수집형으로 선별하여 볼 수 있습니다.

\item {} 
\sphinxstylestrong{데이터 소스 목록:} 설정한 선별 조건에 맞는 데이터 소스들을 보여줍니다.

\item {} 
\sphinxstylestrong{데이터 소스 정보:} 목록에서 선택한 데이터 소스의 정보를 간략하게 보여줍니다.

\end{itemize}
\end{quote}

\item {} 
둘 이상의 데이터 소스를 선택할 경우에는 한 데이터 소스를 다른 데이터 소스로 드래그함으로써 둘을 연결시킬 수 있습니다. 연결된 데이터 소스끼리는 상호간 필터링이 가능합니다. 데이터 소스 연결이 필요 없다면 \sphinxstylestrong{마침} 버튼을 클릭하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard.03}.png}
\end{figure}
\end{quote}

\item {} 
한 데이터 소스를 다른 데이터 소스로 드래그하면 데이터 소스 연결을 설정할 수 있는 새 창이 열립니다. 양 테이블에서 상호간 필터링을 할 수 있는 연결 키로 사용할 컬럼을 하나씩 선택한 후 \sphinxstylestrong{마침}을 클릭하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard.04}.png}
\end{figure}
\end{quote}

\item {} 
마스터 데이터 소스 간의 연결 관계를 설정하였으면 \sphinxstylestrong{마침}을 클릭합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard.04-1}.png}
\end{figure}
\end{quote}

\item {} 
아래 설명을 참조하여 마스터 데이터 소스 연결을 재설정하거나, 앞에서 선택한 최상위 데이터 소스에 join시킬 다른 데이터 소스들을 추가합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard.05}.png}
\end{figure}

마스터 데이터 소스 연결 관계 뷰
\begin{itemize}
\item {} 
\sphinxincludegraphics{{dashboard.icon_plus}.png} : 클릭하면 새 마스터 데이터 소스를 추가할 수 있습니다.

\item {} 
\sphinxstylestrong{연결 수정:} 클릭하면 데이터 소스 연결 관계를 수정할 수 있습니다.

\end{itemize}

개별 마스터 데이터 소스 설정 패널(다이어그램에서 마스터 데이터 소스에 해당하는 타원 중 하나를 클릭 시 열림)
\begin{itemize}
\item {} 
\sphinxstylestrong{데이터 미리보기:} 데이터 소스 join에 따른 결과 테이블을 보여줍니다.

\item {} 
\sphinxstylestrong{스키마 관리:} 선택한 데이터 소스의 join 관계를 관리할 수 있습니다(자세한 절차는 다음 단계를 확인하십시오).

\item {} 
\sphinxstylestrong{연결해제:} 클릭하면 선택한 데이터 소스가 제거됩니다.

\item {} 
\sphinxincludegraphics{{dashboard.icon_X}.png} : 클릭하면 패널이 닫힙니다.

\end{itemize}
\end{quote}

\item {} 
마스터 데이터 소스 중 하나를 다른 데이터 소스들과 join시키려면, 다이어그램에서 해당 타원 클릭 \(\rightarrow\) 하단 패널에서 \sphinxstylestrong{스키마 관리} 탭 클릭 \(\rightarrow\) \sphinxstylestrong{+ 조인을 위하여 데이터소스를 추가해 주세요} 클릭 순으로 진행합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard.05-1}.png}
\end{figure}
\end{quote}

\item {} 
아래 설명을 참조하여 데이터 join 관계를 설정합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard.06}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{마스터 데이터 소스:} 새로 join시키고자 하는 데이터 소스의 마스터 데이터 소스에 관한 정보를 보여줍니다.

\item {} 
\sphinxstylestrong{Datasource to join:} 마스터 데이터 소스에 조인할 데이터 소스를 선택합니다.

\item {} 
\sphinxstylestrong{조인 키 추가}: '조인 키'는 마스터 데이터 소스와 조인할 데이터 소스 간의 컬럼별 조인 관계를 정의하기 위한 키입니다. 두 데이터 소스에서 서로 연결시킬 컬럼을 하나씩 선택한 후 이 버튼을 클릭하면 새로운 조인 키가 추가됩니다. 이때 각각의 데이터 소스의 컬럼에 정의된 데이터 타입이 일치해야 합니다.

\item {} 
\sphinxstylestrong{조인 타입:} 데이터 소스를 어떻게 조인하여 변형할 것인지를 선택합니다. 다음과 같은 예시를 이용하여 각 조인 타입을 설명하겠습니다.
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{마스터 데이터 소스}\label{\detokenize{discovery/part04/create_a_dashboard:id2}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
제품명(조인 키)
&\sphinxstyletheadfamily 
가격
\\
\hline
A
&
\$22.11
\\
\hline
B
&
\$9.23
\\
\hline
C
&
\$8.99
\\
\hline
D
&
\$10.10
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{조인할 데이터 소스}\label{\detokenize{discovery/part04/create_a_dashboard:id3}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
제품명(조인 키)
&\sphinxstyletheadfamily 
판매량
\\
\hline
B
&
100
\\
\hline
D
&
200
\\
\hline
E
&
50
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{itemize}
\item {} 
\sphinxstylestrong{Inner:} 조인 키 컬럼 내 데이터 값을 기준으로 마스터 데이터 소스와 조인할 데이터 소스에 공통적으로 해당하는 레코드만 결과 테이블에 반영합니다. (두 데이터 소스의 교집합)
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
제품명(조인 키)
&\sphinxstyletheadfamily 
가격
&\sphinxstyletheadfamily 
판매량
\\
\hline
B
&
\$9.23
&
100
\\
\hline
D
&
\$10.10
&
200
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\item {} 
\sphinxstylestrong{Left:} 왼쪽 데이터 소스(마스터 데이터 소스)의 조인 키 컬럼 내 데이터 값을 기준으로 오른쪽 데이터 소스(조인할 데이터 소스)의 데이터를 가져와 조인한 뒤, 결과 테이블에 반영합니다. 오른쪽 데이터 소스의 레코드 중에서 왼쪽 데이터 소스에 없는 조인 키 컬럼 데이터 값을 가진 레코드는 버려집니다.
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
제품명(조인 키)
&\sphinxstyletheadfamily 
가격
&\sphinxstyletheadfamily 
판매량
\\
\hline
A
&
\$22.11
&
null
\\
\hline
B
&
\$9.23
&
100
\\
\hline
C
&
\$8.99
&
null
\\
\hline
D
&
\$10.10
&
200
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\item {} 
\sphinxstylestrong{Right:} 오른쪽 데이터 소스(조인할 데이터 소스)의 조인 키 컬럼 내 데이터 값을 기준으로 왼쪽 데이터 소스(마스터 데이터 소스)의 데이터를 가져와 조인한 뒤, 결과 테이블에 반영합니다. 왼쪽 데이터 소스의 레코드 중에서 오른쪽 데이터 소스에 없는 조인 키 컬럼 데이터 값을 가진 레코드는 버려집니다.
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
제품명(조인 키)
&\sphinxstyletheadfamily 
가격
&\sphinxstyletheadfamily 
판매량
\\
\hline
B
&
\$9.23
&
100
\\
\hline
D
&
\$10.10
&
200
\\
\hline
E
&
\$null
&
50
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\item {} 
\sphinxstylestrong{Full Outer:} 조인 키 컬럼 내 데이터 값을 기준으로 양쪽 데이터 소스의 모든 데이터를 가져와 조인한 뒤, 결과 테이블에 반영합니다. (두 데이터 소스의 합집합)
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
제품명(조인 키)
&\sphinxstyletheadfamily 
가격
&\sphinxstyletheadfamily 
판매량
\\
\hline
A
&
\$22.11
&
null
\\
\hline
B
&
\$9.23
&
100
\\
\hline
C
&
\$8.99
&
null
\\
\hline
D
&
\$10.10
&
200
\\
\hline
E
&
null
&
50
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

\end{itemize}
\end{quote}

\item {} 
\sphinxstylestrong{결과 미리보기:} 데이터 소스를 join한 결과값이 나타납니다.

\end{itemize}
\end{quote}

\item {} 
대시보드를 생성하기 위해 불러온 데이터 소스들에 관한 정보를 확인한 뒤, \sphinxstylestrong{이름}과 \sphinxstylestrong{설명}을 입력하고 \sphinxstylestrong{마침} 버튼을 누르면 새로운 대시보드가 생성됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard.07}.png}
\end{figure}
\end{quote}

\item {} 
새로 생성된 대시보드는 워크북 홈 화면에 추가됩니다. 클릭하면 해당 대시보드에 관한 화면이 표시됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard.08}.png}
\end{figure}
\end{quote}

\end{enumerate}


\subsection{대시보드 크기와 레이아웃 변경하기}
\label{\detokenize{discovery/part04/change_dashboard_layout_and_size:id1}}\label{\detokenize{discovery/part04/change_dashboard_layout_and_size::doc}}
대시보드 기본 화면에서 \sphinxstylestrong{대시보드 편집} 버튼을 클릭하면 해당 대시보드의 구성을 편집할 수 있는 화면으로 이동합니다. 여기서는 위젯 추가 기능을 포함하여 대시보드의 편집 및 계층 구조 설정, 레이아웃 변경 기능을 사용할 수 있습니다.


\subsubsection{대시보드 위젯 배열 설정}
\label{\detokenize{discovery/part04/change_dashboard_layout_and_size:id2}}\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard.12}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{위젯 위치 변경:} 위젯 제목 부분을 드래그하여 위젯의 위치를 변경할 수 있습니다.

\item {} 
\sphinxstylestrong{위젯 너비 조정:} 위젯과 위젯의 사이를 움직여 위젯의 너비를 조정할 수 있습니다.

\item {} 
\sphinxstylestrong{화면에 위젯 추가:} 우측 패널에 있는 위젯 목록에서 원하는 위젯을 좌측 위젯 레이아웃 영역으로 드래그하면 해당 위젯이 레이아웃 영역에 추가됩니다.

\item {} 
\sphinxstylestrong{화면에서 위젯 삭제:} 위젯 레이아웃 영역에 표시된 각 위젯에서 X 버튼을 클릭하면 해당 위젯이 레이아웃 영역에서 제거됩니다.

\end{enumerate}
\end{quote}


\subsubsection{차트 위젯 패널}
\label{\detokenize{discovery/part04/change_dashboard_layout_and_size:id3}}
차트 위젯 패널에서는 대시보드 내 차트의 추가, 수정, 삭제 등이 가능합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard.13}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{차트 위젯 수:} 현재 대시보드에 등록된 차트 위젯의 개수를 나타냅니다.

\item {} 
\sphinxstylestrong{차트 위젯 추가:} 대시보드 내에 새로운 차트 위젯을 생성할 수 있습니다.

\item {} 
\sphinxstylestrong{차트 위젯 목록:} 현재 대시보드에 등록된 차트 위젯들이 열거됩니다. 수정 또는 삭제를 원하는 위젯 항목에 마우스를 오버하면 이를 위한 아이콘이 나타납니다. 또한 위젯 항목을 위젯 레이아웃 영역으로 드래그하면 해당 위젯이 레이아웃 영역에 표시됩니다.

\item {} 
\sphinxstylestrong{차트 계층 구조 설정:} 대시보드 내 차트 간 상하 관계를 설정할 수 있습니다. 부모 차트에서 데이터 항목을 하나 선택하면 자식 차트가 그 항목을 기준으로 필터링됩니다. 계층 구조를 설정하려면 하위 관계로 설정할 차트를 드래그하여 원하는 상위 관계 차트 밑으로 옮기면 됩니다. 차트 계층 구조 설정이 완료되면 차트 메뉴 상에서도 구조가 변경된 것을 확인할 수 있습니다.

\end{enumerate}
\end{quote}


\subsubsection{텍스트 위젯 패널}
\label{\detokenize{discovery/part04/change_dashboard_layout_and_size:id4}}
텍스트 위젯 패널에서는 대시보드 내 텍스트 위젯의 추가, 수정, 삭제 등이 가능합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{dashboard-textwidget}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{텍스트 위젯 수:} 현재 대시보드에 등록된 텍스트 위젯의 개수를 나타냅니다.

\item {} 
\sphinxstylestrong{텍스트 위젯 추가:} 대시보드 내에 새로운 텍스트 위젯을 생성할 수 있습니다.

\item {} 
\sphinxstylestrong{텍스트 위젯 목록:} 현재 대시보드에 등록된 텍스트 위젯들이 열거됩니다. 수정 또는 삭제를 원하는 위젯 항목에 마우스를 오버하면 이를 위한 아이콘이 나타납니다. 또한 위젯 항목을 위젯 레이아웃 영역으로 드래그하면 해당 위젯이 레이아웃 영역에 표시됩니다.

\end{enumerate}
\end{quote}


\subsubsection{레이아웃 패널}
\label{\detokenize{discovery/part04/change_dashboard_layout_and_size:id5}}
레이아웃 패널에서는 위젯 레이아웃 영역에서 위젯의 배열과 개별 위젯 표시 방법에 관하여 몇 가지 설정을 설정합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[scale=0.5]{{dashboard.15}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{보드 높이 설정}
\begin{itemize}
\item {} 
\sphinxstylestrong{너비 고정:} 보드의 높이를 화면에 맞춥니다.

\item {} 
\sphinxstylestrong{높이 고정:} 보드의 높이를 고유한 픽셀 값으로 설정합니다.

\item {} 
\sphinxstylestrong{위젯 사이 간격:} 위젯 레이아웃 영역에 표시되는 위젯 간의 간격을 지정합니다.

\end{itemize}

\item {} 
\sphinxstylestrong{차트 제목:} 위젯 레이아웃 영역 내 차트 및 필터 위젯들의 제목 표시 여부를 일괄 설정합니다.

\item {} 
\sphinxstylestrong{범례:} 위젯 레이아웃 영역 내 차트 위젯들의 범례 표시 여부를 일괄 설정합니다.

\item {} 
\sphinxstylestrong{미니맵:} 위젯 레이아웃 영역 내 차트 위젯들의 미니맵 표시 여부를 일괄 설정합니다.

\end{itemize}
\end{quote}


\subsubsection{데이터 소스 패널}
\label{\detokenize{discovery/part04/change_dashboard_layout_and_size:id6}}
데이터 소스 패널에서는 연동된 데이터 소스의 정보를 열람·수정하고, 컬럼 필터를 간편하게 추가할 수 있습니다. 각 차원값 또는 측정값 우측의 필터 아이콘을 눌러서 필터를 추가해 보십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard-datasource-panel}.png}
\end{figure}
\end{quote}

단, 여기서 지정/해제하는 필터는 대시보드 전체에 적용되는 글로벌 필터이고, 차트 에디터에서 지정/해제하는 필터는 차트 내 필터임을 유의하십시오.


\subsection{대시보드 내에 데이터 소스 확인하기}
\label{\detokenize{discovery/part04/display_a_data_source:id1}}\label{\detokenize{discovery/part04/display_a_data_source::doc}}
대시보드 기본 화면에서 \sphinxincludegraphics{{dashboard.icon_db_info}.png} 버튼을 클릭하면 해당 대시보드에서 사용하는 데이터 소스들의 정보 를 보여주는 대화 상자가 나타납니다. 좌측 상단에서 확인하고자 하는 데이터 소스를 선택할 수 있 습니다. 이 대화 상자는 크게 3가지 탭(데이터 그리드, 컬럼 상세 탭, 대시보드 데이터 정보)으로 구 성됩니다.


\subsubsection{데이터 그리드 탭}
\label{\detokenize{discovery/part04/display_a_data_source:id2}}
해당 데이터 소스의 레코드 값이 모두 표시됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard.09}.png}
\end{figure}
\end{quote}


\subsubsection{컬럼 상세 탭}
\label{\detokenize{discovery/part04/display_a_data_source:id3}}
해당 데이터 소스를 구성하는 각 컬럼에 관한 정보를 상세히 보여줍니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dashboard.10}.png}
\end{figure}
\end{quote}


\subsubsection{대시보드 데이터 정보 탭}
\label{\detokenize{discovery/part04/display_a_data_source:id4}}
해당 데이터 소스 전체에 대한 요약 정보를 보여줍니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[scale=0.3]{{dashboard.11}.png}
\end{figure}
\end{quote}


\subsection{대시보드 프리젠테이션 하기}
\label{\detokenize{discovery/part04/present_the_dashboard:id1}}\label{\detokenize{discovery/part04/present_the_dashboard::doc}}
대시보드 기본 화면에서 \sphinxstylestrong{프레젠테이션 뷰} 버튼을 클릭하면 워크북의 대시보드들을 프레젠테이션에 적합한 UI로 열람할 수 있습니다. 이를 통해 사용자는 데이터 분석 결과를 쉽게 보고하고 공유할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{presentation_view_2}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{이름:} 현재 표시 중인 대시보드의 이름입니다.

\item {} 
\sphinxstylestrong{슬라이드 네비게이션:} 각 동그라미는 워크북 내 대시보드 각각을 가리킵니다. 예를 들어 네 번째 동그라미를 클릭하면 네 번째 대시보드 슬라이드로 이동하고 해당 동그라미가 강조됩니다.

\item {} 
\sphinxstylestrong{자동 슬라이드 쇼 설정:} 시간 간격 선택 후 PLAY 버튼을 클릭하면, 자동 슬라이드 쇼가 시작되어 선택한 시간 간격을 주기로 슬라이드가 넘어갑니다.

\item {} 
\sphinxstylestrong{나가기:} 프레젠테이션 뷰를 종료하고 워크북/대시보드 기본 화면으로 돌아갑니다.

\end{enumerate}
\end{quote}


\subsection{컬럼에 새로운 이름 부여하기}
\label{\detokenize{discovery/part04/give_new_column_name(alias):id1}}\label{\detokenize{discovery/part04/give_new_column_name(alias)::doc}}
대시보드 편집모드의 데이터 소스 패널에서 컬럼명에 마우스를 올린 후, 우측의 항목을 클릭하면 해당 컬럼의 Alias 값을 확인할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{give_new_column_name_1}.png}
\end{figure}
\end{quote}

Alias 항목에 마우스를 올리면 새로운 컬럼명을 입력할 수 있는 창이 열리며, 입력 후 \sphinxstylestrong{적용}을 누르면 반영된 것을 확인할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{give_new_column_name_2}.png}
\end{figure}
\end{quote}


\section{차트}
\label{\detokenize{discovery/part04/manage_charts:id1}}\label{\detokenize{discovery/part04/manage_charts::doc}}
기본적으로 워크북 내 각 대시보드는 분석한 데이터를 시각화하여 보여주는 다양한 차트로 구성됩니다. 데이터 분석 목적에 맞게 차트를 만들기 위해 필수적으로 알아야할 몇 가지 개념과 Discovery의 차트 구성 UI에 대해 설명합니다.

차트 홈 화면은 다음과 같이 세 영역으로 구분됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{part04-chart01}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{컬럼/차트 선택 영역:} 차트를 만들기 위해 필수적으로 행해야 하는 액션의 순서대로 UI가 구성되어 있습니다. Data(데이터 컬럼 리스트)선택을 통해 차트를 피봇팅할 수 있으며, Chart(차트 종류 리스트)를 선택하여 데이터를 시각화할 수 있습니다. 또한 Analytics(분석)을 통해 원하는 분석 조건을 차트에 탑재할 수 있습니다.

\item {} 
\sphinxstylestrong{시각화 영역:} 피봇팅할 수 있는 선반영역과 실제 차트가 그려지는 시각화 영역으로 구성됩니다. 컬럼/차트 선택 영역에서 차트를 그릴 수 있는 데이터와 차트가 선택되면 이 곳에서 차트가 나타납니다.

\item {} 
\sphinxstylestrong{옵션 영역:} 차트를 보기 좋게 꾸미고, 차트가 보여지는 방식을 사용자의 기호에 맞게 선택할 수 있습니다. 옵션 영역은 필터, 파레트, 축, 숫자표현, 차트표현으로 이루어져 있습니다.

\end{enumerate}
\end{quote}

아래 각 절에서는 이러한 사용자 인터페이스를 이용하여 각종 차트를 만들고 관리하는 방식을 소개합니다.


\subsection{데이터 컬럼 리스트}
\label{\detokenize{discovery/part04/composition_of_the_data_column_list:id1}}\label{\detokenize{discovery/part04/composition_of_the_data_column_list::doc}}
데이터 컬럼 리스트에 나열되는 컬럼들은 '차원값' 컬럼과 '측정값' 컬럼으로 분류됩니다. 차원값과 측정값의 개념에 대한 자세한 설명은 {\hyperref[\detokenize{discovery/part02/dimension_and_measures::doc}]{\sphinxcrossref{\DUrole{doc}{'차원값'과 '측정값'의 개념}}}} 항목을 참조하십시오.


\subsubsection{데이터 컬럼 리스트 구성}
\label{\detokenize{discovery/part04/composition_of_the_data_column_list:id2}}
데이터 컬럼 리스트에서는 연동된 데이터 소스들의 정보를 열람·수정하고, 컬럼 필터를 간편하게 추가하거나 제거할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{part04-chart02}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{데이터 소스 선택/설정:} 데이터 소스를 선택하거나 해당 데이터 소스의 연결/join 관계를 설정합니다.

\item {} 
\sphinxstylestrong{데이터 상세:} 클릭하면 새 대화 상자를 통해 선택된 데이터 소스에 관한 정보를 보여줍니다

\item {} 
\sphinxstylestrong{컬럼 이름으로 검색:} 데이터 소스 내 컬럼을 이름으로 검색합니다.

\item {} 
\sphinxstylestrong{사용자 컬럼 추가:} 클릭하면 데이터 소스에 있는 컬럼들을 조합·가공하여 새로운 컬럼을 만들 수 있는 대화 상자가 열립니다. 추가된 사용자 컬럼은 대시보드 전체에서 사용할 수 있습니다.

\item {} 
\sphinxstylestrong{필터 지정/해제:} 이 버튼은 해당 컬럼에 마우스를 오버하면 생기며, 클릭 시 해당 컬럼을 차트 필터로 지정하고 다시 한번 클릭하면 지정된 차트 필터가 해제됩니다. 필터로 지정된 컬럼 항목에는 \sphinxincludegraphics{{chart_icon_more}.png} 아이콘이 마우스 오버와 상관 없이 표시됩니다.

\item {} 
\sphinxstylestrong{더 보기:} 이 버튼은 해당 컬럼에 마우스를 오버하면 생기며, 컬럼에 대한 추가적인 정보를 확인하고 별칭을 지정할 수 있습니다.
\begin{itemize}
\item {} 
\sphinxincludegraphics{{chart_icon_info}.png} : 클릭하면 새 대화 상자가 나타나면서 해당 컬럼의 요약 정보와 데이터 값들을 보여줍니다.

\item {} 
\sphinxstylestrong{논리 컬럼 이름:} 해당 컬럼의 논리적 컬럼명을 보여줍니다.

\item {} 
\sphinxstylestrong{타입:} 해당 컬럼의 논리적 데이터 타입을 보여줍니다.

\item {} 
\sphinxstylestrong{Alias:} 해당 컬럼에 대한 별칭을 지정할 수 있습니다. 정식 컬럼명은 영숫자와 몇 가지 특수문자로 제한되며 공백도 포함할 수 없기 때문에 보다 구분하기 편한 별칭을 등록하면 분석 시 편의를 도모할 수 있습니다. 지정된 별칭은 대시보드 전체에 적용됩니다.

\item {} 
\sphinxstylestrong{값 별칭:} 해당컬럼에포함된각데이터값에대해서도별칭을지정할수있습니다. 지정된 별칭은 대시보드 전체에 적용됩니다.

\end{itemize}

\end{enumerate}
\end{quote}


\subsubsection{사용자 컬럼 추가}
\label{\detokenize{discovery/part04/composition_of_the_data_column_list:id3}}
데이터 소스 컬럼 리스트에서 + 버튼을 클릭하면 사용자 컬럼 추가를 위한 대화 상자가 열립니다. 여기서는 데이터 소스에 있는 기존 컬럼들에 각종 공식을 적용하여 차트를 만드는 데 필요한 새로운 컬럼을 만들 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{part04-chart03}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{컬럼 이름:} 사용자 컬럼의 이름을 적는 란입니다.

\item {} 
\sphinxstylestrong{코드 영역:} 사용자 컬럼을 만들기 위한 코드를 적는 란입니다. 아래의 컬럼 및 공식 목록에서 원하는 목록을 클릭하면 이 영역에 자동으로 타이핑 됩니다.

\item {} 
\sphinxstylestrong{컬럼 추가:} 데이터 소스에 주어진 기존 컬럼 목록입니다. 목록에 제시된 컬럼 항목 중 하나를 클릭하면 해당 컬럼이 코드 영역에 자동으로 타이핑됩니다.

\item {} 
\sphinxstylestrong{공식 추가:} Metatron에서 지원하는 공식 목록입니다. 목록에 제시된 공식 중 하나를 클릭하면 해당 공식이 코드 영역에 자동으로 타아핑되고 타이핑 커서가 파라미터를 입력하는 부분으로 자동 이동됩니다. 각 공식의 용도와 사용법, 예제에 관해서는 화면 우측의 도움말 상자를 참조하세요.

\end{enumerate}
\end{quote}


\subsection{차트 그리기(pivoting)}
\label{\detokenize{discovery/part04/pivoting:pivoting}}\label{\detokenize{discovery/part04/pivoting::doc}}

\subsubsection{'Pivoting'이란}
\label{\detokenize{discovery/part04/pivoting:id1}}
Pivoting이란 주어진 테이블을 특정 컬럼들을 기준으로 그룹화하는 과정을 의미하며, 이를 통해 분석가는 원천 데이터의 특정한 측면을 그래픽 또는 도표로 확인할 수 있습니다.
이러한 과정에는 의미 있는 데이터를 포함하는 컬럼들을 열/행/교차 선반에 배치하는 것을 포함합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{pivoting.01}.png}
\end{figure}
\end{quote}

위 그림은 두 개의 차원값 컬럼을 열선반에 배치하고 하나의 측정값 컬럼을 교차선반에 배치 한 상태를 보여주고 있습니다.
차트에는 이렇게 선반에 올려놓은 컬럼들의 데이터가 표시됩니다.

차트 유형별로 선반별 필수/권장 컬럼 유형이 다르며, 컬럼들을 선반에 올려놓기 전에 먼저 차트 유형을 선택하면 선반에 필요한 컬럼 유형이 제시됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{pivoting.02}.png}
\end{figure}
\end{quote}


\subsubsection{열/행/교차 선반의 개념}
\label{\detokenize{discovery/part04/pivoting:id2}}
열/행/교차 선반의 개념은 Excel의 구조를 생각하면 쉽게 이해할 수 있습니다. 아래 그림과 같이 열/행은 블록을 정의하는 역할을 하고, 교차는 블록 안에 들어갈 값을 정하는 역할을 합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{pivoting.03}.png}
\end{figure}
\end{quote}

Excel에서 데이터를 열/행/교차를 2차원 값인 그리드에 표현한 다면, Metatron은 OLAP Data Discovery 도구로서, OLAP Cube를 통해 다차원에서 데이터를 조회합니다.
아래의 차트는 Metatron에서 3차원 큐브로 나타낸 열/행/교차 값의 축 그림 입니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{pivoting.04}.png}
\end{figure}
\end{quote}

Excel 그리드의 값을 3차원 차트에서 표현한다면 그리드의 교차값이 막대바 형태로 여러 개 세워 지게 될 수 있습니다. Metatron에서는 2차원 단면으로 차트가 보여지기 때문에 열과 행 기준으로 막대 바를 쌓아 올려서 표현하게 됩니다.
결국 아래 그 림의 회색 부분과 같은 2차원 형태의 차트로 나타납니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{pivoting.05}.png}
\end{figure}
\end{quote}


\subsection{차트 유형 선택}
\label{\detokenize{discovery/part04/chart_types:id1}}\label{\detokenize{discovery/part04/chart_types::doc}}


Metatron Discovery는 20여 가지의 차트를 제공하고 있습니다. 차트를 선택하기 전에 먼저 컬럼들을 선반에 올려놓으면 그에 어울리는 차트들이 보라색으로 강조됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{Chart_Types.00}.png}
\end{figure}
\end{quote}

아래 표는 각 차트별 생성조건과 사용 속성, 사용 유형, 사용 예시에 대해 정리한 것입니다.
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{20}{135}|\X{25}{135}|\X{25}{135}|\X{40}{135}|\X{25}{135}|}
\hline
\sphinxstyletheadfamily 
차트명/아이콘
&\sphinxstyletheadfamily 
생성 조건
&\sphinxstyletheadfamily 
사용 속성
&\sphinxstyletheadfamily 
사용 유형
&\sphinxstyletheadfamily 
사용 예시
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon01}.png}

막대형 차트
&
열: 차원값 1개 이상 \& 교차: 측정값 1개 이상
&
개별 항목의 값 비교
&
그룹들을 비교할 때 사용하거나 시간에 따른 변화 추이를 보고 싶을 때 사용합니다. 변화 추이가 클 때 사용하면 효과적입니다.
&
제품별 매출 및 수익 비교
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon02}.png}

표
&
열 또는 행: 차원값 1개 이상 \& 교차: 측정값 1개 이상
&
항목별 교차 데이터를 텍스트로 표시
&
특정 기준에 따른 측정 값을 보고싶을 때 사용합니다. 시각화보다는 자세한 데이터와 정확한 값을 보려는 경우에 사용합니다.
&
연도별 매출 상세
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon03}.png}

선형 차트
&
열: 차원값 1개 이상 \& 교차: 측정값 1개 이상
&
시간의 흐름에 따른 데이터 변화
&
시간에 따른 변화 추이를 보고 싶을 때 사용합니다. 변화 추이가 작을 때는 막대형 차트보다 선형 차트를 사용하는 것이 효과적입니다.
&
월별 매출 추이
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon04}.png}

분산형 차트
&
열: 측정값 1개 \& 행: 측정값 1개 \& 교차: 차원값 1개 이상
&
관련된 여러 항목의 연관관계 표시
&
두 변수 간의 관계를 정의하고 싶을 때 사용합니다.
&
제품의 매출과 수익의 관계
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon05}.png}

히트맵
&
열 또는 행: 차원값 1개 이상 \& 교차: 측정값 1개 이상
&
항목별 교차 데이터를 색상 분포 형태로 표시
&
색과 크기를 이용해 두 변수를 직관적으로 비교할 때 사용합니다. 표 차트에서 시각적 요소를 강조하기 위해 사용합니다.
&
지역별 각 제품 판매량
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon06}.png}

원형 차트
&
교차: 차원값 1개 이상, 측정값 1개 이상
&
전체 대비 각 항목이 차지하는 비율
&
전체를 이루는 부분들을 비교할 때 사용합니다.
&
웹 브라우저의 마켓 쉐어 비교
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon07}.png}

맵뷰
&
레이어 선반 : 차원값(위치속성), 차원값 1개이상 , 측정값 1개이상
&
지도 상 각 위치 값에 해당하는 데이터를 표시
&
지역별 색을 이용한 변수의 직관적 비교에 사용. 시각적 요소를 강조하기 위해 사용
&
지역별 각 제품 판매량 비교
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon08}.png}

핵심지표
&
교차: 측정값 1개 이상
&
주요 지표를 추세와 함께 표시
&
조직의 현재 성과에 대한 정보를 빠르게 전달하기 위해 사용합니다.
&
올 해 이입된 고객 수 혹은 조직의 성과 지표
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon09}.png}

박스플롯
&
열: 차원값1개 이상, 행: 차원값1개, 교차: 측정값 1개
&
값의 상승과 하락을 표시
&
각 그룹들의 분포를 비교할 때 사용하거나 특정 값의 목표치를 나타낼 때 사용합니다.
&
비행기 기종 별 지연 시간 분포 비교
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon10}.png}

폭포 차트
&
열: 시간속성의 차원값 1개 \& 교차: 측정값 1개
&
값을 더하거나 뺄 때의 누계를 표시
&
시간에 따른 값의 증가와 감소를 강조할 때 사용합니다.
&
일정 기간 동안 조직의 팀원 수 변화 관찰 혹은 주식
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon11}.png}

워드클라우드
&
교차: 차원값 1개 이상, 측정값 1개
&
출현 빈도에 비례한 크기로 텍스트를 표시
&
중요한 단어들을 강조해서 요약하고 싶을 때 사용합니다.
&
고객들의 코멘트 요약
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon12}.png}

결합 차트
&
열: 차원값 1개 이상 \& 교차: 측정값 2개 이상, 4개 이하
&
막대와 라인 차트를 결합하여 데이터를 비교
&
서로 다른 종류의 정보를 강조하기 위해 사용합니다.
&
제품별 가격과 판매량을 동시 관찰
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon13}.png}

트리맵
&
열: 차원값 1개 \& 행: 차원값 1개 이상 \& 교차: 측정값 1개
&
계층 데이터를 중첩된 사각형 집합으로 표시
&
계층 구조를 갖는 데이터를 시각화하기 위해 사용합니다.
&
제품별(대분류-중분류-소분류) 매출 관찰
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon14}.png}

레이더 차트
&
교차: 차원값 1개, 측정값 1개 이상
&
중심점을 기준으로 다양한 평가요소를 표시
&
여러 측정 목표를 직관적으로 비교할 때 사용합니다.
&
품질을 5요인으로 나누어 평가한 제품들 비교
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon15}.png}

네트워크 다이어그램
&
주체 선반: 차원값 1개 \& 대상 선반: 차원값 1개 \& 연결 선반: 측정값 1개
&
의존관계가 있는 요소들을 표현하는 연결 다이어그램
&
데이터의 발생 순서 흐름을 보고 싶을 때 사용합니다.
&
프로젝트 태스크 흐름을 관찰
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon16}.png}

측정 차트
&
열: 행: 차원값 1개 이상 \& 교차: 측정값 1개
&
설정된 목표에 대한 성능을 시각화하여 표시
&
데이터가 어떤 비율로 구성되어 있는지 보고 싶을 때 사용합니다.
&
지역별 수익 관찰
\\
\hline
\sphinxincludegraphics{{Chart_Types_Icon17}.png}

생키 다이어그램
&
열: 차원값 3개 이상 \& 교차: 측정값 1개
&
연결선의 너비로 흐름의 양을 비율적으로 표시
&
데이터의 양적인 흐름을 관찰할 때 사용합니다.
&
공장의 에너지 흐름 관찰
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}
\end{quote}


\subsection{차트 스타일 속성}
\label{\detokenize{discovery/part04/chart_style:id1}}\label{\detokenize{discovery/part04/chart_style::doc}}
데이터를 피봇팅하고 나면 우측에 차트 스타일을 설정할 수 있는 옵션 메뉴가 나타납니다. 메뉴의 구성은 각 차트의 종류별로 다르게 나타납니다.
모든 차트 유형에 일반적으로 적용되는 설정 항목을 설명하고, 차트 유형별로 고유한 '공통 설정' 유형에 대해서 설명합니다.


\subsubsection{차트 스타일 설정 메뉴}
\label{\detokenize{discovery/part04/chart_style:id2}}
차트 스타일 설정 메뉴를 구성하는 각 항목별로 설정 방식을 설명합니다. 사용하는 차트 유형에 따라 아래 제시된 항목 중 일부가 사용되지 않을 수 있음을 유의하십시오.

\sphinxstylestrong{색상 설정}

차트에 들어가는 각종 색상을 정의합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[scale=0.9]{{Chart_Style.01}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{그래프 색상 설정:} 그래프에서 데이터 표시 항목별 색상을 구분하는 기준을 정한 후 색상 테마를 선택합니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{Series:} 측정값의 종류에 따라 색상을 구분합니다.

\item {} 
\sphinxstylestrong{Dimension:} 차원값의 종류에 따라 색상을 구분합니다.

\item {} 
\sphinxstylestrong{Measure:} 측정값의 크기에 따라 색상을 구분합니다.

\end{itemize}

\item {} 
\sphinxstylestrong{색상범위 설정:} 데이터 표시 색상 구분 기준을 \sphinxstylestrong{Measure}로 선택할 때 나오는 항목으로서, ON으로 설정하면 측정값의 범위에 따라 색상을 다르게 나타낼 수 있습니다. 색상범위는 최저 구간부터 시작해서 원하는 개수만큼 세분화할 수 있는데, 새로운 구간을 추가하려면 현재의 마지막 구간의 최댓값을 먼저 조정한 다음 \sphinxstylestrong{새 범위 추가} 버튼을 클릭해야 합니다.

\end{enumerate}
\end{quote}

\sphinxstylestrong{숫자 포멧}

차트 내 그래프에 텍스트로 나타나는 데이터값 의 표시 형식을 정의합니다. 이 기능을 사용하려면 데이터 레이블 설정 메뉴에서 레이블 표시 기능을 먼저 켜주십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[scale=0.4]{{Chart_Style.02}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{표시 형식:} 데이터 값을 숫자, 통화, 퍼센트, 지수 중 어떤 형식으로 표시할지 선택합니다.

\item {} 
\sphinxstylestrong{소수점 자리 설정:} 데이터 값을 소수점 몇 번째 자리까지 표시할지 결정합니다.

\item {} 
\sphinxstylestrong{수치표시 약어 설정:} 데이터 값의 자릿수가 클 경우 천 단위(K), 백만 단위(M), 십억 단위(B) 중 하나를 약어로 설정할 수 있습니다. \sphinxstylestrong{자동 조정}을 선택하면, 데이터 값들의 자릿수에 가장 적절한 단위가 자동으로 결정됩니다.

\item {} 
\sphinxstylestrong{천단위 구분자 사용:} 데이터 값들을 천단위 구분자를 사용하여 표시할 것인지 선택합니다.

\item {} 
\sphinxstylestrong{사용자 기호 설정:} 데이터 값들의 앞/뒤에 사용자가 원하는 텍스트를 삽입하여 표시할 수 있습니다.

\item {} 
\sphinxstylestrong{미리 보기:} 정의한 숫자 형식에 따른 결과를 예시로 보여줍니다.

\end{enumerate}
\end{quote}

\sphinxstylestrong{Y축 설정(차트 유형 세로형 기준)}

공통 설정 항목에서 차트 유형을 \sphinxstylestrong{가로형}으로 바꾸면 X축과 Y축 설정 항목이 뒤바뀝니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[scale=0.4]{{Chart_Style.03}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{축 제목 입력:} 차트의 Y축에 제목을 입력할 수 있습니다. 해당 기능을 사용하지 않으면 Y축에 제목이 나타나지 않게 됩니다.

\item {} 
\sphinxstylestrong{레이블 표시:} 차트의 Y축에 데이터 레이블을 표시할 것인지 선택합니다. 해당 기능을 사용하지 않으면 Y축에 데이터 레이블은 나타나지 않게 됩니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{레이블 설정:} Y축 데이터 레이블에 표시되는 숫자의 형식을 지정합니다. 자동으로 설정하면 \sphinxstylestrong{숫자 포멧} 항목의 설정값이 동일하게 반영되며, 수동으로 설정하면 Y축 데이터 레이블만의 고유한 형식을 지정할 수 있습니다.

\end{itemize}

\end{enumerate}
\end{quote}

\sphinxstylestrong{X축 설정(차트 유형 세로형 기준)}

여기서는 차트의 X축 표시 방식을 정의합니다. 공통 설정 항목에서 차트 유형을 \sphinxstylestrong{가로형}으로 바꾸면 X축과 Y축 설정 항목이 뒤바뀝니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[scale=0.4]{{Chart_Style.04}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{축 제목 입력:} 차트의 X축에 제목을 입력할 수 있습니다. 해당 기능을 사용하지 않으면 X축에 제목이 나타나지 않게 됩니다.

\item {} 
\sphinxstylestrong{레이블 표시:} 차트의 X축에 데이터 레이블을 표시할 것인지 선택합니다. 해당 기능을 사용하지 않으면 X축에 데이터 레이블은 나타나지 않게 됩니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{레이블 회전:} 차트의 X축에 나타나는 데이터 레이블을 0도/45도/90도 중 어떤 각도로 표시할 것인지 선택합니다.

\end{itemize}

\end{enumerate}
\end{quote}

\sphinxstylestrong{데이터 레이블 설정}

차트 내 그래프에 데이터 값을 표시할 것인지 여부를 선택합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[scale=0.4]{{Chart_Style.05}.png}
\end{figure}
\end{quote}


\subsubsection{차트 유형별 공통 설정 항목}
\label{\detokenize{discovery/part04/chart_style:id3}}
가장 보편적으로 사용되는 상위 6개 차트(막대형 차트, 표, 선형 차트, 분산형 차트, 히 트맵, 원형 차트)의 스타일 설정 방법에 대해 설명합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[scale=0.4]{{Chart_Style.12}.png}
\end{figure}
\end{quote}

\sphinxstylestrong{막대형 차트}

차원값 컬럼을 구성하는 각 범주 항목에 속한 데이터 값이 막대 모양으로 표시됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{Chart_Style.06}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{차트 유형}
\begin{itemize}
\item {} 
\sphinxstylestrong{세로형:} 차원값 축이 세로를 기준으로 하여 데이터 값 막대가 세로로 나타납니다.

\item {} 
\sphinxstylestrong{가로형:} 차원값 축이 가로를 기준으로 하여 데이터 값 막대가 가로로 나타납니다.

\item {} 
\sphinxstylestrong{병렬형:} 측정값을 2개 이상 선택했을 때 측정값별로 각각 다른 막대로 병렬하여 나타냅니다.

\item {} 
\sphinxstylestrong{중첩형:} 측정값을 2개 이상 선택했을 때 모든 측정값을 한 막대에 중첩시켜 나타냅니다.

\end{itemize}

\item {} 
\sphinxstylestrong{Limitation:} 차트에 나타나는 컬럼의 개수를 결정합니다.

\end{enumerate}
\end{quote}

\sphinxstylestrong{표}

열/행 선반에 올려놓은 차원값 컬럼들의 범주 항목을 토대로 표 블록이 형성되며 그에 상응하는 측정값이 교차 영역에 텍스트로 표시됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{Chart_Style.07}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{차트 유형}
\begin{itemize}
\item {} 
\sphinxstylestrong{피봇 데이터:} 분류 기준이 되는 차원값 범주가 동일한 측정값끼리는 한 셀에 집계(\sphinxcode{\sphinxupquote{SUM}}, \sphinxcode{\sphinxupquote{MIN}}, \sphinxcode{\sphinxupquote{MAX}} 등)되는 방식으로 보여집니다.

\item {} 
\sphinxstylestrong{원본 데이터:} 원본 측정값이 집계되지 않은 채로 특정한 차원값 컬럼을 기준으로 전부 출력됩니다.

\item {} 
\sphinxstylestrong{세로보기:} 측정값의 데이터를 표에서 세로로 표시합니다. 원본 데이터 유형으로 표를 나타낼 때는 사용할 수 없습니다.

\item {} 
\sphinxstylestrong{가로보기:} 피봇데이터 유형으로 표를 나타낼 경우 표를 가로보기 할 수 있습니다. 측정값의 데이터를 표에서 가로로 표시합니다.

\end{itemize}

\item {} 
\sphinxstylestrong{Show Head Colum:} 헤드 칼럼에 표시되는 텍스트 정렬 방식을 가로와 세로 별로 설정할 수 있습니다. 원본 데이터로 표시할 경우에는 헤드 칼럼은 필수로 표시됩니다. 피봇 데이터 유형일 경우에 헤드 칼럼을 사용하지 않을 수 있습니다.

\end{enumerate}
\end{quote}

\sphinxstylestrong{선형 차트}

차원값 컬럼을 구성하는 각 범주 항목에 속한 데이터 값이 점 모양으로 표시됩니다. 인접하는 범주 항목의 점끼리는 서로 연결되어 변화 추이를 확인할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{Chart_Style.08}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{차트 유형}
\begin{itemize}
\item {} 
\sphinxstylestrong{선형:} 측정값을 기준점으로 선을 이어서 차트를 나타냅니다.

\item {} 
\sphinxstylestrong{면적형:} 선으로 이어진 면적에 색상을 입혀 차트를 나타냅니다.

\item {} 
\sphinxstylestrong{라인\&포인트:} 측정값을 기준점으로 한 점과 그 점을 연결한 선을 함께 나타냅니다.

\item {} 
\sphinxstylestrong{포인트:} 포인트는 측정값을 기준으로 한 점만 나타냅니다.

\item {} 
\sphinxstylestrong{라인:} 선의 연결만을 나타냅니다.

\item {} 
\sphinxstylestrong{기본형:} 측정값을 그대로 차트에 나타냅니다.

\item {} 
\sphinxstylestrong{누적형:} 측정값을 누적한 값을 차트에 나타냅니다.

\end{itemize}

\end{enumerate}
\end{quote}

\sphinxstylestrong{분산형 차트}

차원값 컬럼을 구성하는 각 범주 항목에 속한 데이터 값이 정의된 기호 모양으로 표시됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{Chart_Style.09}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{기호 유형:} 차트에 표시되는 기호의 모양을 설정합니다.

\item {} 
\sphinxstylestrong{기호 투명도:} 차트에 표시되는 기호의 투명도를 설정합니다. 단색/반투명 중 선택하여 나타낼 수 있습니다.

\end{enumerate}
\end{quote}

\sphinxstylestrong{히트맵}

교차선반에 올려진 측정값 컬럼의 각 데이터 값이 색상으로 표시됩니다. 데이터 값이 클수록 색상 농도가 짙어집니다. 히트맵의 공통 설정 항목에는 설정할 사항이 없습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{Chart_Style.10}.png}
\end{figure}
\end{quote}

\sphinxstylestrong{원형 차트}

차원값 컬럼의 각 범주 항목별로 차지하는 비중을 시각화하는 차트입니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{Chart_Style.11}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{차트 유형}
\begin{itemize}
\item {} 
\sphinxstylestrong{부채꼴형:} 차트가 원형으로 나타납니다.

\item {} 
\sphinxstylestrong{도넛형:} 차트가 도넛형으로 나타납니다.

\end{itemize}

\end{enumerate}
\end{quote}


\subsection{맵뷰와 공간 연산}
\label{\detokenize{discovery/part04/map_chart:id1}}\label{\detokenize{discovery/part04/map_chart::doc}}
메타트론 디스커버리는 3.1.0 버전부터 위치 데이터를 시각화할 수 있는 \sphinxstylestrong{맵뷰} 기능을 제공하고 있습니다. 맵뷰는 기존 차트 유형들과는 다른 차트 생성 조건을 갖고 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{mapview_main}.jpg}
\end{figure}
\end{quote}
\begin{itemize}
\item {} 
\sphinxstylestrong{위치 속성} 의 차원값이 1개 이상 필요합니다.

\item {} 
열/행/교차 선반이 아닌 \sphinxstylestrong{맵 레이어 선반} 에 데이터를 배치합니다.

\item {} 
\sphinxstylestrong{레이어 별 스타일 속성} 을 지정합니다.

\item {} 
\sphinxstylestrong{공간 연산} 이 가능합니다.

\end{itemize}


\subsubsection{위치 속성의 차원값}
\label{\detokenize{discovery/part04/map_chart:id2}}
맵뷰를 사용하기 위해서는 \sphinxcode{\sphinxupquote{Point}}, \sphinxcode{\sphinxupquote{LineString}}, \sphinxcode{\sphinxupquote{Polygon}} 과 같은 WKT Geometry 형식의 데이터로 이루어진 차원값(dimension) 칼럼을 레이어 선반에 올려야 합니다. 위치값의 종류는 크게 세 가지 종류가 있습니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{Point:} x, y로 이루어진 2D 좌표 지오메트리 타입입니다. GPS 데이터처럼 위도와 경도값이 있는 경우입니다.

\item {} 
\sphinxstylestrong{Line:} 라인 좌표를 가진 지오메트리 타입입니다. WKT 형식으로 만들어진 LineString, MultiLineString 지오메트리를 지원합니다.

\item {} 
\sphinxstylestrong{Polygon} : 도형 좌표를 가진 지오메트리 타입입니다. WKT 형식으로 만들어진 Polygon, MultiPolygon 지오메트리를 지원합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{map_01}.jpg}
\end{figure}
\end{quote}

\end{itemize}


\subsubsection{맵 레이어 선반}
\label{\detokenize{discovery/part04/map_chart:id3}}\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{map_02}.jpg}
\end{figure}
\end{quote}

맵뷰에서는 다른 차트 유형과는 달리 열/행/교차 선반이 아닌 맵 레이어 선반을 갖고 있습니다. 맵 레이어 선반에는 반드시 위치 속성의 차원값을 1개 배치해야 합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{map_03}.jpg}
\end{figure}
\end{quote}

맵 레이어 선반에 문자 속성의 차원값을 배치하면 자동으로 해당 차원값으로 색상을 분류하여 표현하며 데이터 툴팁에 해당 차원값이 표기됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{map_04}.jpg}
\end{figure}
\end{quote}

또한 측정값을 레이어 선반에 배치하면 측정값으로 색상을 분류하고 동시에 해당 측정값을 기준으로 포인트 크기를 다르게 표현합니다. 차원값과 마찬가지로 툴팁에 해당 측정값이 표기됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{map_05}.jpg}
\end{figure}
\end{quote}


\paragraph{레이어 선반 추가}
\label{\detokenize{discovery/part04/map_chart:id4}}
레이어 선반 우측의 \sphinxcode{\sphinxupquote{+}} 버튼을 누르면 첫번째 레이어 위에 또 하나의 레이어를 추가할 수 있습니다. 각각의 레이어는 서로 다른 데이터소스를 사용해야 하며, 하나의 레이어에 두 개 이상의 데이터소스의 칼럼을 배치할 수 없습니다. 현재 최대 2개의 레이어 선반을 지원합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{map_addlayer}.jpg}
\end{figure}
\end{quote}


\subsubsection{맵뷰 레이어 스타일 속성}
\label{\detokenize{discovery/part04/map_chart:id5}}

\paragraph{공통 설정}
\label{\detokenize{discovery/part04/map_chart:id6}}
지도 레이어에서 기본 지도를 표현하는 맵 스타일의 유형을 선택할 수 있습니다. OpenStreetMap을 활용하여 세 가지의 맵 스타일을 기본적으로 제공하고 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{map_commonsetting}.jpg}
\end{figure}
\end{quote}
\begin{itemize}
\item {} 
Open Street Map \sphinxstylestrong{Light} (기본값)

\item {} 
Open Street Map \sphinxstylestrong{Dark}

\item {} 
Open Street Map \sphinxstylestrong{Colored}

\end{itemize}


\paragraph{레이어 설정}
\label{\detokenize{discovery/part04/map_chart:id7}}
레이어의 표현 방식을 설정합니다. 레이어 선반을 추가하면 1번 레이어와 2번 레이어에 대한 설정 메뉴가 각각 별도로 생성됩니다.


\subparagraph{Point 타입 레이어 속성}
\label{\detokenize{discovery/part04/map_chart:point}}\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{map_layersetting_point}.jpg}
\end{figure}
\end{quote}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{레이어 이름}: 맵뷰의 범례 및 툴팁 설정시 나타나는 레이어 명칭을 설정합니다.

\item {} 
\sphinxstylestrong{레이어 유형}: 데이터 포인트를 지도에 나타내는 유형을 \sphinxcode{\sphinxupquote{포인트}}/\sphinxcode{\sphinxupquote{히트맵}}/\sphinxcode{\sphinxupquote{헥사곤}}/\sphinxcode{\sphinxupquote{클러스터}} 중 하나로 변경할 수 있습니다. 기본값은 포인트입니다.

\item {} 
\sphinxstylestrong{포인트 유형}: 레이어 유형이 \sphinxcode{\sphinxupquote{포인트}} 인 경우 데이터 포인트의 모양을 변경할 수 있습니다. \sphinxcode{\sphinxupquote{원형}}/\sphinxcode{\sphinxupquote{사각형}}/\sphinxcode{\sphinxupquote{삼각형}} 으로 표현 가능하며 기본값은 원형입니다. 클러스터 사용이 OFF 로 설정되어야 맵에 표현됩니다.

\item {} 
\sphinxstylestrong{색상}: 레이어 선반에 올린 문자 속성의 차원값이나 측정값으로 데이터 포인트의 색상을 구분하여 표현할 수 있습니다. 색상 기준이 없는 경우 팔레트에서 색상을 변경할 수 있습니다. 투명도를 \%로 설정할 수 있습니다.

\item {} 
\sphinxstylestrong{크기}: 레이어 유형이 \sphinxcode{\sphinxupquote{포인트}} 인 경우 레이어 선반에 올린 측정값을 기준으로 데이터 포인트의 크기를 구분하여 표현할 수 있습니다.

\item {} 
\sphinxstylestrong{아웃라인}: ON으로 설정시 각 데이터 포인트의 아웃라인을 그립니다. 기본값은 OFF이며 색상 및 굵기를 설정할 수 있습니다.

\item {} 
\sphinxstylestrong{클러스터 범위}: 레이어 유형이 \sphinxcode{\sphinxupquote{클러스터}} 인 경우 클러스터링 범위를 \%로 지정할 수 있습니다. 데이터 포인트가 많을수록 클러스터를 사용하는 것이 브라우저 성능에 유리합니다.

\item {} 
\sphinxstylestrong{흐림효과}: 레이어 유형이 \sphinxcode{\sphinxupquote{히트맵}} 일 경우 히트맵의 흐림 효과를 조절할 수 있습니다. 기본값은 20\%입니다.

\item {} 
\sphinxstylestrong{반경값}: 레이어 유형이 \sphinxcode{\sphinxupquote{히트맵}} 또는 \sphinxcode{\sphinxupquote{헥사곤}} 일 경우 표시 반경을 1부터 100사이의 값으로 조절할 수 있습니다.

\end{enumerate}


\subparagraph{Line 타입 레이어 속성}
\label{\detokenize{discovery/part04/map_chart:line}}\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{map_layersetting_line}.jpg}
\end{figure}
\end{quote}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{레이어 이름}: 맵뷰의 범례 및 툴팁 설정시 나타나는 레이어 명칭을 설정합니다.

\item {} 
\sphinxstylestrong{색상}: 레이어 선반에 올린 문자 속성의 차원값이나 측정값으로 데이터 포인트의 색상을 구분하여 표현할 수 있습니다. 색상 기준이 없는 경우 팔레트에서 색상을 변경할 수 있습니다. 투명도를 \%로 설정할 수 있습니다.

\item {} 
\sphinxstylestrong{굵기}: 라인의 굵기를 설정할 수 있습니다.

\item {} 
\sphinxstylestrong{선 유형}: 실선/점선/파선 중 하나를 선택합니다. 기본값은 실선입니다.

\end{enumerate}


\subparagraph{Polygon 타입 레이어 속성}
\label{\detokenize{discovery/part04/map_chart:polygon}}\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{map_layersetting_polygon}.jpg}
\end{figure}
\end{quote}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{레이어 이름}: 맵뷰의 범례 및 툴팁 설정시 나타나는 레이어 명칭을 설정합니다.

\item {} 
\sphinxstylestrong{색상}: 레이어 선반에 올린 문자 속성의 차원값이나 측정값으로 데이터 포인트의 색상을 구분하여 표현할 수 있습니다. 색상 기준이 없는 경우 팔레트에서 색상을 변경할 수 있습니다. 투명도를 \%로 설정할 수 있습니다.

\item {} 
\sphinxstylestrong{아웃라인}: ON으로 설정시 각 폴리곤의 아웃라인을 그립니다. 기본값은 OFF이며 색상 및 굵기를 설정할 수 있습니다.

\end{enumerate}


\paragraph{범례 설정}
\label{\detokenize{discovery/part04/map_chart:id8}}
범례 표시 여부를 설정할 수 있습니다. 기본값은 OFF 이며, ON으로 변경 시 범례의 위치를 설정할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{map_legend}.jpg}
\end{figure}
\end{quote}


\subsubsection{공간 분석}
\label{\detokenize{discovery/part04/map_chart:id9}}
메타트론 디스커버리 맵뷰에서는 두 개의 레이어 간의 간단한 공간 분석 기능을 지원합니다. 왼쪽 분석 탭에서 연산식을 설정할 수 있으며, 현재 버전에서 공간 연산식은 두 종류를 지원합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{map_analysis}.jpg}
\end{figure}
\end{quote}
\begin{itemize}
\item {} 
\sphinxstylestrong{Within}: 기준 레이어의 요소와 비교 레이어의 요소 사이 거리를 지정하여 거리 내에 존재하는 값을 반환합니다.

\item {} 
\sphinxstylestrong{Intersection}: 기준 레이어에서 비교 레이어와 겹치는 부분을 반환하는 방식입니다. Polygon \textgreater{} Line \textgreater{} Point의 순서로 더 큰 Geometry가 기준이 되는 경우, 결과 반환값이 달라질 수 있습니다.

\end{itemize}

각 연산식에서 추가적으로 설정할 수 있는 값은 아래와 같습니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{근접 거리 입력(Buffer)}: 기준 레이어와 비교 레이어 간에 비교할 거리를 숫자로 입력하도록 설정할 수 있습니다. 거리 단위를 미터 또는 킬로미터로 변경할 수 있습니다.

\item {} 
\sphinxstylestrong{단계구분도 보기 (Choropleth map)}: 연산 결과 레이어를 단계구분도 형태로 표시할 수 있습니다. 단계구분도의 색상 기준을 선택할 수 있으며 겹치는 데이터의 수(COUNT)를 기본으로 색상을 나눕니다. 만약 기준 레이어에 측정값이 있을 경우 해당 측정값을 기준으로 색상을 변경할 수 있습니다.

\end{itemize}


\section{필터}
\label{\detokenize{discovery/part04/filters:id1}}\label{\detokenize{discovery/part04/filters::doc}}
필터는 대시보드와 차트를 구성할 때 조건에 일치하는 데이터만 표출하도록 설정하는 기능입니다. 차트의 종류는 차트 필터, 글로벌 필터 두 가지로 구성됩니다. 차트 필터는 개별 차트에 적용되는 필터이고, 글로벌 필터는 하나의 대시보드 전체에 적용되는 필터입니다.


\subsection{차트 필터}
\label{\detokenize{discovery/part04/chart_filter:id1}}\label{\detokenize{discovery/part04/chart_filter::doc}}
차트 필터는 각 컬럼별로 차트에 나타낼 데이터의 범위를 한정 짓는 기능을 합니다. 본 챕터에서는 차트 필터를 지정하고 활용하는 방법에 대해 설명합니다.


\subsubsection{자동으로 포함되는 필터들}
\label{\detokenize{discovery/part04/chart_filter:id2}}
다음에 해당하는 컬럼들의 필터는 별도의 차트 필터를 추가하지 않아도 자동으로 포함됩니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{타임스탬프 컬럼 필터:} Metatron 엔진의 시계열 특성 때문에 시간 조건 필터링이 필수적으로 사용됩니다.

\item {} 
\sphinxstylestrong{추천 필터:} 데이터 소스 등록할 때 '추천 필터'로 지정된 컬럼 필터들입니다.

\item {} 
\sphinxstylestrong{글로벌 필터가 적용된 대시보드:} 해당 대시보드에 등록된 모든 차트에 공통적으로 적용되는 필터입니다.

\end{itemize}


\subsubsection{차트 필터 패널}
\label{\detokenize{discovery/part04/chart_filter:id3}}
차트 홈 화면 우측에는 차트 필터 패널이 있습니다. 이 패널에서는 등록된 필터를 간단하게 조회·설정할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{chart-panel}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{필터 수:} 차트 패널 이름 옆에는 현재 적용된 차트가 몇 개인지 표시됩니다.

\item {} 
\sphinxstylestrong{필터 추가/변경:} 우측 상단의 '+' 버튼을 누르면 새로운 필터를 추가하거나 기존 필터를 세부 설정하는 팝업이 나타납니다.

\item {} 
\sphinxstylestrong{필터 대상 컬럼:} 개별 필터의 상단에는 필터가 적용되는 컬럼 정보를 보여줍니다.

\item {} 
\sphinxstylestrong{필터 상세 설정:} 개별 필터 우측 상단에 햄버거 메뉴를 누르면 필터를 초기화하거나 상세 설정할 수 있습니다.

\end{enumerate}
\end{quote}


\subsubsection{차트 필터 대화 상자}
\label{\detokenize{discovery/part04/chart_filter:id4}}
차트 필터 패널 상단에서 버튼을 클릭하거나 각 필터 영역에서 버튼을 클릭하면 차트 필터 대화 상자를 열 수 있습니다. 이 대화 상자에서는 새로운 필터를 추가하거나 기존 필터를 세부적으로 설정할 수 있습니다.

차트 필터 대화 상자는 다음과 같이 차원값과 측정값 영역으로 구성됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{filter-dialog}.png}
\end{figure}
\end{quote}


\paragraph{차원값 필터링}
\label{\detokenize{discovery/part04/chart_filter:id5}}
해당 차트와 연동된 데이터 소스의 차원값을 필터로 지정할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{filter-dialog-dimension}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{범위 선택:} 선택한 필터의 컬럼에 들어있는 데이터 범주 중 필터링하여 차트에 표시할 범위를 선택합니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{단건:} 하나의 데이터 범주만 선택하여 차트에서 표시할 수 있습니다.

\item {} 
\sphinxstylestrong{다건:} 여러 개의 데이터 범주를 선택하여 차트에 표시할 수 있습니다.

\end{itemize}

\item {} 
\sphinxstylestrong{검색:} 컬럼 속성 값이 너무 많은 경우, 원하는 결과만 볼 수 있도록 제한할 수 있습니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{이름으로 검색:} 컬럼의 속성값 이름으로 검색할 수 있습니다.

\item {} 
\sphinxstylestrong{속성 필터링:} 속성 값 이름을 정규식이나 와일드 카드로 매칭하거나, 측정값의 범위를 기준으로 조건을 걸어서 속성을 선별할 수 있습니다.

\end{itemize}

\end{itemize}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{filter-dimension-searching}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{Defined value:} 컬럼에 들어있지 않은 속성값을 필터 조건으로 추가하는 데 사용합니다. 현재 데이터 소스에는 없지만 추후에 들어올 수 있는 데이터를 미리 예측하여 필터를 생성하는 기능입니다.

\end{itemize}
\end{quote}


\paragraph{타임스탬프 컬럼 필터 설정}
\label{\detokenize{discovery/part04/chart_filter:id6}}
시간 아이콘이 표시된 차원값은 타임스탬프 타입이며 해당 차원값은 타임스탬프 필터를 설정할 수 있습니다. 기본적으로 전체 시간(All time)으로 설정되어 있으며, 특정 기간의 데이터만 차트에 표출하고 싶은 경우 Relative 또는 Specific을 선택하여 설정합니다.

Relative는 현재 시점을 기준으로 상대적인 기간을 설정하여 해당 기간 동안의 데이터만 차트에 표출하도록 합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{filter-timestamp-relative}.png}
\end{figure}
\end{quote}

Specific은 데이터의 특정 기간을 직접 설정하여 해당 기간 동안의 데이터만 차트에 표출하도록 합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{filter-timestamp-specific}.png}
\end{figure}
\end{quote}


\paragraph{측정값 필터링}
\label{\detokenize{discovery/part04/chart_filter:id7}}
해당 차트와 연동된 데이터 소스의 측정값을 필터로 지정할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{filter-measure1}.png}
\end{figure}
\end{quote}

필터로 설정할 측정값을 선택했으면 필터링할 값의 범위를 지정합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{filter-measure2}.png}
\end{figure}
\end{quote}


\subsection{글로벌 필터}
\label{\detokenize{discovery/part04/global_filter:id1}}\label{\detokenize{discovery/part04/global_filter::doc}}
글로벌 필터는 대시보드에 속한 모든 차트에 적용되는 데이터 표출 조건으로, 대시보드 편집 창의 필터 패널에서 추가, 수정, 삭제할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{global-filter}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{필터 위젯 수:} 글로벌 필터 제목 옆에 현재 대시보드에 등록된 필터 위젯의 개수가 나타납니다.

\item {} 
\sphinxstylestrong{필터 위젯 추가:} 우측 상단의 '+'를 클릭하면 대시보드 내에 새로운 필터 위젯을 생성할 수 있습니다. 필터 생성 팝업 및 생성 방법은 직전 챕터의 차트 필터 생성 절차와 동일합니다.

\item {} 
\sphinxstylestrong{필터 위젯 목록:} 현재 대시보드에 등록된 필터 위젯들이 열거됩니다. 수정 또는 삭제를 원하는 위젯 항목에 마우스를 오버하면 이를 위한 아이콘이 나타납니다. 또한 위젯 항목을 위젯 레이아웃 영역으로 드래그하면 위젯이 위젯 레이아웃 영역에 표시됩니다.

\end{enumerate}
\end{quote}

전체 대시보드에 적용된 글로벌 필터는 차트 생성 시 개별 필터를 만들 때에 함께 조회됩니다. 또한 글로벌 필터 생성 시에도 개별 차트 필터가 있다면 어떤 칼럼에 생성되었는지 직관적으로 알려줍니다.


\chapter{노트북}
\label{\detokenize{discovery/part05/index:id1}}\label{\detokenize{discovery/part05/index::doc}}
\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{notebook_overview}.png}
\end{figure}

Metatron Discovery에서는 노트북 기능을 수행할 수 있습니다. 노트북이란, 라이브 코드, 등식, 시각화와 설명을 위한 텍스트 등을 포함한 문서를 만들고 공유할 수 있는 도구입니다.
주로 데이터 클리닝과 변형, 수치 시뮬레이션, 통계 모델링, 머신 러닝 등에 사용할 수 있습니다.

Metatron Discovery에서는 Jupyter와 Zeppelin을 등록하여 사용할 수 있도록 기능을 제공하고 있습니다. Jupyter는 데이터 과학 분야에서 주로 사용하는 Python, R 프로그래밍 언어를, Zeppelin은 Spark(scala) 프로그래밍 언어를 활용하여 실시간으로 인터렉티브하게 데이터를 분석하고 시각화할 수 있도록 도와줍니다. 노트북을 수행하기 전, 노트북 서버 세팅이 되어있어야 합니다.


\section{노트북 서버 관리}
\label{\detokenize{discovery/part05/notebook_management:id1}}\label{\detokenize{discovery/part05/notebook_management::doc}}
노트북 모듈의 사용을 허용하기 위해서는 먼저 \sphinxstylestrong{관리자}가 외부 분석 도구가 설치되어 있는 서버, 즉 '노트북 서버'와 연동을 해야 합니다.

메인 화면 좌측 패널에서 \sphinxmenuselection{MANAGEMENT \(\rightarrow\) 노트북 관리 \(\rightarrow\) 노트북 서버} 메뉴로 이동하면 노트북 서버를 새로 등록하거나 기존에 등록된 노트북 서버를 조회·수정할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{notebook_management0}.png}
\end{figure}
\end{quote}


\subsection{노트북 서버 목록}
\label{\detokenize{discovery/part05/notebook_management:id2}}
이 화면에서는 노트북 서버들을 보여줍니다.
노트북 서버 목록은 서버 이름과 타입으로 필터링할 수 있으며, 목록에 나타난 서버 중 하나를 클릭하여 해당 서버의 정보를 열람·수정할 수 있습니다.
또한 서버 중 하나에 마우스를 오버하면 나타나는 \sphinxincludegraphics{{icon_bin1}.png} 버튼을 클릭하거나, 좌측에서 삭제하고자 하는 서버들의 체크란을 선택한 후 우측 상단에 있는 \sphinxguilabel{선택 삭제} 버튼을 클릭하면 해당 노트북 서버가 삭제됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{notebook_management1}.png}
\end{figure}
\end{quote}


\subsection{노트북 서버 추가}
\label{\detokenize{discovery/part05/notebook_management:id3}}
노트북 관리 화면에서 \sphinxguilabel{노트북 서버 추가} 버튼을 클릭하면 다음과 같은 노트북 서버 등록 화면이 팝업이 됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[scale=0.6]{{notebook_management2}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{타입:} 등록하려는 노트북 서버에 설치된 외부 분석 도구를 선택합니다. \sphinxstylestrong{Jupyter}와 \sphinxstylestrong{zeppelin} 중 선택이 가능합니다.

\item {} 
\sphinxstylestrong{URL:} 등록하려는 노트북 서버의 URL을 입력합니다. http://와 https://를 지원합니다.

\item {} 
\sphinxstylestrong{이름:} 등록하려는 노트북 서버의 이름을 입력합니다.

\item {} 
\sphinxstylestrong{설명:} 등록하려는 노트북 서버에 대한 설명을 입력합니다.

\end{itemize}
\end{quote}


\section{노트북 서버 등록하기}
\label{\detokenize{discovery/part05/register_a_notebook_server:id1}}\label{\detokenize{discovery/part05/register_a_notebook_server::doc}}
워크스페이스에서 노트북 기능을 이용하여 데이터를 분석하기 위해서는 노트북 서버 초기 설정이 필요합니다. 노트북 서버 초기 설정 절차는 다음과 같습니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
워크스페이스의 우측 상단에 있는 \sphinxincludegraphics{{icon_more}.png} 버튼을 클릭한 후 \sphinxguilabel{노트북 서버 설정}을 선택합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{register_a_notebook_server_01}.png}
\end{figure}
\end{quote}

\item {} 
관리자가 사전에 등록해 둔 Jupyter, Zeppelin 서버 목록 중에서 본인 워크스페이스에서 연결해서 사용하고자 하는 노트북 서버를 선택 후 \sphinxguilabel{마침}버튼을 클릭합니다.
\begin{quote}
\begin{itemize}
\item {} 
아무 서버도 선택하지 않고자 한다면, \sphinxstylestrong{(없음)} 항목을 선택하십시오.

\end{itemize}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{register_a_notebook_server_02}.png}
\end{figure}
\end{quote}

\end{enumerate}


\section{신규 노트북 생성하기}
\label{\detokenize{discovery/part05/create_a_notebook:id1}}\label{\detokenize{discovery/part05/create_a_notebook::doc}}
노트북 서버 설정이 완료되면, 노트북을 생성할 수 있습니다. 노트북 생성 절차는 다음과 같습니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
워크스페이스 하단에 있는 \sphinxstylestrong{+ 노트북} 버튼을 클릭하면 노트북을 생성할 수 있는 화면이 나타납니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_notebook_00}.png}
\end{figure}
\end{quote}

\item {} 
노트북에서 분석하고자 하는 데이터셋 타입을 선택합니다. Metatron Discovery에서 사용하는 데이터 단위인 \sphinxstylestrong{데이터 소스}, \sphinxstylestrong{대시보드}, \sphinxstylestrong{차트} 그리고 \sphinxstylestrong{선택하지 않음} 중에서 선택할 수 있습니다. Zeppelin으로 분석하기를 원한다면, \sphinxstylestrong{선택하지 않음}을 선택하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_notebook_01}.png}
\end{figure}
\end{quote}

\item {} 
\sphinxstylestrong{데이터 소스}, \sphinxstylestrong{대시보드}, \sphinxstylestrong{차트} 중 하나를 선택하면, 현재 Metatron Discovery에 등록된 데이터 목록을 조회할 수 있습니다. 분석 대상 데이터를 선택한 후 다음 버튼을 클릭합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_notebook_02}.png}
\end{figure}
\end{quote}

\item {} 
데이터를 분석하고자 하는 노트북 정보를 입력합니다. 초기 노트북 서버 설정에서 연결해 둔 노트북 서버에 한해서만 \sphinxstylestrong{서버 유형}을 선택할 수 있습니다. \sphinxstylestrong{Jupyter} 선택 시 'R' 또는 'Python' 언어를, \sphinxstylestrong{Zeppelin} 선택 시 'Spark' (scala) 언어를 선택하여 분석할 수 있게 됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_notebook_03}.png}
\end{figure}
\end{quote}

\item {} 
노트북 생성이 완료되면, 해당 워크스페이스 화면에서 다음과 같이 확인할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_notebook_04}.png}
\end{figure}
\end{quote}

\end{enumerate}


\section{노트북 활용하기}
\label{\detokenize{discovery/part05/use_a_notebook:id1}}\label{\detokenize{discovery/part05/use_a_notebook::doc}}
노트북을 생성하였으면, 스크립트를 작성하고 REST API를 통해 서비스할 수 있습니다. 노트북 활용 절차는 다음과 같습니다.


\subsection{노트북 상세 조회}
\label{\detokenize{discovery/part05/use_a_notebook:id2}}
워크스페이스 화면에서 분석하고자 하는 노트북을 선택하면, 아래와 같은 상세 화면이 나타납니다. 노트북 생성 시 입력했던 데이터 타입과 데이터 소스 이름, 개발 언어, 코드를 조회할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{use_a_notebook_01}.png}
\end{figure}
\end{quote}


\subsection{노트북 코딩}
\label{\detokenize{discovery/part05/use_a_notebook:id3}}
노트북 상세 조회 화면에서 코드 란의 \sphinxstylestrong{상세}를 클릭하면, 노트북 페이지가 나타납니다. 노트북 페이지 상단에는 데이터셋을 로딩하는 코드가 삽입되어 있으며, 해당 셀을 실행하면 dataset 객체에 JSON 포맷의 데이터셋이 로딩됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{use_a_notebook_02}.png}
\end{figure}
\end{quote}

위 화면은 Zeppeline을 선택한 경우에 나타나며, 생성 시 선택한 데이터의 로딩을 위한 셀이 삽입되어 있습니다. 3번째 셀부터 프로그램 코딩 작업을 수행한 후 개발이 완료되면 \sphinxstylestrong{저장} 버튼을 클릭하십시오.


\subsection{노트북 API 등록하기}
\label{\detokenize{discovery/part05/use_a_notebook:api}}
작성한 노트북은 REST API 를 호출하여 결과값을 반환할 수 있습니다. 아래 설명을 참조하여 \sphinxstylestrong{리턴타입}을 선택한 후 \sphinxstylestrong{이름}과 \sphinxstylestrong{설명}을 기입하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{use_a_notebook_03}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{HTML}: 노트북 스크립트 전체 실행 결과 화면을 HTML로 반환합니다.

\item {} 
\sphinxstylestrong{JSON}: 노트북 스크립트에 작성된 사용자가 정의한 포맷의 JSON 객체를 결과로 반환합니다. 이 때 Metatron Discovery에서 제공하는 \sphinxcode{\sphinxupquote{response.write(...)}} 함수를 사용하며, 예시 코드는 다음과 같습니다.
\begin{itemize}
\item {} 
R 기반 노트북: \sphinxcode{\sphinxupquote{response.write(list(coefficient = 2, intercept = 0))}}

\item {} 
Python 기반 노트북: \sphinxcode{\sphinxupquote{response.write(\{'coefficient' : 2.5, 'intercept' : 0\})}}

\end{itemize}

\item {} 
\sphinxstylestrong{없음}: 노트북 스크립트를 실행하되 반환값은 제공하지 않습니다.

\end{itemize}
\end{quote}

API 정보를 모두 입력한 후 \sphinxstylestrong{마침} 버튼을 클릭하면 API생성이 완료되고 아래와 같은 REST API URL을 확인할 수 있습니다. \sphinxstylestrong{Result} 버튼을 클릭하면 URL 실행 결과값을 팝업으로 조회할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{use_a_notebook_04}.png}
\end{figure}
\end{quote}


\chapter{워크벤치}
\label{\detokenize{discovery/part06/index:id1}}\label{\detokenize{discovery/part06/index::doc}}
\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workbench_overview}.png}
\end{figure}

Metatron Discovery 워크벤치는 SQL을 기반으로 하는 데이터 전처리 및 분석 환경을 제공합니다. 주요 기능은 다음과 같습니다.
\begin{itemize}
\item {} 
다양한 외부 데이터베이스를 한꺼번에 작업공간에 조회 가능

\item {} 
연동된 데이터베이스의 테이블과 컬럼을 쉽게 조회/선택하며 상세 정보 열람 가능

\item {} 
쿼리 편집 도구가 내장되어 있으며 쿼리 결과를 실시간으로 확인하고 다양하게 활용 가능:
\begin{itemize}
\item {} 
쿼리결과를 로컬 파일로 다운로드 또는 온라인 엑셀로 출력

\item {} 
쿼리 결과를 즉시 시각화함으로써 쿼리 결과로 출력된 데이터 형태를 쉽게 파악

\item {} 
쿼리 결과를 데이터 소스로 저장하여 워크북이나 노트북에서 분석에 활용 가능

\end{itemize}

\end{itemize}

SQL 기반 분석 쿼리를 보관하는 각각의 문서를 '워크벤치'라고 부릅니다. 본 단원에서는 워크벤치를 \sphinxstylestrong{생성}하고 \sphinxstylestrong{활용}하는 절차를 소개합니다.


\section{워크벤치 만들기}
\label{\detokenize{discovery/part06/06_02-create_a_workbench:id1}}\label{\detokenize{discovery/part06/06_02-create_a_workbench::doc}}
해당 워크스페이스에서 워크벤치를 사용하기 위해서는 워크벤치용 데이터 커넥션이 설정되어 있어야 합니다.
이에 관한 자세한 내용은 {\hyperref[\detokenize{discovery/part02/data_connection::doc}]{\sphinxcrossref{\DUrole{doc}{데이터 커넥션}}}} 항목을 참조하시기 바랍니다.

워크벤치 생성 절차는 다음과 같습니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
워크스페이스 하단에 있는 \sphinxstylestrong{+ 워크벤치} 버튼을 클릭하면 워크벤치에서 데이터 분석에 사용할 데이터 커넥션을 연결할 수 있는 화면이 나타납니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workbench_creation_01}.png}
\end{figure}
\end{quote}

\item {} 
사용자가 연결하여 사용하고자하는 워크벤치용 데이터 커넥션을 선택한 후 \sphinxstylestrong{다음} 버튼을 클릭합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workbench_creation_02}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{데이터 커넥션 이름으로 검색:} 해당 워크스페이스에 허용된 데이터 커넥션을 이름으로 검색합니다.

\item {} 
\sphinxstylestrong{DB Type:} 데이터 커넥션을 데이터베이스 타입(Oracle/MySQL/Hive/presto/Tibero)별로 선별하여 볼 수 있습니다. \sphinxstylestrong{모두}로 선택하면 모든 DB타입의 데이터 커넥션을 볼 수 있습니다.

\item {} 
\sphinxstylestrong{계정 타입:} 데이터 커넥션을 설정된 계정 타입(관리자 직접 입력/사용자의 계정 사용/워크벤치 접속 시 직접 입력)별로 선별하여 볼 수 있습니다. \sphinxstylestrong{All}로 선택하면 모든 계정 타입의 데이터 커넥션을 볼 수 있습니다.

\item {} 
\sphinxstylestrong{데이터 커넥션:} 설정한 선별 조건에 맞는 데이터 커넥션들을 보여줍니다.

\end{itemize}
\end{quote}

\item {} 
선택한 데이터 커넥션의 정보를 확인하고 이름과 설명을 입력하면 워크벤치가 생성됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[scale=0.5]{{workbench_creation_03}.png}
\end{figure}
\end{quote}

\item {} 
워크벤치 생성이 완료되면, 생성된 워크벤치를 바로 확인할 수 있습니다.

\end{enumerate}


\section{워크벤치 사용하기}
\label{\detokenize{discovery/part06/06_03-use_a_workbench:id1}}\label{\detokenize{discovery/part06/06_03-use_a_workbench::doc}}
워크벤치에서는 SQL 데이터베이스 편집 및 관리가 용이하며 쿼리 결과를 다양한 형태로 시각화하여 저장할 수 있습니다. 워크벤치의 화면은 다음과 같은 5개의 영역으로 나뉘며, 추가적으로 스키마 브라우저를 열 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workbench_basic}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
기본 정보 영역({\hyperref[\detokenize{discovery/part06/06_03-use_a_workbench:workbench-use-1}]{\sphinxcrossref{\DUrole{std,std-ref}{기본 정보 영역}}}} 참조)

\item {} 
스키마 및 테이블 영역({\hyperref[\detokenize{discovery/part06/06_03-use_a_workbench:workbench-use-2}]{\sphinxcrossref{\DUrole{std,std-ref}{스키마 및 테이블 영역}}}} 참조)

\item {} 
쿼리 에디터 영역({\hyperref[\detokenize{discovery/part06/06_03-use_a_workbench:workbench-use-3}]{\sphinxcrossref{\DUrole{std,std-ref}{쿼리 에디터 영역}}}} 참조)

\item {} 
쿼리 결과 영역({\hyperref[\detokenize{discovery/part06/06_03-use_a_workbench:workbench-use-4}]{\sphinxcrossref{\DUrole{std,std-ref}{쿼리 결과 영역}}}} 참조)

\item {} 
추가 도구 영역({\hyperref[\detokenize{discovery/part06/06_03-use_a_workbench:workbench-use-5}]{\sphinxcrossref{\DUrole{std,std-ref}{추가 도구 영역}}}} 참조)

\item {} 
스키마 브라우저({\hyperref[\detokenize{discovery/part06/06_03-use_a_workbench:workbench-use-6}]{\sphinxcrossref{\DUrole{std,std-ref}{스키마 브라우저}}}} 참조)

\end{enumerate}
\end{quote}


\subsection{기본 정보 영역}
\label{\detokenize{discovery/part06/06_03-use_a_workbench:workbench-use-1}}\label{\detokenize{discovery/part06/06_03-use_a_workbench:id2}}
현재 작업하는 워크벤치에 관한 정보가 나타나는 영역입니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workbench_lnb_header}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{이름:} 워크벤치의 이름입니다. 클릭하여 이름을 변경할 수 있습니다.

\item {} 
\sphinxstylestrong{데이터 커넥션:} 해당 워크벤치와 연결되어 있는 데이터 커넥션의 이름입니다. \sphinxincludegraphics{{icon_exclamation}.png} 아이콘을 클릭하면 자세한 정보가 나타납니다.

\item {} 
\sphinxincludegraphics{{icon_folding}.png} : 패널을 접고 펼치는 UI 버튼입니다

\end{enumerate}
\end{quote}


\subsection{스키마 및 테이블 영역}
\label{\detokenize{discovery/part06/06_03-use_a_workbench:workbench-use-2}}\label{\detokenize{discovery/part06/06_03-use_a_workbench:id3}}
원하는 데이터베이스, 테이블, 컬럼을 손쉽게 쿼리 에디터에 입력할 수 있는 UI 기능입니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workbench_lnb}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{데이터베이스 이름:} 현재 선택된 데이터베이스의 이름을 출력해줍니다. 해당 워크벤치에 등록된 데이터 커넥션의 첫 번째 데이터베이스를 기본적으로 선택됩니다. 클릭하면 데이터 커넥션에 포함된 모든 데이터베이스가 조회되며, 그 중에 하나를 선택하면 해당 데이터베이스로 변경됩니다.

\item {} 
\sphinxstylestrong{스키마 브라우저:} 선택된 데이터베이스의 테이블 목록과 각 테이블에 속한 모든 컬럼 및 레코드 정보를 확인할 수 있는 스키마 브라우저 화면이 팝업됩니다.

\item {} 
\sphinxstylestrong{테이블 검색:} 선택된 데이터베이스에 등록된 테이블을 이름으로 검색합니다.

\item {} 
\sphinxstylestrong{테이블 이름:} 필요한 데이터를 담은 테이블을 선택하면, 오른쪽 쿼리 에디터에 해당 테이블에 대한 \sphinxcode{\sphinxupquote{SELECT \textbackslash{}* FROM \{table name\}}} 쿼리가 자동으로 입력됩니다.

\item {} 
\sphinxstylestrong{컬럼 목록:} 해당 테이블에 속한 모든 컬럼 이름과 각각의 데이터 타입이 나타납니다. 컬럼 이름을 클릭하면 쿼리 에디터에 자동으로 삽입됩니다.

\end{enumerate}
\end{quote}


\subsection{쿼리 에디터 영역}
\label{\detokenize{discovery/part06/06_03-use_a_workbench:workbench-use-3}}\label{\detokenize{discovery/part06/06_03-use_a_workbench:id4}}
쿼리를 작성하고 실행할 수 있는 에디터 화면입니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workbench_query_editor}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxincludegraphics{{icon_arrow}.png} : 탭이 너무 많을 경우 탭 영역을 좌우로 스크롤 할수 있는 버튼입니다. 탭의 개수가 많지 않은 경우 나타나지 않습니다.

\item {} 
\sphinxstylestrong{탭:} 쿼리 관리를 위해 여러 개의 탭으로 나누어서 쿼리를 실행하거나 저장할 수 있습니다. \sphinxincludegraphics{{icon_more1}.png} 버튼을 클릭 시 탭 제목의 수정과 탭 삭제가 가능합니다.

\item {} 
\sphinxincludegraphics{{icon_plus1}.png} : 이 버튼을 클릭하면 새로운 탭이 추가됩니다.

\item {} 
\sphinxincludegraphics{{icon_full}.png} : 이 버튼을 클릭하면 쿼리 에디터 영역을 전체화면으로 확장하거나 축소 할 수 있습니다.

\item {} 
\sphinxstylestrong{쿼리 행:} 쿼리 코드의 행 번호를 보여줍니다.

\item {} 
\sphinxstylestrong{에디터 화면:} 이 곳에 쿼리 문을 작성합니다. 멀티 쿼리의 실행 및 단일 쿼리의 실행이 가능합니다. \sphinxcode{\sphinxupquote{;}}을 쿼리 문이 끝날 때마다 삽입하면 쿼리를 나눠서 실행이 가능합니다. 자동완성 기능이 제공됩니다.

\item {} 
\sphinxstylestrong{쿼리 전체 실행:} 쿼리 에디터에 작성된 전체 쿼리를 실행합니다. (단축키: Ctrl + Enter)

\item {} 
\sphinxstylestrong{쿼리 부분 실행:} 쿼리 문 안에서 마우스가 위치된 특정 쿼리 또는 드래그하여 선택된 영역만 쿼리를 실행합니다. (단축키: Command + Enter)

\item {} 
\sphinxstylestrong{CLEAR SQL:} 쿼리 문을 모두 삭제 합니다.

\item {} 
\sphinxstylestrong{SQL BEAUTIFIER:} 이 버튼을 클릭하면 작성된 쿼리 문이 쿼리 문법 표준에 맞게 정렬됩니다.

\item {} 
\sphinxstylestrong{Query History:} 쿼리 에디터에서 수행한 과거 목록을 조회할수 있으며, 쿼리 선택 시 쿼리문이 쿼리 에디터에 추가됩니다.

\item {} 
\sphinxstylestrong{Query Editor 단축키:} 쿼리 에디터에서 사용가능한 단축키 목록입니다.

\end{enumerate}
\end{quote}


\subsection{쿼리 결과 영역}
\label{\detokenize{discovery/part06/06_03-use_a_workbench:workbench-use-4}}\label{\detokenize{discovery/part06/06_03-use_a_workbench:id5}}
쿼리가 실행되면 그 결과가 쿼리 결과 탭에 나타납니다. 모든 쿼리 결과는 계속 누적되지만, 원하는 결과 탭을 자유롭게 삭제할 수 있습니다. 쿼리 결과는 텍스트 그리드 형태로 제공되며, 차트 미리보기, 데이터 소스 저장, 다운로드 CSV 기능이 지원됩니다.


\subsubsection{쿼리 수행 중}
\label{\detokenize{discovery/part06/06_03-use_a_workbench:id6}}\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workbench_query_result_ing}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{쿼리 결과 탭:} 다중 쿼리 수행시 쿼리당 하나의 결과 탭이 생성되며 쿼리 수행 중인 탭일 경우 탭 제목에 'Loading' 메시지가 표시됩니다.

\item {} 
\sphinxstylestrong{쿼리 로그:} 쿼리 수행 로그를 보여주는 영역입니다. Hive 타입의 커넥션일 경우 Hive Job Log가 추가적으로 표시됩니다.

\item {} 
\sphinxstylestrong{쿼리 수행 취소:} 수행중인 쿼리를 취소합니다. DB 타입별 취소에 걸리는 시간이 다소 차이날 수 있습니다.

\item {} 
\sphinxstylestrong{쿼리 수행 단계:} 쿼리 수행의 총 5가지 단계 중 현재 단계를 표시합니다.
\begin{itemize}
\item {} 
Getting connection

\item {} 
Creating statement

\item {} 
Executing query

\item {} 
Getting result set

\item {} 
Done!

\end{itemize}

\item {} 
\sphinxstylestrong{다중 쿼리 순서 표시:} 다중 쿼리 수행 시 현재 몇 번째 쿼리를 수행 중인지 표시합니다.

\item {} 
\sphinxstylestrong{표시 전환 탭:} 쿼리 수행 로그 탭과 쿼리 결과 탭을 전환하는 버튼입니다.

\item {} 
\sphinxstylestrong{쿼리 수행 상태:} 3가지 쿼리 수행 상태를 표시합니다.
\begin{itemize}
\item {} 
쿼리 수행중

\item {} 
쿼리 수행 실패

\item {} 
쿼리 수행 취소

\end{itemize}

\item {} 
\sphinxstylestrong{쿼리 수행 시작 시각:} 쿼리 수행 시작 시각을 표시합니다.

\item {} 
\sphinxstylestrong{쿼리 수행 경과 시간:} 쿼리 수행 경과 시간을 표시합니다.

\end{enumerate}
\end{quote}


\subsubsection{쿼리 수행 후}
\label{\detokenize{discovery/part06/06_03-use_a_workbench:id7}}\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workbench_query_result_complete}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{쿼리 결과 탭:} 다중 쿼리 수행시 쿼리당 하나의 결과 탭이 생성되며 쿼리 수행 중인 탭일 경우 탭 제목에 'Loading' 메시지가 표시됩니다.

\item {} 
\sphinxstylestrong{데이터 내역:} 쿼리 실행에 의해 출력된 데이터 내역입니다. 출력된 데이터는 클립보드에 복사하여 활용할 수도 있습니다.

\item {} 
\sphinxstylestrong{표시 전환 탭:} 쿼리 수행 로그 탭과 쿼리 결과 탭을 전환하는 버튼입니다.

\item {} 
\sphinxstylestrong{컬럼 데이터 검색:} 결과 내 컬럼 및 값을 검색할 수 있습니다.

\item {} 
\sphinxstylestrong{차트 미리보기:} 쿼리 결과를 이용하여 차트를 가상으로 그려볼 수 있습니다. 시각화를 위해 그려지는 것이고, 실제 워크스페이스 내용에 반영되지는 않습니다. (자세한 조작 방식은 {\hyperref[\detokenize{discovery/part04/manage_charts::doc}]{\sphinxcrossref{\DUrole{doc}{차트}}}} 항목 참조)

\item {} 
\sphinxstylestrong{데이터 소스 저장:} 쿼리 결과를 이용하여 워크스페이스 내 데이터 소스로 저장할 수 있습니다. 데이터 소스 생성 팝업이 나타나며, 데이터 커넥션 선택 및 테이블 선택 등의 과정은 워크벤치 결과 내용으로 대체됩니다. 따라서 스키마 정의 및 ingestion 주기 등의 과정이 곧바로 진행되게 됩니다. (자세한 절차는 {\hyperref[\detokenize{discovery/part02/create_a_data_source::doc}]{\sphinxcrossref{\DUrole{doc}{데이터 소스 만들기}}}} 참조)

\item {} 
\sphinxstylestrong{다운로드 CSV:} 쿼리 결과를 로컬 파일(csv)로 다운로드가 가능합니다.

\item {} 
\sphinxstylestrong{데이터 페이징:} 1000건의 이상의 데이터일 경우 Prev, Next 버튼을 이용해 페이지 넘김이 가능합니다.

\item {} 
\sphinxstylestrong{쿼리 수행 시작 시각:} 쿼리 수행 시작 시각을 표시합니다.

\item {} 
\sphinxstylestrong{쿼리 수행 종료 시각:} 쿼리 수행 종료 시각을 표시합니다.

\item {} 
\sphinxstylestrong{쿼리 수행 경과 시간:} 쿼리 수행 경과 시간을 표시합니다.

\item {} 
\sphinxstylestrong{쿼리 Row 정보:} 쿼리 결과의 Row 숫자와 현재 페이지 정보를 표시합니다.

\end{enumerate}
\end{quote}


\subsection{추가 도구 영역}
\label{\detokenize{discovery/part06/06_03-use_a_workbench:workbench-use-5}}\label{\detokenize{discovery/part06/06_03-use_a_workbench:id8}}
추가 도구 영역은 워크벤치 활용에 도움을 주는 유용한 기능들로 구성되어 있습니다.
\begin{itemize}
\item {} 
반복 사용 구문에 대한 글로벌 변수 설정 ({\hyperref[\detokenize{discovery/part06/06_03-use_a_workbench:global-variable}]{\sphinxcrossref{\DUrole{std,std-ref}{글로벌 변수(Global variable) 편집 기능}}}} 참조)

\item {} 
다른 워크벤치로 이동하기 위한 네비게이션 기능 ({\hyperref[\detokenize{discovery/part06/06_03-use_a_workbench:workbench-navigation}]{\sphinxcrossref{\DUrole{std,std-ref}{워크벤치 네비게이션}}}} 참조)

\end{itemize}


\subsubsection{글로벌 변수(Global variable) 편집 기능}
\label{\detokenize{discovery/part06/06_03-use_a_workbench:global-variable}}\label{\detokenize{discovery/part06/06_03-use_a_workbench:id9}}
어떤 구문이 반복적으로 사용되고 그 내용을 계속 바꿔가면서 쿼리를 실행해야 할 경우, 그 구문을 '글로벌 변수'로 지정해서 사용하면 편리합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[scale=0.7]{{workbench_global_variable}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{변수 타입:} 글로벌 변수 타입으로는 달력과 텍스트가 제공합니다.

\item {} 
\sphinxstylestrong{새 변수 추가:} 원하는 변수 종류를 선택한 뒤 새 변수 추가 버튼을 누릅니다. 쿼리 에디터 영역에 해당 글로벌 변수가 추가됩니다.

\item {} 
\sphinxstylestrong{이름:} 변수 이름을 입력합니다.

\item {} 
\sphinxstylestrong{변수 값:} 달력은 날짜를 선택, 텍스트는 값을 입력하여 사용할 수 있습니다.

\end{itemize}
\end{quote}


\subsubsection{워크벤치 네비게이션}
\label{\detokenize{discovery/part06/06_03-use_a_workbench:workbench-navigation}}\label{\detokenize{discovery/part06/06_03-use_a_workbench:id10}}
다른 워크벤치로 이동하는 기능을 제공합니다. 이동하기를 원하는 워크벤치를 클릭하면 해당 워크벤치로 이동합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workbench_navigation}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{워크벤치 검색:} 워크스페이스에 저장된 워크벤치를 검색합니다.

\item {} 
\sphinxstylestrong{워크벤치 목록:} 워크스페이스에 저장된 모든 워크벤치를 보여줍니다. 나열된 워크벤치 중 하나를 클릭하면 해당 워크벤치로 이동됩니다.

\end{itemize}
\end{quote}


\subsection{스키마 브라우저}
\label{\detokenize{discovery/part06/06_03-use_a_workbench:workbench-use-6}}\label{\detokenize{discovery/part06/06_03-use_a_workbench:id11}}
선택된 데이터베이스의 테이블 목록과 각 테이블에 속한 컬럼 및 레코드 정보를 확인할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workbench_schema_browser}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{컬럼:} 선택한 테이블의 모든 컬럼의 이름과 속성을 보여줍니다.

\item {} 
\sphinxstylestrong{인포메이션:} 선택한 테이블의 속성을 보여줍니다.

\item {} 
\sphinxstylestrong{데이터:} 선택한 테이블의 데이터를 보여줍니다. 최대 50건의 데이터만 조회할 수 있습니다.

\end{itemize}
\end{quote}


\chapter{데이터 프리퍼레이션}
\label{\detokenize{discovery/part07/index:id1}}\label{\detokenize{discovery/part07/index::doc}}
\sphinxstylestrong{데이터 프리퍼레이션}은 파일, 테이블 등의 데이터셋을 분석에 용이한 형태로 정제하기 위한 변형 룰들을 생성하여, 그 결과를 HDFS, Hive 등으로 저장하는 툴입니다.

\sphinxstylestrong{Metatron Discovery 데이터 프리퍼레이션의 장점}
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{data_preparation_overview_1}.png}
\end{figure}
\end{quote}

사용자는 위와 같이 GUI를 통해 Step-by-Step으로 변형 룰을 생성해낼 수 있습니다. 매 Step의 변형 결과가 데이터 분포도와 함께 메모리에 저장되기 때문에, 사용자는 이전 스텝 결과를 마우스 클릭만으로 쉽게 확인할 수 있을 뿐 아니라, 마치 텍스트 편집기를 쓰는 것처럼 \sphinxstylestrong{undo}, \sphinxstylestrong{redo} 등의 동작도 간단히 실행할 수 있습니다.

이러한 특징을 기반으로 데이터 프리퍼레이션 툴에서는 다음과 같은 장점을 활용할 수 있습니다.
\begin{itemize}
\item {} 
프로그래밍이나 데이터 처리에 익숙하지 않아도 작업자가 원하는 형태의 결과를 얻을 수 있습니다.

\item {} 
보통 변형 룰 하나를 추가하려면 프로그래밍을 하거나 최소한 SQL문을 작성해야하지만, 데이터 프리퍼레이션 GUI를 통한 \sphinxstylestrong{탐색적 변형}을 활용하면 몇 번의 마우스 클릭이나 타이핑만으로 간편하게 변형 룰을 만들어내어 시간을 크게 절약할 수 있습니다.

\item {} 
기본적으로 수반되는 데이터 변형들은 자동으로 수행합니다. 예를 들어, 명백히 숫자로 보이는 컬럼에 대해 알아서 형변환 룰을 적용해줍니다. 이것은 언제나 \sphinxstylestrong{undo} 또는 룰 삭제가 용이하기 때문에 가능한 것입니다.

\item {} 
다양한 형태의 데이터를 결합하여 원하는 형태로 바꿔놓을 수 있습니다(예: 기준 파일 + 팩트 테이블).

\item {} 
만들어 놓은 데이터 정제 결과를 다른 사람들과 공유함으로써, 물리적인 데이터를 주고 받는 부담을 줄여줍니다.

\item {} 
실제 데이터는 지우고 그것을 만드는 방법만 유지함으로써, 저장 공간을 아끼고 \sphinxstylestrong{ILM (Information Life Cycle)}을 줄일 수 있습니다. 다시 필요할 때 실제 데이터를 만들어내는 데에 부담이 줄어들기 때문입니다.

\end{itemize}

\sphinxstylestrong{Metatron Discovery 데이터 프리퍼레이션의 구조}
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{preparation_overview}.png}
\end{figure}
\end{quote}

위 그림과 같이 데이터 프리퍼레이션은 정제할 대상 데이터를 참조하는 \sphinxstylestrong{데이터셋}, 지정된 데이터셋의 변형 룰들을 정의하는 \sphinxstylestrong{데이터플로우}, 그리고 그러한 룰들에 의해 변형된 결과물을 출력하는 \sphinxstylestrong{데이터 스냅샷}으로 구성됩니다.


\section{데이터셋 만들기}
\label{\detokenize{discovery/part07/create_a_dataset:id1}}\label{\detokenize{discovery/part07/create_a_dataset::doc}}
\sphinxstylestrong{데이터셋}은 데이터 프리퍼레이션의 가장 기본이 되는 단위로서, 데이터 연산의 대상이 되는 개체를 가리킵니다. \sphinxstylestrong{Imported Dataset}과 \sphinxstylestrong{Wrangled Dataset}의 두 가지 종류로 존재합니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{Imported Dataset:} 변형 규칙이 적용되기 전의 원천 데이터 개체

\item {} 
\sphinxstylestrong{Wrangled Dataset:} 변형 규칙이 적용되어 분석 작업의 대상이 되는 데이터 개체

\end{itemize}

Wrangled Dataset은 변형 룰을 정의하는 \sphinxstylestrong{데이터플로우} 지정 과정에서 생성되는 것이며, 본 절차에서 생성되는 데이터셋은 Imported Dataset입니다.

데이터셋 메뉴는 메인 화면 좌측 패널에서 \sphinxstylestrong{MANAGEMENT} \textgreater{} \sphinxstylestrong{데이터 프리퍼레이션} \textgreater{} \sphinxstylestrong{데이터셋}을 통해 진입할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[scale=0.5]{{create_a_dataset_1}.png}
\end{figure}
\end{quote}

그런 다음 \sphinxstylestrong{데이터셋} 홈 화면 우측 상단에서 \sphinxstylestrong{+새로운 데이터셋 생성} 버튼을 클릭하면 새로운 데이터셋을 생성할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_dataset_2}.png}
\end{figure}
\end{quote}

데이터셋 생성 화면에 들어가면 대상 원천 데이터의 타입을 선택해야 합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[scale=0.5]{{create_a_dataset_3}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{파일:} 사용자가 소유한 파일을 가져오거나 URI(곧 지원 예정)를 이용하여 데이터셋을 생성합니다(자세한 절차는 {\hyperref[\detokenize{discovery/part07/create_a_dataset:create-a-dataset-of-file}]{\sphinxcrossref{\DUrole{std,std-ref}{파일 타입 데이터셋 생성하기}}}} 참조).

\item {} 
\sphinxstylestrong{Database:} 외부 데이터베이스의 접속 정보와 쿼리를 이용하여 데이터셋을 생성합니다(자세한 절차는 {\hyperref[\detokenize{discovery/part07/create_a_dataset:create-a-dataset-of-database}]{\sphinxcrossref{\DUrole{std,std-ref}{데이터베이스 타입 데이터셋 생성하기}}}} 참조).

\item {} 
\sphinxstylestrong{Staging DB:} Metatron 구동 시 설정된 Staging DB의 정보를 이용하여 데이터셋을 생성합니다(자세한 절차는 {\hyperref[\detokenize{discovery/part07/create_a_dataset:create-a-dataset-of-stagingdb}]{\sphinxcrossref{\DUrole{std,std-ref}{Staging DB 타입 데이터셋 생성하기}}}} 참조).

\end{itemize}

\begin{sphinxadmonition}{note}{참고:}
Staging DB는 ETL 프로세스에서 원활한 데이터 로딩을 위해 데이터를 임시 보관하는 클러스터 내 데이터베이스로서, 통상 Hive로 설정됩니다.
\end{sphinxadmonition}
\end{quote}


\subsection{파일 타입 데이터셋 생성하기}
\label{\detokenize{discovery/part07/create_a_dataset:create-a-dataset-of-file}}\label{\detokenize{discovery/part07/create_a_dataset:id2}}
사용자가 소유한 파일을 가져오거나 URI(곧 지원 예정)를 이용하여 데이터셋을 생성합니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
데이터 타입 선택 화면에서 \sphinxstylestrong{파일}을 선택합니다.

\item {} 
사용자 로컬 PC에서 데이터 소스로 사용할 파일을 가져옵니다. \sphinxstylestrong{Import} 버튼을 클릭하여 파일을 선택할 수도 있고 화면 상으로 파일을 끌어다 놓을 수도 있습니다. 파일을 가져왔으면 다음 버튼을 누릅니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_dataset_of_file_1}.png}
\end{figure}
\end{quote}

\item {} 
업로드 된 파일의 그리드 형태를 확인하고 컬럼 구분자를 지정합니다. 데이터가 바르게 출력되면 다음으로 넘어갑니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_dataset_of_file_2}.png}
\end{figure}
\end{quote}

\item {} 
생성할 데이터셋의 \sphinxstylestrong{이름}과 \sphinxstylestrong{설명}을 입력한 후 \sphinxstylestrong{완료} 버튼을 누릅니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_dataset_of_file_3}.png}
\end{figure}
\end{quote}

\item {} 
데이터셋 생성이 완료되면 데이터셋 목록 화면으로 자동으로 이동합니다. 방금 생성한 데이터셋을 확인할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_dataset_of_file_4}.png}
\end{figure}
\end{quote}

\end{enumerate}


\subsection{데이터베이스 타입 데이터셋 생성하기}
\label{\detokenize{discovery/part07/create_a_dataset:create-a-dataset-of-database}}\label{\detokenize{discovery/part07/create_a_dataset:id3}}
외부 데이터베이스의 접속 정보와 쿼리를 이용하여 데이터셋을 생성합니다.

데이터베이스 타입의 데이터셋을 생성하기 위해서는 선행적으로 데이터 커넥션이 생성되어 있어야 합니다. 자세한 절차는 {\hyperref[\detokenize{discovery/part02/data_connection:create-data-connection}]{\sphinxcrossref{\DUrole{std,std-ref}{데이터 커넥션 만들기}}}} 항목을 참조하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_dataset_of_database_1}.png}
\end{figure}
\end{quote}

해당 데이터 커넥션이 생성되었다면 다시 \sphinxstylestrong{MANAGEMENT} \textgreater{} \sphinxstylestrong{데이터 프리퍼레이션} \textgreater{} \sphinxstylestrong{데이터셋} \textgreater{} \sphinxstylestrong{+새로운 데이터셋 생성}을 통해 데이터 타입 선택 화면에 진입한 후, 다음의 절차를 진행합니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
데이터 타입 선택 화면에서 \sphinxstylestrong{Database}를 선택합니다.

\item {} 
해당 데이터 커넥션을 선택하고 \sphinxstylestrong{테스트} 버튼을 눌러 유효한 커넥션임을 확인합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_dataset_of_database_2}.png}
\end{figure}
\end{quote}

\item {} 
데이터를 선택합니다. 연결된 데이터베이스 계정에서 테이블을 선택할 수도 있고 쿼리문을 직접 작성할 수도 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_dataset_of_database_3}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{테이블:} 데이터베이스와 테이블명을 선택한 후 실제 저장될 데이터가 조회되면, 확인 후 \sphinxstylestrong{다음} 버튼을 누릅니다.

\item {} 
\sphinxstylestrong{쿼리:} 원하는 데이터를 가져올 수 있는 쿼리문을 직접 작성하고 \sphinxstylestrong{실행} 버튼을 클릭하면 하단에 데이터가 보여집니다. 데이터를 확인한 후 \sphinxstylestrong{다음} 버튼을 누르십시오.

\end{itemize}
\end{quote}

\item {} 
생성할 데이터셋의 \sphinxstylestrong{이름}과 \sphinxstylestrong{설명}을 입력한 후 \sphinxstylestrong{완료} 버튼을 누릅니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_dataset_of_database_5}.png}
\end{figure}
\end{quote}

\item {} 
데이터셋 생성이 완료되면 데이터셋 목록 화면으로 자동으로 이동합니다. 방금 생성한 데이터셋을 확인할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_dataset_of_database_6}.png}
\end{figure}
\end{quote}

\end{enumerate}


\subsection{Staging DB 타입 데이터셋 생성하기}
\label{\detokenize{discovery/part07/create_a_dataset:staging-db}}\label{\detokenize{discovery/part07/create_a_dataset:create-a-dataset-of-stagingdb}}
Metatron 구동 시 설정된 Staging DB의 정보를 이용하여 데이터셋을 생성합니다.

Staging DB 타입의 데이터셋은 데이터 커넥션을 지정할 필요가 없다는 것을 제외하면 데이터베이스 타입의 데이터셋과 동일합니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
데이터 타입 선택 화면에서 \sphinxstylestrong{Staging DB}를 선택합니다.

\item {} 
데이터를 선택합니다. 연결된 데이터베이스 계정에서 테이블을 선택할 수도 있고 쿼리문을 직접 작성할 수도 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_dataset_of_stagingdb_1}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{테이블:} 데이터베이스와 테이블명을 선택한 후 실제 저장될 데이터가 조회되면, 확인 후 \sphinxstylestrong{다음} 버튼을 누릅니다.

\item {} 
\sphinxstylestrong{쿼리:} 원하는 데이터를 가져올 수 있는 쿼리문을 직접 작성하고 \sphinxstylestrong{실행} 버튼을 클릭하면 하단에 데이터가 보여집니다. 데이터를 확인한 후 \sphinxstylestrong{다음} 버튼을 누르십시오.

\end{itemize}
\end{quote}

\item {} 
생성할 데이터셋의 \sphinxstylestrong{이름}과 \sphinxstylestrong{설명}을 입력한 후 \sphinxstylestrong{완료} 버튼을 누릅니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_dataset_of_stagingdb_3}.png}
\end{figure}
\end{quote}

\item {} 
데이터셋 생성이 완료되면 데이터셋 목록 화면으로 자동으로 이동합니다. 방금 생성한 데이터셋을 확인할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_dataset_of_stagingdb_4}.png}
\end{figure}
\end{quote}

\end{enumerate}


\section{데이터플로우 관리하기}
\label{\detokenize{discovery/part07/manage_dataflow:id1}}\label{\detokenize{discovery/part07/manage_dataflow::doc}}
\sphinxstylestrong{데이터플로우}는 \sphinxstylestrong{데이터셋}을 처리하는 단위입니다. 한 데이터플로우는 다수의 데이터셋들을 가져와 연관지어서 변형을 가할 수 있습니다.
다시 말해, 어떤 데이터셋이 변형 룰을 가지려면 반드시 한 데이터플로우에 속해야 하며, 그 안의 다른 데이터셋들과 join, union 등의 관계를 가질 수 있습니다.

아래와 같이 데이터플로우 상세 화면에서는 해당 데이터플로우에 속한 모든 데이터셋과 이들 간의 의존 관계, 그리고 각 데이터셋에 적용된 변형 룰들을 보여줍니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{add_datasets_1}.png}
\end{figure}
\end{quote}

아래 각 하위 단원에서는 이러한 데이터플로우를 정의하기 위해 \sphinxstylestrong{데이터셋을 추가}하고, \sphinxstylestrong{변형 룰들을 편집}하고, \sphinxstylestrong{변형 결과물을 데이터 스냅샷으로 출력}하는 과정을 살펴봅니다.

데이터플로우 메뉴는 메인 화면 좌측 패널에서 \sphinxstylestrong{MANAGEMENT} \textgreater{} \sphinxstylestrong{데이터 프리퍼레이션} \textgreater{} \sphinxstylestrong{데이터플로우}를 통해 진입할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics[scale=0.5]{{create_a_dataset_1}.png}
\end{figure}
\end{quote}


\subsection{데이터셋 추가하기}
\label{\detokenize{discovery/part07/add_datasets:id1}}\label{\detokenize{discovery/part07/add_datasets::doc}}
데이터플로우 정의의 첫 단계는 데이터셋을 추가하는 것입니다. 이를 위해서는 아래와 같은 두 가지 방법이 있습니다.
\begin{itemize}
\item {} 
{\hyperref[\detokenize{discovery/part07/add_datasets:dataflow-creation-first}]{\sphinxcrossref{\DUrole{std,std-ref}{빈 데이터플로우 생성 후 데이터셋 추가}}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/add_datasets:dataflow-from-dataset}]{\sphinxcrossref{\DUrole{std,std-ref}{데이터셋 상세 화면에서 바로 데이터플로우 생성}}}}

\end{itemize}


\subsubsection{빈 데이터플로우 생성 후 데이터셋 추가}
\label{\detokenize{discovery/part07/add_datasets:dataflow-creation-first}}\label{\detokenize{discovery/part07/add_datasets:id2}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{데이터플로우} 홈 화면 우측 상단에서 \sphinxstylestrong{데이터플로우 추가}를 클릭합니다.

\item {} 
생성할 데이터플로우의 \sphinxstylestrong{이름}과 \sphinxstylestrong{설명}을 입력하고 \sphinxstylestrong{완료}를 누르면, 빈 데이터플로우가 생성됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{add_datasets_2}.png}
\end{figure}
\end{quote}

\item {} 
화면 중앙에 위치한 \sphinxstylestrong{이 데이터플로우에 데이터셋 추가} 버튼을 누릅니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{add_datasets_3}.png}
\end{figure}
\end{quote}

\item {} 
추가할 데이터셋들을 선택합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{add_datasets_4}.png}
\end{figure}
\end{quote}

\item {} 
선택한 Imported Dataset과 그에 상응하는 Wrangled Dataset이 생성되었으면, \sphinxstylestrong{룰 편집} 버튼을 눌러 룰 편집을 실시합니다(자세한 절차는 {\hyperref[\detokenize{discovery/part07/edit_rules::doc}]{\sphinxcrossref{\DUrole{doc}{룰 편집}}}} 참조)
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{add_datasets_5}.png}
\end{figure}
\end{quote}

\end{enumerate}


\subsubsection{데이터셋 상세 화면에서 바로 데이터플로우 생성}
\label{\detokenize{discovery/part07/add_datasets:dataflow-from-dataset}}\label{\detokenize{discovery/part07/add_datasets:id3}}
데이터셋 상세 화면에서 \sphinxstylestrong{이 데이터셋으로 새로운 데이터플로우 생성} 버튼을 누르면, 자동으로 데이터플로우를 만들고 \sphinxstylestrong{룰 편집} 직전의 단계까지 진행합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{add_datasets_6}.png}
\end{figure}

\begin{sphinxadmonition}{note}{참고:}
데이터플로우의 이름은 데이터셋 이름을 기반해서 자동으로 지어집니다.
\end{sphinxadmonition}
\end{quote}


\subsection{룰 편집}
\label{\detokenize{discovery/part07/edit_rules:id1}}\label{\detokenize{discovery/part07/edit_rules::doc}}
데이터 프리퍼레이션에서 가장 핵심적인 작업은 데이터를 변형(주로 정제)하는 룰(rule)을 만들어내는 것입니다.
이 변형 룰과 입출력 명세를 합쳐서 우리는 실제 데이터에 적용하거나, 또 비슷한 다른 데이터에 적용하거나, 이런 작업들을 스케쥴링합니다.

이제 룰을 만들고, 결과를 확인하고, 룰을 다시 변경하거나 삭제하는 일에 대한 설명을 하겠습니다.

먼저 룰 편집 화면의 구성은 다음과 같습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{edit_rules_1}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
컬럼 타입, 이름, 메뉴 버튼

\item {} 
룰 간편 생성을 위한 메뉴

\item {} 
적용된 룰 리스트 및 중간 삽입 버튼 (룰 사이에 마우스를 갖다대면 나옴)

\item {} 
Undo, redo가 가능한 경우 활성화

\item {} 
룰 세부 내용 입력 패널

\item {} 
컬럼 값 분포 및 distinct count, type mismatch 또는 null value 관련 정보 등

\end{enumerate}
\end{quote}


\subsubsection{룰 생성하기}
\label{\detokenize{discovery/part07/edit_rules:id2}}

\paragraph{컬럼 헤더 메뉴를 이용하는 방법}
\label{\detokenize{discovery/part07/edit_rules:id3}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
컬럼 헤더를 클릭해서 대상 컬럼을 고릅니다.
\begin{quote}
\begin{itemize}
\item {} 
기능 키를 이용해서 다수의 컬럼을 고를 수 있습니다.

\item {} 
OS에 따라 \textasciicircum{} 또는 ⌘ 키를 누른 채 클릭을 하면 해당 컬럼이 선택/해제됩니다. (토글)

\item {} 
Shift 키를 누른 채 클릭을 하면 범위가 선택됩니다.

\end{itemize}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{edit_rules_2}.png}
\end{figure}
\end{quote}

\item {} 
선택된 컬럼 중 하나의 헤더에서 \sphinxincludegraphics{{header_menu}.png} 아이콘을 클릭해서 헤더 메뉴를 연 후, 변환 명령을 선택합니다.
\begin{quote}
\begin{itemize}
\item {} 
이 중에서 \sphinxstylestrong{drop}, \sphinxstylestrong{settype} 등은 즉시 실행됩니다.

\end{itemize}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{edit_rules_3}.png}
\end{figure}
\end{quote}

\item {} 
추가 입력이 필요한 경우, 하단 명령 입력 패널을 통해 내용을 입력한 후 \sphinxstylestrong{추가} 버튼을 누릅니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{edit_rules_4}.png}
\end{figure}
\end{quote}

\item {} 
몇몇 룰의 경우에는 분포도 막대를 선택해서 명령을 수행할 수도 있습니다.
\begin{quote}
\begin{itemize}
\item {} 
분포도의 막대를 클릭하면 해당 범위를 조건으로 필터링 등을 실시할 수 있습니다(토글).

\item {} 
Type mismatch, null value 그래프를 클릭해서 해당 값들에 대해 조건을 걸 수도 있습니다.

\end{itemize}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{edit_rules_13}.png}
\end{figure}
\end{quote}

\end{enumerate}


\paragraph{하단 명령 입력 패널을 이용하는 방법}
\label{\detokenize{discovery/part07/edit_rules:id4}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
화면 하단 명령 입력 패널에서 변환 룰(커맨드)을 선택합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{edit_rules_5}.png}
\end{figure}
\end{quote}

\item {} 
추가 입력이 필요한 경우 내용을 더 입력한 후 \sphinxstylestrong{추가} 버튼을 누릅니다.
\begin{quote}
\begin{itemize}
\item {} 
대상 컬럼을 고르는 입력 패널이 있지만, 이 경우에도 컬럼 헤더를 클릭해서 컬럼을 지정할 수도 있습니다.

\end{itemize}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{edit_rules_6}.png}
\end{figure}
\end{quote}

\end{enumerate}


\paragraph{룰 리스트 중간에 삽입하는 방법}
\label{\detokenize{discovery/part07/edit_rules:id5}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
화면 우측의 변환 룰 리스트에서 새 룰을 삽입하고자 하는 룰 경계에 마우스를 갖다대면 \sphinxstylestrong{+ 룰 추가} 버튼이 생깁니다. 이 버튼을 누르십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{edit_rules_7}.png}
\end{figure}
\end{quote}

\item {} 
화면 하단 명령 입력 패널에서 변환 룰(커맨드)를 선택하고 추가 내용을 입력한 후, \sphinxstylestrong{추가} 버튼을 누릅니다.
\begin{quote}
\begin{itemize}
\item {} 
이렇게 룰을 중간에 삽입하면, 삽입된 위치 이후의 모든 룰이 영향을 받습니다.

\item {} 
이 때 정상적으로 수행될 수 없는 룰이 생기면, 빨간 색으로 표시되고 해당 스텝은 이전 스텝의 결과를 그대로 갖게 됩니다.

\end{itemize}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{edit_rules_6}.png}
\end{figure}
\end{quote}

\end{enumerate}


\subsubsection{생성된 룰 편집하기}
\label{\detokenize{discovery/part07/edit_rules:id6}}

\paragraph{룰 수정}
\label{\detokenize{discovery/part07/edit_rules:id7}}\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
화면 우측의 변환 룰 리스트에서 수정하고자 하는 룰 위에 마우스를 갖다대면 \sphinxincludegraphics{{icon_edit1}.png} 버튼이 생깁니다. 이 버튼을 누르십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{edit_rules_8}.png}
\end{figure}
\end{quote}

\item {} 
화면 하단 명령 입력 패널에서 변환 룰 내용을 수정한 후, \sphinxstylestrong{완료} 버튼을 누릅니다.
\begin{quote}
\begin{itemize}
\item {} 
룰이 수정되면 그 이후의 모든 룰이 영향을 받습니다.

\end{itemize}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{edit_rules_12}.png}
\end{figure}
\end{quote}

\end{enumerate}


\paragraph{룰 삭제}
\label{\detokenize{discovery/part07/edit_rules:id8}}
화면 우측의 변환 룰 리스트에서 삭제하고자 하는 룰 위에 마우스를 갖다대면 \sphinxincludegraphics{{icon_delete}.png} 버튼이 생깁니다. 이 버튼을 누르십시오.
\begin{quote}
\begin{itemize}
\item {} 
선택한 룰이 제거되면 그 이후 모든 룰이 모두 영향을 받습니다.

\end{itemize}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{edit_rules_10}.png}
\end{figure}
\end{quote}


\paragraph{undo 및 redo}
\label{\detokenize{discovery/part07/edit_rules:undo-redo}}
화면 우측의 변환 룰 리스트 상단에는 \sphinxstylestrong{undo} 및 \sphinxstylestrong{redo} 동작을 수행할 수 있는 아이콘이 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{edit_rules_11}.png}
\end{figure}
\end{quote}

어떤 명령 수행 후, 직전의 상태로 되돌리고자 할 때엔 \sphinxincludegraphics{{icon_undo}.png} 버튼을 클릭하십시오.
\begin{itemize}
\item {} 
데이터셋에 대한 변형(룰 생성, 수정, 삭제 모두 포함)이 직전의 상태로 되돌아갑니다.

\item {} 
해당 변형의 영향을 받은 다른 모든 룰도 직전의 상태가 됩니다.

\end{itemize}

다시 그 명령을 수행하고자 할 때엔 \sphinxincludegraphics{{icon_redo}.png} 버튼을 클릭하십시오.
\begin{itemize}
\item {} 
해당 명령을 그대로 다시 수행하는 것보다는 \sphinxincludegraphics{{icon_redo}.png}를 이용하는 것이 더 빠릅니다. 그 결과가 메모리에 저장되어있기 때문입니다.

\end{itemize}


\subsection{룰의 종류}
\label{\detokenize{discovery/part07/rule_kinds:id1}}\label{\detokenize{discovery/part07/rule_kinds::doc}}
본 절에서는 각 룰을 다음과 같은 항목으로 구분하여 설명합니다.
\begin{itemize}
\item {} 
룰 이름

\item {} 
필수 인자

\item {} 
선택 인자

\item {} 
상세 설명

\item {} 
주의사항

\end{itemize}

현재 데이터 프리퍼레이션에서 지원하는 룰 종류는 다음과 같습니다.
\begin{itemize}
\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:drop}]{\sphinxcrossref{drop}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:header}]{\sphinxcrossref{header}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:settype}]{\sphinxcrossref{settype}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:setformat}]{\sphinxcrossref{setformat}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:rename}]{\sphinxcrossref{rename}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:keep}]{\sphinxcrossref{keep}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:delete}]{\sphinxcrossref{delete}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:replace}]{\sphinxcrossref{replace}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:set}]{\sphinxcrossref{set}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:derive}]{\sphinxcrossref{derive}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:split}]{\sphinxcrossref{split}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:merge}]{\sphinxcrossref{merge}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:extract}]{\sphinxcrossref{extract}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:countpattern}]{\sphinxcrossref{countpattern}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:nest}]{\sphinxcrossref{nest}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:unnest}]{\sphinxcrossref{unnest}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:flatten}]{\sphinxcrossref{flatten}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:aggregate}]{\sphinxcrossref{aggregate}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:pivot}]{\sphinxcrossref{pivot}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:unpivot}]{\sphinxcrossref{unpivot}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:join}]{\sphinxcrossref{join}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:union}]{\sphinxcrossref{union}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:window}]{\sphinxcrossref{window}}}

\end{itemize}

이러한 룰과 더불어 각종 수식 함수를 제공함으로써, 데이터 프리퍼레이션은 일반적인 데이터 정제에 필요한 대부분의 기능들을 지원하고 있습니다.


\subsubsection{drop}
\label{\detokenize{discovery/part07/rule_kinds:drop}}
필수 인자
\begin{itemize}
\item {} 
컬럼: 대상 컬럼 리스트

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
선택된 컬럼들을 삭제합니다.

\end{itemize}


\subsubsection{header}
\label{\detokenize{discovery/part07/rule_kinds:header}}
필수 인자: 컬럼명을 담고 있는 행 번호 (1-base)

상세 설명
\begin{itemize}
\item {} 
지정된 행의 내용을 컬럼명으로 설정합니다.

\item {} 
첫 행에 컬럼명이 있는 CSV 파일을 읽어들일 때에 유용합니다.

\item {} 
특별한 설정이 없는 한, 데이터 프리퍼레이션은 자동으로 header를 수행합니다. 자동 적용된 header의 결과를 원치 않는 경우 해당 룰을 삭제하면 되지만, 보통 그런 일은 흔치 않습니다.

\end{itemize}


\subsubsection{settype}
\label{\detokenize{discovery/part07/rule_kinds:settype}}
필수 인자
\begin{itemize}
\item {} 
컬럼: 대상 컬럼 리스트

\item {} 
새로운 타입: Long, Double, String, Boolean, Timestamp 중 택 1

\end{itemize}

선택 인자
\begin{itemize}
\item {} 
포멧 지정: Timestamp의 경우 format string (Joda time)

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
선택된 컬럼들의 타입을 바꿉니다.

\item {} 
Type mismatch가 발생해도 룰은 성공하며, type mismatch는 이후 따로 해결해주어야 합니다.

\end{itemize}


\subsubsection{setformat}
\label{\detokenize{discovery/part07/rule_kinds:setformat}}
필수 인자
\begin{itemize}
\item {} 
컬럼: 대상 컬럼 리스트

\item {} 
포멧 지정: Jodatime의 포맷 스트링

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
Timestamp 컬럼의 화면 표시 형식을 바꿉니다.

\item {} 
대상 컬럼이 반드시 Timestamp 타입이어야 합니다.

\end{itemize}

주의사항
\begin{itemize}
\item {} 
포멧 지정 입력창은 아래처럼 입력에 따라 제시되는 리스트가 변합니다. 원하는 포멧을 앞에서부터 치다보면 리스트에 나오는 후보가 점점 좁혀집니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_setformat_1}.png}
\end{figure}
\end{quote}

\end{itemize}


\subsubsection{rename}
\label{\detokenize{discovery/part07/rule_kinds:rename}}
필수 인자
\begin{itemize}
\item {} 
컬럼: 대상 컬럼 (1개)

\item {} 
새로운 컬럼 이름: 새로운 이름

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
선택된 컬럼의 이름을 변경합니다.

\item {} 
2개 이상의 컬럼들에 대해 한번에 rename을 수행하고자 할 때엔 하단 명령 입력창에 있는 \sphinxstylestrong{전체 컬럼 변경} 버튼을 클릭하면 다음과 같은 팝업창이 뜹니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_rename_1}.png}
\end{figure}
\end{quote}

\end{itemize}


\subsubsection{keep}
\label{\detokenize{discovery/part07/rule_kinds:keep}}
필수 인자
\begin{itemize}
\item {} 
조건: Boolean이 결과로 나오는 조건식

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
조건식을 참으로 하는 행만 남기고 나머지 행을 지웁니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_keep_1}.png}
\end{figure}
\end{quote}

\end{itemize}


\subsubsection{delete}
\label{\detokenize{discovery/part07/rule_kinds:delete}}
필수 인자
\begin{itemize}
\item {} 
조건: Boolean이 결과로 나오는 조건식

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
조건식을 참으로 하는 행을 모두 지웁니다. {\hyperref[\detokenize{discovery/part07/rule_kinds:keep}]{\sphinxcrossref{keep}}}과 정반대로 동작합니다.

\end{itemize}


\subsubsection{replace}
\label{\detokenize{discovery/part07/rule_kinds:replace}}
\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_replace_1}.png}
\end{figure}

필수 인자
\begin{itemize}
\item {} 
컬럼: 대상 컬럼 리스트

\item {} 
패턴: 갈아치울 대상 문자열 패턴
\begin{itemize}
\item {} 
상수 문자열인 경우: \sphinxcode{\sphinxupquote{'}}로 감싸져 있는 경우 (\sphinxcode{\sphinxupquote{'seoul'}}, \sphinxcode{\sphinxupquote{'서울'}}, \sphinxcode{\sphinxupquote{'서울 특별시'}} 등)

\item {} 
정규식인 경우: \sphinxcode{\sphinxupquote{/}}로 감싸져 있는 경우 (\sphinxcode{\sphinxupquote{/{[} ,\_{]}+/}}, \sphinxcode{\sphinxupquote{/\textbackslash{}s+\$/}} 등)

\end{itemize}

\item {} 
새로운 값: 새롭게 놓일 문자열 수식
\begin{itemize}
\item {} 
상수 문자열

\item {} 
정규식의 그룹을 이용한 문자열 수식: \sphinxcode{\sphinxupquote{\$1\_\$2\_\$3}} 등

\end{itemize}

\end{itemize}

선택 인자
\begin{itemize}
\item {} 
다음 문자 사이 무시: 이 안에 입력된 문자 사이 내용에 대해서는 치환을 하지 않습니다.

\item {} 
모든 항목 일치 여부: 단어의 모든 문자가 일치해야하는지 여부

\item {} 
대소문자 구분 무시: 대소문자를 동일하게 취급할지 여부

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
선택된 컬럼들에 대하여, 문자열 변환을 수행합니다.

\end{itemize}

주의사항
\begin{itemize}
\item {} 
\sphinxstylestrong{새로운 값}에는 \sphinxcode{\sphinxupquote{'}}이나 \sphinxcode{\sphinxupquote{/}}를 사용하지 않습니다.

\item {} 
\sphinxstylestrong{새로운 값}에 다른 컬럼의 값을 이용할 수 없습니다. replace는 순수히 해당 컬럼 내용안에서의 문자열 변환입니다. (cf. {\hyperref[\detokenize{discovery/part07/rule_kinds:set}]{\sphinxcrossref{set}}} 룰)

\end{itemize}


\subsubsection{set}
\label{\detokenize{discovery/part07/rule_kinds:set}}
\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_set_1}.png}
\end{figure}

필수 인자
\begin{itemize}
\item {} 
컬럼: 대상 컬럼 리스트

\item {} 
수식: 대상 컬럼의 값이 될 수식. 다른 컬럼값을 참조할 수 있습니다. (cf. {\hyperref[\detokenize{discovery/part07/rule_kinds:replace}]{\sphinxcrossref{replace}}} 룰)
\begin{itemize}
\item {} 
여러 컬럼을 대상으로 하는 경우, \sphinxcode{\sphinxupquote{\$col}}이라고 쓰면 각 컬럼에 대해 변환을 할 때, 그 대상 컬럼을 가리키도록 치환됩니다.

\item {} 
즉, \sphinxcode{\sphinxupquote{column1}}, \sphinxcode{\sphinxupquote{column2}}에 대해 set 명령을 사용하는 경우, \sphinxcode{\sphinxupquote{column1}}에 대해 변환을 할 때엔 \sphinxcode{\sphinxupquote{\$col}}이 \sphinxcode{\sphinxupquote{column1}}이 되고, \sphinxcode{\sphinxupquote{column2}}에 대해 변환을 할 때엔 \sphinxcode{\sphinxupquote{\$col}}이 \sphinxcode{\sphinxupquote{column2}}가 됩니다.

\end{itemize}

\end{itemize}

선택 인자
\begin{itemize}
\item {} 
다음 조건에서만 수행
\begin{itemize}
\item {} 
이 조건을 만족하는 행에 대해서만 set 룰을 적용합니다.

\item {} 
SQL문에서 \sphinxcode{\sphinxupquote{WHERE}}과 같다고 생각하면 됩니다.

\end{itemize}

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
해당 컬럼의 값을 주어진 수식의 결과값으로 대체합니다.

\item {} 
복잡한 수식을 사용하는 경우 \sphinxstylestrong{고급 편집기}를 클릭하면 다음과 같은 팝업창이 뜹니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_set_2}.png}
\end{figure}
\end{quote}

\end{itemize}

\sphinxstylestrong{고급 편집기}를 활용하면 컬럼의 리스트와 함수의 리스트 및 각 설명, 예시를 보면서 넓은 창에서 수식을 편집할 수 있고, 실제로 룰을 실행하기 전에 수식의 유효성을 체크해볼 수 있습니다.


\subsubsection{derive}
\label{\detokenize{discovery/part07/rule_kinds:derive}}
필수 인자
\begin{itemize}
\item {} 
수식: 새로운 컬럼의 값이 될 수식. {\hyperref[\detokenize{discovery/part07/rule_kinds:set}]{\sphinxcrossref{set}}} 룰과 마찬가지로 다른 컬럼값을 참조할 수 있습니다.

\item {} 
새로운 컬럼 이름

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:set}]{\sphinxcrossref{set}}} 룰과 비슷하지만, 어떤 컬럼의 값을 대체하는 것이 아니라 새로운 컬럼을 만들어냅니다.

\end{itemize}

주의사항
\begin{itemize}
\item {} 
수식에 등장하는 컬럼 중에 제일 마지막 컬럼 뒤로 삽입됩니다.

\end{itemize}


\subsubsection{split}
\label{\detokenize{discovery/part07/rule_kinds:split}}
필수 인자
\begin{itemize}
\item {} 
컬럼: 대상 컬럼 리스트

\item {} 
패턴: split의 기준이 되는 문자열 수식. {\hyperref[\detokenize{discovery/part07/rule_kinds:replace}]{\sphinxcrossref{replace}}} 룰과 같이 정규식을 허용합니다.

\item {} 
횟수: 몇 개의 컬럼으로 나눌 것인지 여부입니다.

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
각 행에 대해 주어진 \sphinxstylestrong{횟수} - 1 만큼 split을 합니다.

\item {} 
컬럼 내용에 패턴이 더 이상 없을 경우 \sphinxtitleref{null} 값을 가진 컬럼을 만들어냅니다.

\end{itemize}

주의사항
\begin{itemize}
\item {} 
\sphinxstylestrong{횟수}에 해당하는 개수의 컬럼이 생기게 된다는 것에 유의하세요.

\end{itemize}


\subsubsection{merge}
\label{\detokenize{discovery/part07/rule_kinds:merge}}
필수 인자
\begin{itemize}
\item {} 
컬럼: 대상 컬럼 리스트

\item {} 
구분자: 컬럼들을 이을 상수 문자열

\item {} 
새로운 컬럼 이름

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
대상 컬럼들을 \sphinxstylestrong{구분자}로 이어서 새로운 컬럼을 만듭니다.

\end{itemize}

주의사항
\begin{itemize}
\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:replace}]{\sphinxcrossref{replace}}} 룰도 마찬가지지만, \sphinxcode{\sphinxupquote{'}} 로 감싸는 것은 생략할 수 있습니다. 즉, \sphinxcode{\sphinxupquote{/}} 로도, \sphinxcode{\sphinxupquote{'}} 로도 감싸지지 않는 문자열이 입력되었을 시, 알아서 \sphinxcode{\sphinxupquote{'}} 로 감싸서 전달되게 되어있습니다.

\end{itemize}


\subsubsection{extract}
\label{\detokenize{discovery/part07/rule_kinds:extract}}
필수 인자
\begin{itemize}
\item {} 
컬럼: 대상 컬럼 리스트

\item {} 
패턴: 추출할 문자열 패턴. {\hyperref[\detokenize{discovery/part07/rule_kinds:replace}]{\sphinxcrossref{replace}}} 룰과 마찬가지로 정규식을 허용합니다.

\item {} 
횟수: 추출할 횟수

\end{itemize}

선택 인자
\begin{itemize}
\item {} 
다음 문자 사이 무시: 이 안에 입력된 문자 사이 내용에 대해서는 치환을 하지 않습니다.

\item {} 
대소문자 구분 무시: 대소문자를 동일하게 취급할지 여부

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
패턴에 매치되는 내용으로 새로운 컬럼을 만듭니다.

\end{itemize}

주의사항
\begin{itemize}
\item {} 
여러 개의 대상 컬럼이 있는 경우, 추출의 결과는 각 컬럼의 뒤로 붙습니다.

\end{itemize}


\subsubsection{countpattern}
\label{\detokenize{discovery/part07/rule_kinds:countpattern}}
필수 인자
\begin{itemize}
\item {} 
컬럼: 대상 컬럼 리스트

\item {} 
패턴: 찾아낼 문자열 패턴. {\hyperref[\detokenize{discovery/part07/rule_kinds:replace}]{\sphinxcrossref{replace}}} 룰과 마찬가지로 정규식을 허용합니다.

\end{itemize}

선택 인자
\begin{itemize}
\item {} 
다음 문자 사이 무시: 이 안에 입력된 문자 사이 내용에 대해서는 치환을 하지 않습니다.

\item {} 
대소문자 구분 무시: 대소문자를 동일하게 취급할지 여부

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
패턴에 매치되는 내용이 몇 군데에 있는지 세어서, 그 숫자로 새 컬럼을 만듭니다.

\item {} 
{\hyperref[\detokenize{discovery/part07/rule_kinds:extract}]{\sphinxcrossref{extract}}}와 상당히 비슷합니다. 내용을 추출하는 것이 아니라, 그 숫자를 세는 것만 다를 뿐입니다.

\end{itemize}

주의사항
\begin{itemize}
\item {} 
여러 개의 대상 컬럼이 있는 경우, 추출의 결과는 각각 컬럼의 뒤로 붙습니다.

\end{itemize}


\subsubsection{nest}
\label{\detokenize{discovery/part07/rule_kinds:nest}}
필수 인자
\begin{itemize}
\item {} 
컬럼: 대상 컬럼 리스트

\item {} 
타입: Map 또는 Array

\item {} 
새로운 컬럼 이름

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
대상 컬럼을 주어진 타입으로 묶습니다.

\item {} 
다음은 각각 Array, Map으로 묶여진 경우입니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_nest_1}.png}
\end{figure}
\end{quote}

\end{itemize}


\subsubsection{unnest}
\label{\detokenize{discovery/part07/rule_kinds:unnest}}
\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_unnest_1}.png}
\end{figure}

필수 인자
\begin{itemize}
\item {} 
컬럼: 대상 컬럼 (1개)

\item {} 
선택할 요소: Array의 경우 \sphinxstyleemphasis{0-base} index, Map의 경우 key값

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
Array 또는 Map에서 지정된 요소를 빼서 새 컬럼으로 만듭니다.

\end{itemize}

주의사항
\begin{itemize}
\item {} 
대상 컬럼은 반드시 Array 또는 Map 타입이어야 합니다.

\end{itemize}


\subsubsection{flatten}
\label{\detokenize{discovery/part07/rule_kinds:flatten}}
필수 인자
\begin{itemize}
\item {} 
컬럼: 대상 컬럼 (1개)

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
Array의 각각 원소를 해당 컬럼의 값으로 삼는 행을 만들어냅니다.

\end{itemize}

주의사항
\begin{quote}
\begin{itemize}
\item {} 
대상 컬럼은 반드시 Array 타입이어야 합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_flatten_1}.png}
\end{figure}
\end{quote}

\end{itemize}

위와 같이 Array 컬럼에 4개의 원소가 있는 경우, 각 원소의 값에 대해 1개씩 행이 생깁니다. 이 때 대상 Array 컬럼을 제외한 모든 컬럼들의 값은 동일하게 됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_flatten_2}.png}
\end{figure}
\end{quote}
\end{quote}


\subsubsection{aggregate}
\label{\detokenize{discovery/part07/rule_kinds:aggregate}}
\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_aggregate_1}.png}
\end{figure}

필수 인자
\begin{itemize}
\item {} 
수식: Aggregation 함수 리스트

\item {} 
그룹화 기준: Group By에 쓰일 컬럼 리스트

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
그룹화 기준 컬럼들 각 조합에 대해 Group By 연산을 수행한 결과를 새로운 컬럼으로 추가합니다.

\item {} 
각 수식 당 한 컬럼씩 생깁니다. 예를 들어, 평균값과 카운트를 수식으로 지정하였을 경우, 2개의 컬럼이 생깁니다.

\item {} 
현재 지원하는 Aggregation 함수는 다음과 같습니다.
\begin{quote}
\begin{itemize}
\item {} 
count()

\item {} 
sum(\sphinxstyleemphasis{colname})

\item {} 
avg(\sphinxstyleemphasis{colname})

\item {} 
min(\sphinxstyleemphasis{colname})

\item {} 
max(\sphinxstyleemphasis{colname})

\end{itemize}

주의사항
\end{quote}

\item {} 
샘플링된 결과에 대해서만 연산을 수행합니다. 때문에 전체 데이터에 대한 결과, 즉 스냅샷은 달라질 수 있습니다.

\item {} 
count함수 사용시 \sphinxcode{\sphinxupquote{()}} 를 꼭 붙여야 하는 것에 유의하십시오.

\item {} 
count(\sphinxstyleemphasis{colname})은 현재 지원하지 않습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_aggregate_2}.png}
\end{figure}
\end{quote}

\end{itemize}


\subsubsection{pivot}
\label{\detokenize{discovery/part07/rule_kinds:pivot}}
\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_pivot_1}.png}
\end{figure}

필수 인자
\begin{itemize}
\item {} 
컬럼: 피봇 대상 컬럼 리스트

\item {} 
수식: 컬럼의 값이 될 수식 리스트 (Aggregation 함수만 가능)

\item {} 
그룹화 기준: Group By에 쓰일 컬럼 리스트

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
대상 컬럼들과 그룹화 기준 컬럼들 각 조합에 대해 Group By 연산을 수행하고, 그 결과를 새로운 컬럼값으로 하는 데이터셋을 만듭니다.

\item {} 
각 수식에 대해 컬럼 세트들이 생깁니다. 예를 들어, 평균값과 카운트를 수식으로 지정하였을 경우, 피봇 대상 컬럼들의 값이 결국 10개의 그룹으로 나뉠 경우, 20개의 컬럼이 생겨나게 됩니다.

\end{itemize}

주의사항
\begin{itemize}
\item {} 
최소 2개의 컬럼에 대한 복합 Group By를 할 때에 사용됩니다. (피봇 대상 1개, 그룹화 기준 1개)

\item {} 
일반적으로 컬럼명이 길어지기 때문에, 뒤이어 \sphinxstylestrong{전체 rename}을 필요로하는 경우가 많습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_pivot_2}.png}
\end{figure}
\end{quote}

\end{itemize}


\subsubsection{unpivot}
\label{\detokenize{discovery/part07/rule_kinds:unpivot}}
\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_unpivot_1}.png}
\end{figure}

필수 인자
\begin{itemize}
\item {} 
컬럼: 컬럼값으로 내릴 대상 컬럼들 리스트

\item {} 
그룹 수: 결과 컬럼 숫자 (기본적으로 1)

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
선택된 컬럼들에 대해 컬럼 이름과 컬럼의 값을 내용으로 하는 컬럼 2개를 만듭니다. (그룹 수가 1인 경우)

\item {} 
그룹 수가 선택된 컬럼 숫자와 같은 경우, 각 컬럼 이름과 값에 해당하는 컬럼들을 만듭니다. 즉, 10개 컬럼에 대해 그룹 수 10으로 unpivot을 하면, 총 20개 컬럼이 생깁니다.

\end{itemize}

주의사항
\begin{itemize}
\item {} 
그룹 수가 대상 컬럼 수의 약수인 경우는 곧 지원할 예정입니다.
\begin{quote}

\textless{}그룹 수가 1인 경우\textgreater{}
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_unpivot_2}.png}
\end{figure}
\end{quote}

\textless{}그룹 수가 컬럼 수와 같은 경우\textgreater{}
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_unpivot_3}.png}
\end{figure}
\end{quote}
\end{quote}

\end{itemize}


\subsubsection{join}
\label{\detokenize{discovery/part07/rule_kinds:join}}
\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_join_1}.png}
\end{figure}

join은 다른 룰들과는 달리, 별도의 팝업창을 갖습니다.

필수 인자 (팝업에서 선택하거나 입력)
\begin{itemize}
\item {} 
join 대상 데이터셋: 같은 데이터플로우 내의 Wrangled 데이터셋

\item {} 
join 결과로 나올 컬럼들 (토글)

\item {} 
join 키: 여러 개 입력 가능

\item {} 
join 타입: 현재 내부조인만 지원

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
대상 데이터셋과 연결해서 컬럼들을 만들어 냅니다.

\item {} 
기본적으로 관계형 데이터베이스의 \sphinxcode{\sphinxupquote{join}}과 같습니다.

\item {} 
\sphinxstylestrong{결과보기} 버튼으로 실제 룰적용 전에 join 결과를 볼 수 있습니다.

\end{itemize}

주의사항
\begin{itemize}
\item {} 
결과로 나올 컬럼에 join 키가 꼭 포함되어있어야 합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_join_2}.png}
\end{figure}
\end{quote}

\end{itemize}


\subsubsection{union}
\label{\detokenize{discovery/part07/rule_kinds:union}}
\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_union_1}.png}
\end{figure}

union 역시 {\hyperref[\detokenize{discovery/part07/rule_kinds:join}]{\sphinxcrossref{join}}}처럼 별도의 팝업창을 갖습니다.

필수 인자(팝업에서 선택)
\begin{itemize}
\item {} 
union 대상 데이터셋: 다수 선택 가능

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
지정된 데이터셋의 내용도 함께 처리합니다.

\item {} 
기본적으로 관계형 데이터베이스의 \sphinxcode{\sphinxupquote{union all}}과 같습니다.

\end{itemize}

주의사항
\begin{itemize}
\item {} 
대상 데이터셋은 union을 수행하는 데이터셋과 컬럼명과 타입, 그리고 컬럼 개수가 일치해야합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_union_2}.png}
\end{figure}
\end{quote}

\end{itemize}


\subsubsection{window}
\label{\detokenize{discovery/part07/rule_kinds:window}}
\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_window_1}.png}
\end{figure}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{rule_kinds_window_2}.png}
\end{figure}

필수 인자
\begin{itemize}
\item {} 
수식: Window 함수 리스트

\item {} 
그룹화 기준: 이 그룹안에서 행의 순서가 만들어짐. 없으면 그냥 전체적으로 정렬 기준 적용

\item {} 
정렬 기준: 이 컬럼의 순서로 전후 관계가 만들어짐. 없으면 그냥 데이터가 입력되는 순서

\end{itemize}

상세 설명
\begin{itemize}
\item {} 
앞의 행, 뒤의 행의 내용을 토대로 수식을 계산해서 컬럼값을 생성합니다.

\item {} 
그룹화 기준내에서 정렬 기준으로 순서를 정합니다.
\begin{itemize}
\item {} 
예를 들어, 위의 예시에서는 주(state)별로 앞뒤 3개씩의 행을 포함해서 평균값을 계산합니다.

\item {} 
화면상에서는 바로 앞에 보인다고 해도, 주가 같지 않으면 더 앞의 행을 보게됩니다.

\end{itemize}

\item {} 
현재 지원하는 Window 함수는 다음과 같습니다.
\begin{itemize}
\item {} 
row\_number()

\item {} 
lead(\sphinxstyleemphasis{colname}, \sphinxstyleemphasis{int})

\item {} 
lag(\sphinxstyleemphasis{colname}, \sphinxstyleemphasis{int})

\item {} 
rolling\_sum(\sphinxstyleemphasis{colname}, \sphinxstyleemphasis{int}, \sphinxstyleemphasis{int})

\item {} 
rolling\_avg(\sphinxstyleemphasis{colname}, \sphinxstyleemphasis{int}, \sphinxstyleemphasis{int})

\end{itemize}

\item {} 
Window 함수와 더불어 Aggregation 함수도 사용할 수 있습니다.

\end{itemize}

주의사항
\begin{itemize}
\item {} 
Window 함수 사용시, 인자 수가 부족하거나 한 상황에 대해 적절한 에러메시지가 제공되지 않습니다. 유의하시기 바랍니다.

\end{itemize}


\subsection{데이터 스냅샷 만들기}
\label{\detokenize{discovery/part07/create_a_datasnapshot:id1}}\label{\detokenize{discovery/part07/create_a_datasnapshot::doc}}
데이터플로우에서 룰 편집이 완료된 데이터셋은 '데이터 스냅샷'을 찍어서 로컬 PC에 파일로 다운로드 받거나, Metatron 엔진으로 즉시 적재할 수 있습니다. 데이터 스냅샷을 실행하면 10,000개 행 이하의 샘플 데이터에만 적용된 룰을 전체 데이터에 대해 적용하게 됩니다.

스냅샷을 만드는 방법은 다음과 같습니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
{\hyperref[\detokenize{discovery/part07/edit_rules::doc}]{\sphinxcrossref{\DUrole{doc}{룰 편집}}}} 창 우측 상단에 위치한 \sphinxstylestrong{데이터 스냅샷} 버튼을 클릭합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_datasnapshot_1}.png}
\end{figure}
\end{quote}

\item {} 
스냅샷 생성을 위한 팝업이 나타나면, 스냅샷 생성 위치를 FILE과 HIVE(STAGING\_DB) 중에서 지정합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_datasnapshot_2}.png}
\end{figure}
\begin{itemize}
\item {} 
FILE 경로로 스냅샷의 위치를 지정하는 경우, \sphinxstylestrong{CSV} 또는 \sphinxstylestrong{JSON}의 포맷으로 생성할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_datasnapshot_3}.png}
\end{figure}
\end{quote}

\item {} 
HIVE 옵션은 STAGING\_DB가 설정된 경우에만 활성화됩니다. 스키마명과 테이블명을 지정하면 해당 테이블에 스냅샷이 생성됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_datasnapshot_4}.png}
\end{figure}
\end{quote}

\end{itemize}
\end{quote}

\item {} 
스냅샷을 생성하면 동일한 창에서 스냅샷 생성 상태와 정보를 조회할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_a_datasnapshot_5}.png}
\end{figure}
\end{quote}

\end{enumerate}


\section{데이터 스냅샷 결과 이용하기}
\label{\detokenize{discovery/part07/data_snapshot:id1}}\label{\detokenize{discovery/part07/data_snapshot::doc}}
데이터플로우를 통해 생성된 \sphinxstylestrong{데이터 스냅샷}은 다음과 같이 활용할 수 있습니다.
\begin{itemize}
\item {} 
{\hyperref[\detokenize{discovery/part07/data_snapshot:snapshot-result-check}]{\sphinxcrossref{\DUrole{std,std-ref}{데이터 스냅샷 결과 확인하기}}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/data_snapshot:snapshot-into-druid}]{\sphinxcrossref{\DUrole{std,std-ref}{Metatron 엔진으로 적재하기}}}}

\item {} 
{\hyperref[\detokenize{discovery/part07/data_snapshot:snapshot-into-csv}]{\sphinxcrossref{\DUrole{std,std-ref}{CSV파일로 다운로드 받기}}}}

\end{itemize}


\subsection{데이터 스냅샷 결과 확인하기}
\label{\detokenize{discovery/part07/data_snapshot:snapshot-result-check}}\label{\detokenize{discovery/part07/data_snapshot:id2}}
스냅샷의 생성 단계는 다음과 같은 3가지 경우로 분류됩니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{성공} = SUCCEEDED

\item {} 
\sphinxstylestrong{실패} = FAILED

\item {} 
\sphinxstylestrong{처리중} = INITIALIZING, RUNNING, WRITING, TABLE\_CREATING, CANCELING

\end{itemize}

스냅샷의 상세한 처리 결과는 다음 2가지 경로를 통해 확인할 수 있습니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{MANAGEMENT} \textgreater{} \sphinxstylestrong{데이터 프리퍼레이션} \textgreater{} \sphinxstylestrong{데이터 스냅샷}의 스냅샷 목록을 통해서 확인
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{data_snapshot_1}.png}
\end{figure}
\end{quote}

\item {} 
\sphinxstylestrong{데이터플로우}의 {\hyperref[\detokenize{discovery/part07/edit_rules::doc}]{\sphinxcrossref{\DUrole{doc}{룰 편집}}}} 화면 우측에서 \sphinxstylestrong{스냅샷(\#)} 탭을 클릭
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{data_snapshot_2}.png}
\end{figure}
\end{quote}

\end{itemize}

생성에 성공한 스냅샷의 상세 보기 화면으로 들어가면, 데이터의 유효성 비율, 생성된 스냅샷의 그리드 등을 확인할 수 있고, 스냅샷 결과를 {\hyperref[\detokenize{discovery/part07/data_snapshot:snapshot-into-csv}]{\sphinxcrossref{\DUrole{std,std-ref}{CSV 파일로 다운로드}}}}할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{data_snapshot_3}.png}
\end{figure}
\end{quote}

유효한 데이터가 생성되지 못한 스냅샷의 상세 보기 화면으로 들어가면, 실패를 발생시킨 예외의 로그가 표시됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{data_snapshot_4}.png}
\end{figure}
\end{quote}


\subsection{Metatron 엔진으로 적재하기}
\label{\detokenize{discovery/part07/data_snapshot:metatron}}\label{\detokenize{discovery/part07/data_snapshot:snapshot-into-druid}}
(개발예정)


\subsection{CSV파일로 다운로드 받기}
\label{\detokenize{discovery/part07/data_snapshot:csv}}\label{\detokenize{discovery/part07/data_snapshot:snapshot-into-csv}}
생성에 성공한 스냅샷의 상세 보기에서는 \sphinxstylestrong{CSV로 다운로드}가 가능합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{data_snapshot_5}.png}
\end{figure}
\end{quote}

다운로드한 파일은 표준 CSV 형식으로, 'comma'로 구분되고 'new line'으로 개행합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{data_snapshot_6}.png}
\end{figure}
\end{quote}


\chapter{계정 관리}
\label{\detokenize{discovery/part08/index:id1}}\label{\detokenize{discovery/part08/index::doc}}
관리자는 Metatron Discovery 사용자들의 멤버쉽과 사용 권한을 설정·관리할 수 있으며, \sphinxstylestrong{그룹} 기능을 이용하여 이러한 관리를 더욱 효율화할 수 있습니다.

사용자 관리를 위해서는 메인 화면 좌측 패널에서 \sphinxmenuselection{ADMINISTRATION \(\rightarrow\) 사용자} 클릭 후 원하는 하위 메뉴를 선택하면 됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{user_menu}.png}
\end{figure}
\end{quote}


\section{멤버쉽 승인}
\label{\detokenize{discovery/part08/membership_approval:membership-approval}}\label{\detokenize{discovery/part08/membership_approval:id1}}\label{\detokenize{discovery/part08/membership_approval::doc}}
이 메뉴에서는 사용자들의 가입 신청 내역을 보여줍니다. 아래 화면에서 보이는 것과 같이 가입이 거절되었거나, 승인을 대기 중인 신청 건들이 목록에 나타납니다. 승인을 마친 사용자는 이 메뉴가 아닌 \sphinxstylestrong{멤버} 메뉴에서 확인할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{approval_home}.png}
\end{figure}
\end{quote}


\section{멤버}
\label{\detokenize{discovery/part08/members:id1}}\label{\detokenize{discovery/part08/members::doc}}
이 메뉴에서는 등록을 마친 사용자들을 열람·관리할 수 있습니다.

Metatron Discovery 가입은 다음 두 방법 중 하나로 이루어집니다.
\begin{itemize}
\item {} 
사용자가 회원 가입 신청 후 관리자가 승인({\hyperref[\detokenize{discovery/part08/membership_approval:membership-approval}]{\sphinxcrossref{\DUrole{std,std-ref}{멤버쉽 승인}}}} 참조)

\item {} 
관리자가 직접 등록({\hyperref[\detokenize{discovery/part08/members:user-registration}]{\sphinxcrossref{\DUrole{std,std-ref}{사용자 등록}}}} 참조)

\end{itemize}


\subsection{멤버 홈 화면}
\label{\detokenize{discovery/part08/members:id2}}
멤버 홈 화면에서는 Metatron Discovery 시스템에 가입된 사용자들을 열거하여 보여줍니다.
사용자 목록은 여러 기준으로 필터링할 수 있으며, 목록에 나타난 사용자 중 하나를 클릭하여 해당 사용자의 정보를 열람·수정할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{members_home}.png}
\end{figure}
\end{quote}


\subsection{사용자 정보 열람 및 수정}
\label{\detokenize{discovery/part08/members:id3}}
홈 화면 목록에 나타난 사용자 중 하나를 클릭하면, 아래와 같이 해당 사용자의 정보를 보여주는 화면으로 이동합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{member_info}.png}
\end{figure}
\end{quote}

이 화면에서는 기본 정보 열람과 더불어 몇 가지 설정이 가능합니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{상태 설정(활성화/비활성화)}: 해당 사용자를 비활성화시키면 시스템에 로그인할 수 없게 됩니다.

\item {} 
\sphinxstylestrong{패스워드 초기화}: 해당 사용자가 비밀번호를 잊어버린 경우, 비밀번호를 초기화할 수 있는 메일을 보내줍니다.

\item {} 
\sphinxstylestrong{그룹 설정}: \sphinxincludegraphics{{setup_icon}.png} 아이콘을 클릭하면 해당 사용자가 속한 그룹을 추가·삭제할 수 있습니다. 그룹과 관련된 설명은 {\hyperref[\detokenize{discovery/part08/groups:user-groups}]{\sphinxcrossref{\DUrole{std,std-ref}{그룹}}}} 항목을 참조하십시오.

\end{itemize}


\subsection{사용자 등록}
\label{\detokenize{discovery/part08/members:user-registration}}\label{\detokenize{discovery/part08/members:id4}}
홈 화면 우측 상단에서 \sphinxguilabel{사용자 생성} 버튼을 클릭하면 아래와 같은 사용자 생성 팝업이 나타납니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_member}.png}
\end{figure}
\end{quote}

사용자의 실명과 ID, 이메일을 입력하면 사용자 등록이 완료되며, 해당 메일 주소로 가입 내역이 전달됩니다.


\section{그룹}
\label{\detokenize{discovery/part08/groups:user-groups}}\label{\detokenize{discovery/part08/groups:id1}}\label{\detokenize{discovery/part08/groups::doc}}
Metatron Discovery 사용자들을 그룹으로 지정하면 다음과 같은 편의 기능을 사용할 수 있습니다.
\begin{itemize}
\item {} 
그룹에 속한 사용자들의 권한 일괄 설정

\item {} 
그룹에 속한 사용자들에게 일괄 메일 전송

\end{itemize}


\subsection{그룹 홈 화면}
\label{\detokenize{discovery/part08/groups:id2}}
그룹 홈 화면에는 현재 Metatron Discovery에 등록된 사용자 그룹들을 보여줍니다.
그룹 목록은 여러 기준으로 필터링할 수 있으며, 목록에 나타난 그룹 중 하나를 클릭하여 해당 그룹의 정보를 열람·수정할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{groups_home}.png}
\end{figure}
\end{quote}


\subsection{그룹 정보 열람 및 수정}
\label{\detokenize{discovery/part08/groups:id3}}
홈 화면 목록에 나타난 그룹 중 하나를 클릭하면, 아래와 같이 해당 그룹의 정보를 보여주는 화면으로 이동합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{group_info}.png}
\end{figure}
\end{quote}

이 화면에서 제공되는 기능은 다음과 같습니다.
\begin{itemize}
\item {} 
해당 그룹의 기본 정보와 부여된 권한, 그리고 소속된 사용자들을 확인할 수 있습니다.

\item {} 
\sphinxincludegraphics{{setup_icon}.png} 아이콘을 클릭하면 해당 그룹의 소속 멤버를 추가·삭제할 수 있습니다.

\item {} 
\sphinxguilabel{모든 멤버에게 이메일 보내기} 버튼을 클릭하면 해당 그룹에 소속된 모든 멤버에게 이메일을 보낼 수 있습니다.

\end{itemize}


\subsection{그룹 등록}
\label{\detokenize{discovery/part08/groups:id4}}
홈 화면 우측 상단에서 \sphinxguilabel{그룹 생성} 버튼을 클릭하면 아래와 같은 그룹 생성 팝업이 나타납니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_group}.png}
\end{figure}
\end{quote}

이름과 설명을 입력한 후 \sphinxguilabel{마침} 버튼을 클릭하면 새로운 그룹이 생성됩니다.


\section{사용자 권한}
\label{\detokenize{discovery/part08/permissions:id1}}\label{\detokenize{discovery/part08/permissions::doc}}
Metatron Discovery는 아래 화면과 같이 총 4종류의 권한을 지원하여 사용자 계정별로 접근 권한에 차등을 둘 수 있습니다. 본 메뉴에서는 개별 사용자 또는 그룹에게 부여하는 권한을 설정할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{permissions}.png}
\end{figure}
\end{quote}

홈 화면에 제시된 4개의 권한 중 하나를 클릭하면 아래와 같이 해당 권한이 부여된 개인 사용자와 그룹이 표시됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{edit_permission}.png}
\end{figure}
\end{quote}

\sphinxstylestrong{멤버} 또는 \sphinxstylestrong{그룹} 영역에서 \sphinxincludegraphics{{setup_icon}.png} 아이콘을 클릭하면 아래와 같은 설정 팝업이 나타나서 해당 권한을 부여받는 멤버/그룹을 설정할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{shared_users}.png}
\end{figure}
\end{quote}


\chapter{데이터 탐색}
\label{\detokenize{discovery/part09/index:id1}}\label{\detokenize{discovery/part09/index::doc}}
관리자는 Metatron Discovery 사용자들의 멤버쉽과 사용 권한을 설정·관리할 수 있으며, \sphinxstylestrong{그룹} 기능을 이용하여 이러한 관리를 더욱 효율화할 수 있습니다.

데이터 탐색을 위해서는 메인 화면 좌측 패널에서 \sphinxmenuselection{Exploration} 클릭 후 원하는 하위 메뉴를 선택하면 됩니다.
또한 사용자의 원활한 데이터 탐색을 위해서 Admin은 Metadata를 관리하여야 합니다. \sphinxmenuselection{Management \textgreater{} Exploration} 클릭 후 원하는 하위 메뉴를 선택하면 됩니다.


\section{데이터 탐색하기}
\label{\detokenize{discovery/part09/dataexploration:id1}}\label{\detokenize{discovery/part09/dataexploration::doc}}
Metatron Discovery에서 제공하는 데이터 탐색의 목적은, 데이터가 어디 있던 쉽게 찾을 수 있고, 찾은 데이터로 시각화 할 수 있는 기능을 지원하고 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{exploration}.png}
\end{figure}
\end{quote}


\subsection{데이터 탐색 오버뷰 화면}
\label{\detokenize{discovery/part09/dataexploration:id2}}
현재 사용하고 계신 원천 DB 내 데이터, 그리고 Metatron Discovery에서 제공하는 StagingDB(Slave DB) 및 Engine(Druid) 내 데이터를 관리할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{exploration01}.png}
\end{figure}
\end{quote}


\subsection{데이터 탐색 상세 화면}
\label{\detokenize{discovery/part09/dataexploration:id3}}
데이터 탐색을 통해 원하는 데이터를 빠르게 찾을 수 있도록 기능을 제공하고 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{exploration_detail}.png}
\end{figure}
\end{quote}

데이터는 크게 3부분으로 정보를 제공합니다. Overview, Column Scheme, Sample Data 입니다.
각 데이터 타입에 따라, 워크북(Datasource 타입인 경우), 워크벤치(DB 타입인 경우)를 만들 수 있는 액션버튼도 제공합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{exploration_detail01}.png}
\end{figure}
\end{quote}

샘플 데이터의 경우 현재 100건까지만 보여집니다. 권한이 있는 경우 'Management \textgreater{} Exploration'을 통해 더 많은 데이터를 확인하고 다운로드 할 수 있습니다.
권한의 여부는 해당 화면 상단에 'Edit data'라는 버튼의 유무로 확인할 수 있으며, 해당 버튼을 클릭하면 'Management \textgreater{} Exploration'로 이동이 가능합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{exploration_detail02}.png}
\end{figure}
\end{quote}

다른 메뉴로 점핑 시 다음과 같은 경고창이 보여집니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{popup}.png}
\end{figure}
\end{quote}

아래 화면은 'Management \textgreater{} Exploration'로 이동하였을때 화면입니다. 해당 공간에서, 관리자로서의 좀 더 많은 메타 정보를 상세히 볼 수 있고 관리할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{exploration_detail03}.png}
\end{figure}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{metadata}.png}
\end{figure}
\end{quote}

카타로그, 태그 등의 검색과 필터 기능을 통하여 데이터를 빠르게 찾을 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{search}.png}
\end{figure}
\end{quote}

Metatron Discovery에서는 데이터를 카타로그로 관리할 수 있습니다. 카타로그을 그룹 등의 분류 군에 따라 구별해 두고 빠르게 데이터를 검색 하는 용도로 사용할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{catalog}.png}
\end{figure}
\end{quote}


\subsection{Favorite Data 화면}
\label{\detokenize{discovery/part09/dataexploration:favorite-data}}
해당 기능은 준비 중입니다.


\subsection{Data Creator 화면}
\label{\detokenize{discovery/part09/dataexploration:data-creator}}
해당 기능은 준비 중입니다.


\section{메타데이터 관리하기}
\label{\detokenize{discovery/part09/metadata:id1}}\label{\detokenize{discovery/part09/metadata::doc}}
메타데이터는 Exploration에서 보여지는 각 데이터를 관리하고 더 자세하게 분석하기 위한 용도로 만들어졌습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{metadata01}.png}
\end{figure}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{metadata}.png}
\end{figure}
\end{quote}


\section{Column Dictionary}
\label{\detokenize{discovery/part09/columndictionary:column-dictionary}}\label{\detokenize{discovery/part09/columndictionary::doc}}\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dictionary}.png}
\end{figure}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dictionary01}.png}
\end{figure}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{dictionary02}.png}
\end{figure}
\end{quote}


\section{Code Table}
\label{\detokenize{discovery/part09/codetable:code-table}}\label{\detokenize{discovery/part09/codetable::doc}}\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{codetable01}.png}
\end{figure}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{codetable02}.png}
\end{figure}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{codetable03}.png}
\end{figure}
\end{quote}


\chapter{엔진 모니터링}
\label{\detokenize{discovery/part10/index:id1}}\label{\detokenize{discovery/part10/index::doc}}
엔진 모니터링은 Metatron Engine의 모니터링을 의미합니다. Metatron Engine은 Druid를 사용한 시계열 기반의 엔진입니다.
엔진 모니터링은 Ingestion, Query에 대한 상태 모니터링과 로그 정보를 보여집니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{overview00}.png}
\end{figure}
\end{quote}

해당 기능은 Metatron Discovery 3.4.0 이후 버젼부터 지원합니다.


\section{Overview}
\label{\detokenize{discovery/part10/overview:overview}}\label{\detokenize{discovery/part10/overview::doc}}

\subsection{Druid Setting Configuration}
\label{\detokenize{discovery/part10/overview:druid-setting-configuration}}
Druid 설치 정보를 알 수 있습니다. 우측 상단을 보면 information버튼이 있습니다. 해당 버튼을 클릭하면, 설치된 정보를 확인 가능합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{configuration}.png}
\end{figure}
\end{quote}

Druid 설치 설정을 Common, Historical Node, Broker Node, Coordinator Node, Middle Manager Node, Overlord Node로 각각 확인 가능합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{configuration01}.png}
\end{figure}
\end{quote}


\subsection{Historical 사용량}
\label{\detokenize{discovery/part10/overview:historical}}
각 historical node 의 사용량 표시합니다. Coordinator의 servers 리스트에서 개별 서버 항목 추출하여 만들어집니다.


\subsection{Cluster 전체 사용량}
\label{\detokenize{discovery/part10/overview:cluster}}
Druid historical 모니터링기능을 제공합니다.

Cluster의 사용량 정보는 아래와 같습니다.
\begin{itemize}
\item {} 
cluster 전체 사용량 확인 가능

\item {} 
개별 historical 사용량 확인 가능

\end{itemize}

Coordinator의 servers 리스트를 이용하여 만들어진 KPI 입니다.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Field
&\sphinxstyletheadfamily 
Description
&\sphinxstyletheadfamily 
Example
\\
\hline
Node Count
&
historical node 수
&\\
\hline
MaxSize
&&\\
\hline
currSize
&&\\
\hline
Used
&&\\
\hline
FreeSize
&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Historical 사용량}
\label{\detokenize{discovery/part10/overview:id1}}
각 historical node 의 사용량 표시합니다. Coordinator의 servers 리스트에서 개별 서버 항목 추출하여 만들어집니다.


\section{Ingestion}
\label{\detokenize{discovery/part10/ingestion:ingestion}}\label{\detokenize{discovery/part10/ingestion::doc}}
Druid Indexing Service 모니터링입니다. 해당 페이지에서는 Index task의 실행 상태 및 task 관련 정보를 제공합니다.

아래와 같은 정보를 제공해줍니다.
\begin{itemize}
\item {} \begin{description}
\item[{MiddleManager 상태 확인 가능}] \leavevmode\begin{itemize}
\item {} 
worker 별 용량, 현재 사용량 현황

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Supervisor 상태 확인 가능}] \leavevmode\begin{itemize}
\item {} 
supervisor 별 상태

\item {} 
terminate (suspend, reset) 기능 제공

\end{itemize}

\end{description}

\item {} \begin{description}
\item[{Task 상태 확인 가능}] \leavevmode\begin{itemize}
\item {} 
runningTasks, pendingTasks, waitingTasks, completedTasks

\item {} 
log, kill 기능 제공

\end{itemize}

\end{description}

\item {} 
Lockbox 상태 확인 가능

\end{itemize}

Ingestion 에는 supervisor와 middle manager에 대한 정보도 같이 확인할 수 있다.


\subsection{Tasks}
\label{\detokenize{discovery/part10/ingestion:tasks}}
Task는 다음과 같이 4개로 분류할 수 있습니다.
\begin{itemize}
\item {} 
pending task:  worker 할당을 기다리는 task

\item {} 
running task: 실행중인 task

\item {} 
waiting task: lock을 기다리는 task

\item {} 
completed task: 완료된 task로 SUCCESS, FAIL의 두 상태로 나뉜다.

\end{itemize}

Task 상세 정보 및 메뉴는 아래와 같습니다.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Field
&\sphinxstyletheadfamily 
Description
&\sphinxstyletheadfamily 
Example
\\
\hline
id
&
taskId
&\\
\hline
type
&&\\
\hline
dataSource
&&\\
\hline
createdTime
&&\\
\hline
queueInsertionTime
&&\\
\hline
status
&&\\
\hline
runnerStatusCode
&&\\
\hline
duration
&&\\
\hline
locationhost
&&\\
\hline
locationport
&&\\
\hline
payload
&&\\
\hline
status
&
상태
&\\
\hline
log
&&\\
\hline
log last 8k
&&\\
\hline
kill
&&\\
\hline
ingestion
&&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

이와 같습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ingestion_task}.png}
\end{figure}
\end{quote}

상세 화면을 살펴보면 다음과 같습니다. (아래는 Kafka를 사용한 경우입니다)
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ingestion_task01}.png}
\end{figure}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ingestion_task02}.png}
\end{figure}
\end{quote}

아래는 Kafka가 아닌 일반 Task의 경우의 모습입니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ingestion_task03}.png}
\end{figure}
\end{quote}


\subsection{Supervisors}
\label{\detokenize{discovery/part10/ingestion:supervisors}}
실행중인 Supervisors의 모니터링을 할 수 있다. 확인 가능한 Supervisor 상세 정보 및 menu는 다음과 같다.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
Field
&\sphinxstyletheadfamily 
Description
&\sphinxstyletheadfamily 
Example
\\
\hline
Status
&
get supervisorIDs로 제공되는
supervisor는 모두 running 상태임
&\\
\hline
Datasource
&&\\
\hline
Detailed Status
&
status API 로 제공되는 정보
&\\
\hline
Lag
&
kafka의 lag 정보. emitter 사용
&\\
\hline
Spec
&&\\
\hline
Shutdown
&
Terminate supervisor. 관련된 task도 함께 kill 됨
&\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

이와 같습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ingestion_supervisor}.png}
\end{figure}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ingestion_supervisor01}.png}
\end{figure}
\end{quote}


\subsection{MiddleManagers}
\label{\detokenize{discovery/part10/ingestion:middlemanagers}}
worker 리스트를 의미합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ingestion_middlemanager}.png}
\end{figure}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{ingestion_middlemanager01}.png}
\end{figure}
\end{quote}


\section{Query}
\label{\detokenize{discovery/part10/query:query}}\label{\detokenize{discovery/part10/query::doc}}\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{query}.png}
\end{figure}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{query_detail}.png}
\end{figure}
\end{quote}


\part{EX-pack for Workflow Integrator}
\label{\detokenize{index:ex-pack-for-workflow-integrator}}

\chapter{Integrator 확장팩 소개}
\label{\detokenize{integrator/part01/index:integrator}}\label{\detokenize{integrator/part01/index::doc}}
Integrator 확장팩은 Hadoop 워크플로우 관리 시스템인 Apache Oozie를 조작하기 쉬운 GUI로 구현하고, 워크플로우를 거쳐 적재된 데이터를 Metatron Discovery에 바로 사용할 수 있도록 지원하는 모듈입니다. 이를 통해 사용자는 반복적으로 수행해야 할 Hadoop 작업 루틴을 간편하게 설계·구축하고 실행 주기를 설정하여, Metatron Discovery 작업에 필요한 데이터를 주기적으로 확보할 수 있습니다.

Integrator 확장팩의 주요 특징은 다음과 같습니다.

\sphinxstylestrong{워크플로우 편집과 예약을 동시에}
\begin{quote}

직관적인 차트 에디터를 이용하여 워크플로우를 손쉽게 생성하고 실행을 예약할 수 있습니다.
\end{quote}

\sphinxstylestrong{여러 클러스터를 한번에 관리}
\begin{quote}

워크플로우 내 작업 노드별로 원천 데이터의 출처와 가공 후 적재할 테이블을 자유롭게 지정할 수 있어, 여러 클러스터를 한번에 관리할 수 있습니다.
\end{quote}

\sphinxstylestrong{워크플로우 공유}
\begin{quote}

구축된 워크플로우는 조직 내 여러 사람이 함께 공유하고 관리할 수 있습니다.
\end{quote}

\sphinxstylestrong{알람 및 보고서}
\begin{quote}

예약된 워크플로우 실행 결과는 SMS, 이메일, 메신저 등 다양한 채털을 통해 보고받을 수 있습니다.
\end{quote}


\chapter{워크플로우 리스트}
\label{\detokenize{integrator/part02/index:workflow-list}}\label{\detokenize{integrator/part02/index:id1}}\label{\detokenize{integrator/part02/index::doc}}
Integrator 메인 홈에서 \sphinxstylestrong{워크플로우} 탭으로 들어가면, 아래와 같이 현재 등록된 워크플로우들을 열거하여 보여줍니다.
\sphinxstylestrong{상태} 컬럼에서는 각 워크플로우의 진행 현황을 간략하게 보여줍니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workflow_list}.png}
\end{figure}
\end{quote}

리스트에 나열된 워크플로우 중 하나를 클릭하면 해당 워크플로우의 에디터 화면으로 이동합니다. 워크플로우 에디터에 대한 자세한 설명은 {\hyperref[\detokenize{integrator/part03/index:workflow-editor}]{\sphinxcrossref{\DUrole{std,std-ref}{워크플로우 에디터}}}} 항목을 참조하십시오.

화면 우측 상단의 \sphinxstylestrong{+ 워크플로우 생성}을 클릭하면 새로운 워크플로우를 생성할 수 있는 대화 상자가 열립니다. 만들고자하는 워크플로우의 이름과 설명을 입력한 후 \sphinxstylestrong{마침} 버튼을 클릭하면 새로운 워크플로우가 생성됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_workflow}.png}
\end{figure}
\end{quote}


\chapter{워크플로우 에디터}
\label{\detokenize{integrator/part03/index:workflow-editor}}\label{\detokenize{integrator/part03/index:id1}}\label{\detokenize{integrator/part03/index::doc}}
워크플로우 에디터는 선택한 Hadoop 워크플로우를 손쉽게 편집하고 실행을 스케줄링할 수 있는 GUI를 제공합니다. {\hyperref[\detokenize{integrator/part02/index:workflow-list}]{\sphinxcrossref{\DUrole{std,std-ref}{워크플로우 리스트}}}}에 열거된 워크플로우 중 하나를 클릭하면 워크플로우 에디터로 이동하며, 화면 구성은 아래와 같습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{workflow_editor}.png}
\end{figure}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{워크플로우 노드 선택 영역:} 워크플로우에 추가할 노드들을 선택하는 영역입니다. \sphinxincludegraphics{{icon_unfold}.png} 버튼을 클릭하면 패널이 확장되어 각 노드의 명칭을 확인할 수 있습니다. 다음과 같은 두 종류의 노드로 구분됩니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{액션 노드(에디터에서 'Task'로 분류):} 원천 데이터를 Hadoop 클러스터에서 수집·가공·적재하기 위한 각각의 연산처리 작업을 정의합니다. 자세한 내용은 {\hyperref[\detokenize{integrator/part03/tasks:action-nodes}]{\sphinxcrossref{\DUrole{std,std-ref}{액션 노드}}}} 항목을 참조하십시오.

\item {} 
\sphinxstylestrong{제어 흐름 노드(에디터에서 'General'로 분류):} 워크플로우의 시작과 끝을 정의하고, 액션 노드들의 흐름 경로를 결정하는 역할을 합니다. 자세한 내용은 {\hyperref[\detokenize{integrator/part03/control_flow:control-flow-nodes}]{\sphinxcrossref{\DUrole{std,std-ref}{제어 흐름 노드}}}} 항목을 참조하십시오.

\end{itemize}

\item {} 
\sphinxstylestrong{워크플로우 차트 캔버스:} 추가한 노드들 간의 시퀀스를 정의하는 영역입니다. 아래 그림과 같이 노드 선택 영역에서 원하는 노드들을 캔버스로 드래그한 후, 원하는 시퀀스에 맞춰서 노드끼리 연결을 하면 워크플로우 차트가 간단하게 완성됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{canvas}.png}
\end{figure}

영역 상단에 있는 \sphinxincludegraphics{{icon_do}.png} 버튼을 사용하여 undo와 redo가 가능하며, \sphinxincludegraphics{{icon_play}.png} 버튼을 클릭하면 현재 정의된 워크플로우가 실행됩니다. 또한 \sphinxstylestrong{Draft} 버튼을 클릭하면 현재까지 작업한 워크플로우가 저장되고, \sphinxstylestrong{Save} 버튼을 클릭하면 실제 워크플로우로서 반영이 됩니다.
\end{quote}

\item {} 
\sphinxstylestrong{워크플로우 노드 설정 영역:} 워크플로우 차트 캔버스에서 선택한 각 개별 노드의 상세 작업 내역을 설정하는 영역입니다. 자세한 설정 방식은 {\hyperref[\detokenize{integrator/part03/tasks:action-nodes}]{\sphinxcrossref{\DUrole{std,std-ref}{액션 노드}}}} 및 {\hyperref[\detokenize{integrator/part03/control_flow:control-flow-nodes}]{\sphinxcrossref{\DUrole{std,std-ref}{제어 흐름 노드}}}}에서 해당 노드 항목을 참조하십시오.

\item {} 
\sphinxstylestrong{워크플로우 실행 내역 표시 영역:} 정의된 워크플로우의 실행 내역을 보여주는 영역입니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{Manual run 탭:} 에디터 좌측 상단에 있는 \sphinxincludegraphics{{icon_play}.png} 버튼을 클릭하여 수동으로 워크플로우를 실행한 내역을 보여줍니다.

\item {} 
\sphinxstylestrong{Scheduled run 탭:} 정해진 시간에 따라 워크플로우 실행을 예약하는 UI를 제공하고 예약된 내역을 보여줍니다. 자세한 내용은 {\hyperref[\detokenize{integrator/part03/scheduled_run:scheduled-run}]{\sphinxcrossref{\DUrole{std,std-ref}{워크플로우 실행 예약하기}}}} 항목을 참조하십시오.

\end{itemize}

\end{enumerate}
\end{quote}

워크플로우 에디터 사용을 위해 보다 상세한 설명이 필요한 부분에 관해서는 아래와 같이 정리하였습니다.


\section{액션 노드}
\label{\detokenize{integrator/part03/tasks:action-nodes}}\label{\detokenize{integrator/part03/tasks:id1}}\label{\detokenize{integrator/part03/tasks::doc}}
Integrator의 액션 노드들(action nodes)은 원천 데이터를 Hadoop 클러스터에서 수집·가공·적재하기 위한 각각의 연산처리 작업을 정의합니다.
아래와 같이 여러 가지 Hadoop 작업과 몇몇 추가적인 개별 시스템 작업(Java, Shell 등)을 지원합니다.
\begin{itemize}
\item {} 
{\hyperref[\detokenize{integrator/part03/tasks:sqoop}]{\sphinxcrossref{Sqoop}}}

\item {} 
{\hyperref[\detokenize{integrator/part03/tasks:mr}]{\sphinxcrossref{MR}}}

\item {} 
{\hyperref[\detokenize{integrator/part03/tasks:exec}]{\sphinxcrossref{EXEC}}}

\item {} 
{\hyperref[\detokenize{integrator/part03/tasks:java}]{\sphinxcrossref{Java}}}

\item {} 
{\hyperref[\detokenize{integrator/part03/tasks:hive-query}]{\sphinxcrossref{HIVE Query}}}

\item {} 
{\hyperref[\detokenize{integrator/part03/tasks:ssh}]{\sphinxcrossref{SSH}}}

\item {} 
{\hyperref[\detokenize{integrator/part03/tasks:spark}]{\sphinxcrossref{Spark}}}

\item {} 
{\hyperref[\detokenize{integrator/part03/tasks:sub-workflow}]{\sphinxcrossref{Sub-Workflow}}}

\item {} 
{\hyperref[\detokenize{integrator/part03/tasks:distcp}]{\sphinxcrossref{DistCp}}}

\item {} 
{\hyperref[\detokenize{integrator/part03/tasks:hdfs}]{\sphinxcrossref{HDFS}}}

\item {} 
{\hyperref[\detokenize{integrator/part03/tasks:done}]{\sphinxcrossref{Done}}}

\item {} 
{\hyperref[\detokenize{integrator/part03/tasks:druid}]{\sphinxcrossref{Druid}}}

\end{itemize}


\subsection{Sqoop}
\label{\detokenize{integrator/part03/tasks:sqoop}}
RDB 상의 데이터를 가져오거나 간단한 쿼리를 실행할 수 있는 task 입니다.


\subsection{MR}
\label{\detokenize{integrator/part03/tasks:mr}}
Local에 있는 jar를 실행하는 데 사용합니다.


\subsection{EXEC}
\label{\detokenize{integrator/part03/tasks:exec}}
Python, shell 등 로컬에 있는 파일을 실행하는데 사용합니다.


\subsection{Java}
\label{\detokenize{integrator/part03/tasks:java}}
Java Task는 Java Class를 실행하고자 할 때 사용합니다. (단, main 함수가 구현되어 있어야 합니다.)


\subsection{HIVE Query}
\label{\detokenize{integrator/part03/tasks:hive-query}}
Hive 쿼리를 실행할 때 사용합니다.


\subsection{SSH}
\label{\detokenize{integrator/part03/tasks:ssh}}
원격지(remote)에 있는 명령어를 실행할 때 사용합니다. 다만, remote 서버는 SSH password-less login 설정이 되어 있어야 합니다.


\subsection{Spark}
\label{\detokenize{integrator/part03/tasks:spark}}
SPARK를 실행하는데 사용합니다.


\subsection{Sub-Workflow}
\label{\detokenize{integrator/part03/tasks:sub-workflow}}
기존 만들어진 Workflow와 연계 시 사용됩니다. 여러개의 Workflow 를 묶어서 실행하고자 할 때 각각의 Workflow 를 Task 로 정의합니다.


\subsection{DistCp}
\label{\detokenize{integrator/part03/tasks:distcp}}
Source Hadoop Cluster 에서 Target Hadoop Cluster에 파일 복사시 사용합니다.


\subsection{HDFS}
\label{\detokenize{integrator/part03/tasks:hdfs}}
Hadoop File 관리시 사용합니다.


\subsection{Done}
\label{\detokenize{integrator/part03/tasks:done}}
완료시 Done 파일을 생성합니다.


\subsection{Druid}
\label{\detokenize{integrator/part03/tasks:druid}}
Druid 엔진에 데이터 증분적재하기 위해 사용합니다.


\section{제어 흐름 노드}
\label{\detokenize{integrator/part03/control_flow:control-flow-nodes}}\label{\detokenize{integrator/part03/control_flow:id1}}\label{\detokenize{integrator/part03/control_flow::doc}}
Integrator의 제어 흐름 노드들(control-flow nodes)은 워크플로우의 시작과 끝을 정의하고, {\hyperref[\detokenize{integrator/part03/tasks:action-nodes}]{\sphinxcrossref{\DUrole{std,std-ref}{액션 노드}}}}들의 흐름 경로를 결정하는 역할을 합니다.
지원하는 노드는 다음과 같습니다.
\begin{itemize}
\item {} 
{\hyperref[\detokenize{integrator/part03/control_flow:start}]{\sphinxcrossref{Start}}}

\item {} 
{\hyperref[\detokenize{integrator/part03/control_flow:end}]{\sphinxcrossref{End}}}

\item {} 
{\hyperref[\detokenize{integrator/part03/control_flow:decision}]{\sphinxcrossref{Decision}}}

\item {} 
{\hyperref[\detokenize{integrator/part03/control_flow:fork}]{\sphinxcrossref{Fork}}}

\item {} 
{\hyperref[\detokenize{integrator/part03/control_flow:join}]{\sphinxcrossref{Join}}}

\end{itemize}


\subsection{Start}
\label{\detokenize{integrator/part03/control_flow:start}}
모든 워크플로우의 시작점입니다. 워크플로우를 실행하기 위해서는 필수로 들어가야 합니다.


\subsection{End}
\label{\detokenize{integrator/part03/control_flow:end}}
모든 워크플로우의 종료점입니다. 워크플로우를 종료하기 위해서는 필수로 들어가야 합니다.


\subsection{Decision}
\label{\detokenize{integrator/part03/control_flow:decision}}
조건에 따라 분기할 수 있게 하는 노드입니다. 가지수 만큼의 Switch case 문이 발생합니다.


\subsection{Fork}
\label{\detokenize{integrator/part03/control_flow:fork}}
조건 없이 분기하여 무조건 실행하는 동시실행 분기함수(parallel execution)입니다.


\subsection{Join}
\label{\detokenize{integrator/part03/control_flow:join}}
여러 노드를 합쳐주는 역할을 합니다.


\section{워크플로우 실행 예약하기}
\label{\detokenize{integrator/part03/scheduled_run:scheduled-run}}\label{\detokenize{integrator/part03/scheduled_run:id1}}\label{\detokenize{integrator/part03/scheduled_run::doc}}
워크플로우를 정해진 주기에 따라 반복적으로 실행해야할 경우 이러한 실행을 예약하고, 그 결과를 SMS, 메신저, 이메일 등으로 보고받을 수 있습니다.


\subsection{예약 실행 리스트}
\label{\detokenize{integrator/part03/scheduled_run:id2}}
워크플로우 에디터 우측 하단의 실행 내역 표시 영역에서 \sphinxstylestrong{Scheduled run} 탭을 클릭하면, 아래와 같이 해당 워크플로우에 대해 등록된 예약 실행 리스트가 나타납니다.
이 리스트에는 각 예약 실행 항목의 실행 현황이 표시되며, \sphinxincludegraphics{{icon_exec}.png} 버튼을 누르면 해당 예약 건이 실행되고 \sphinxincludegraphics{{icon_bin2}.png} 버튼을 누르면 삭제됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{schedule_list}.png}
\end{figure}
\end{quote}


\subsection{예약 실행 추가하기}
\label{\detokenize{integrator/part03/scheduled_run:id3}}
Scheduled run 영역에서 \sphinxstylestrong{+ Create execution schedule}을 클릭하면 다음과 같이 새 예약 실행을 생성하는 대화 상자가 열립니다. 아래 설명을 참조하여 각 필드 입력 후 \sphinxstylestrong{생성} 버튼을 클릭하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_schedule}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{Name:} 예약 실행의 이름을 입력합니다.

\item {} 
\sphinxstylestrong{Description:} 예약 실행에 대한 설명을 입력합니다.

\item {} 
\sphinxstylestrong{Tags:}

\item {} 
\sphinxstylestrong{Workflow:} 예약 실행할 워크플로우를 선택합니다.

\item {} 
\sphinxstylestrong{Period:} 예약 실행될 기간의 시작과 끝을 설정합니다.

\item {} 
\sphinxstylestrong{Frequency:} 예약실행되는 기간 중 반복 주기를 설정합니다.

\item {} 
\sphinxstylestrong{Concurrency:}

\item {} 
\sphinxstylestrong{Timeout(min):}

\item {} 
\sphinxstylestrong{Datasets:}

\item {} 
\sphinxstylestrong{Configuration:}

\item {} 
\sphinxstylestrong{Variables:}

\item {} 
\sphinxstylestrong{Alert:}

\end{itemize}
\end{quote}


\chapter{모니터링}
\label{\detokenize{integrator/part04/index:id1}}\label{\detokenize{integrator/part04/index::doc}}
Integrator 메인 홈에서 \sphinxstylestrong{모니터링} 탭으로 들어가면 등록된 각 워크플로우의 시간대별 실행 현황과 예약 정보를 그래프 형식으로 보여줍니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{monitoring_page}.png}
\end{figure}
\end{quote}

그래프에 표시된 상태 바 각각은 예약 또는 직접 명령한 워크플로우 실행 건을 가리키며, 다음과 같은 방식으로 실행 정보를 보여줍니다.
\begin{itemize}
\item {} 
위치와 길이: 해당 건이 실행된 기간에 해당하는 타임라인 구간에 표시됩니다.

\item {} 
색상: 화면 상단에 범례로 표시된 \sphinxstylestrong{Status} 항목의 표시 색상과 동일한 색상으로 표시됩니다. 예를 들어 녹색으로 표시된 상태 바는 해당 실행 건이 running 상태임을 의미합니다.

\end{itemize}

상태 바 위에 마우스 커서를 오버하면 아래와 같은 실행 내역이 나타나며, 대화 상자 우측 상단의 \sphinxstylestrong{상세보기}를 클릭하면 자세한 정보를 확인할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{status_bar}.png}
\end{figure}
\end{quote}


\chapter{Use Case}
\label{\detokenize{integrator/part05/index:use-case}}\label{\detokenize{integrator/part05/index::doc}}

\section{데이터 소스 적재 위임}
\label{\detokenize{integrator/part05/index:id1}}\begin{itemize}
\item {} 
대용량의 데이터 적재 시 발생하는 시스템 부하를 방지하기 위해 background 처리

\end{itemize}


\section{워크벤치와 연계}
\label{\detokenize{integrator/part05/index:id2}}\begin{itemize}
\item {} 
특정 쿼리의 반복 실행

\item {} 
오래 걸리는 쿼리의 위임

\end{itemize}


\section{데이터 프리퍼레이션과 연계}
\label{\detokenize{integrator/part05/index:id3}}\begin{itemize}
\item {} 
Wrangled dataset 반복 사용

\end{itemize}


\part{EX-pack for Anomaly Detection}
\label{\detokenize{index:ex-pack-for-anomaly-detection}}

\chapter{Anomaly 확장팩 소개}
\label{\detokenize{anomaly/part01/index:anomaly}}\label{\detokenize{anomaly/part01/index::doc}}
이상 탐지 확장팩 Anomaly는 Machine Learning 예측 모델을 기반으로 데이터 흐름의 비정상적인 상황을 감지하여 사용자가 즉각적으로 확인할 수 있도록 도와주는 도구입니다.


\section{기본 원리}
\label{\detokenize{anomaly/part01/index:basic-principles}}\label{\detokenize{anomaly/part01/index:id1}}
아래 그림과 같이 Anomaly는 대상 데이터 소스의 집계값을 실시간으로 예측하고 실제 값을 모니터링합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{features_01}.png}
\end{figure}
\end{quote}

여기서 \sphinxstylestrong{Predict}로 표시된 값은 머신러닝 기반으로 예측한 데이터 집계값이고, \sphinxstylestrong{Actual}로 표시된 값은 실제로 모니터링한 결과 값입니다. 아래 그림과 같이 두 값 간의 격차가 커질수록 \sphinxstylestrong{total abnormal score}가 증가하게 됩니다. 즉, 실제치가 예상치와 다르면 데이터 집계값이 그만큼 정상 범위를 벗어났다고 간주하는 것입니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{features_02}.png}
\end{figure}
\end{quote}

이 예시에서는 abnormal score가 10점에 도달하면 \sphinxcode{\sphinxupquote{Moderate}} 알람을 발생시키고, 80점에 도달하면 \sphinxcode{\sphinxupquote{Critical}} 알람을 발생시키도록 설정되어 있습니다.

이렇게 발생하는 알람은 다양한 채널로 사용자에게 통보되어, 사용자는 데이터 이상 상황에 즉각 대처할 수 있습니다.


\section{주요 기능}
\label{\detokenize{anomaly/part01/index:id2}}
Anomaly의 주요 기능은 다음과 같습니다.

\sphinxstylestrong{Machine Learning}
\begin{quote}

머신러닝에 기반한 예측 모델이 자동으로 추천되어 사용자 편의 증대
\end{quote}

\sphinxstylestrong{Alarm \& Report}
\begin{quote}

비정상적인 상황 발생 시 즉각 알람 발동 및 보고서 생성
\end{quote}

\sphinxstylestrong{Analyze}
\begin{quote}

데이터로 차트 생성하고 분석하는 서비스 메타트론 디스커버리와 연계 가능
\end{quote}

\sphinxstylestrong{Link with Learning System}
\begin{quote}

새로운 분석을 적용할 수 있도록 외부 분석 시스템과의 연계를 지원
\end{quote}


\section{구조}
\label{\detokenize{anomaly/part01/index:id3}}
Anomaly의 메뉴 구성은 다음과 같습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{structure_01}.png}
\end{figure}
\end{quote}

주요 메뉴 간 이동이 쉽고 세부 항목 간 참조 기능도 잘 구축되어 있어, 알람 룰 설정값과 발생한 알람 내역, 그리고 전반적인 알람 현황 간의 유기적인 파악이 용이합니다.


\chapter{알람 룰 만들기}
\label{\detokenize{anomaly/part02/index:id1}}\label{\detokenize{anomaly/part02/index::doc}}
Anomaly는 다음의 절차를 순차적으로 수행하도록 안내하여 사용자가 원하는 알람 룰을 쉽게 생성할 수 있도록 지원해줍니다.
\begin{itemize}
\item {} 
{\hyperref[\detokenize{anomaly/part02/index:select-datasource}]{\sphinxcrossref{\DUrole{std,std-ref}{데이터 소스 선정}}}}

\item {} 
{\hyperref[\detokenize{anomaly/part02/index:select-columns}]{\sphinxcrossref{\DUrole{std,std-ref}{모니터링할 지표 선택하기}}}}

\item {} 
{\hyperref[\detokenize{anomaly/part02/index:configure-training}]{\sphinxcrossref{\DUrole{std,std-ref}{트레이닝 기간 설정하기}}}}

\item {} 
{\hyperref[\detokenize{anomaly/part02/index:select-model}]{\sphinxcrossref{\DUrole{std,std-ref}{모델 선택하기}}}}

\item {} 
{\hyperref[\detokenize{anomaly/part02/index:alarm-rule-settings}]{\sphinxcrossref{\DUrole{std,std-ref}{알람 룰 조건 설정하기}}}}

\item {} 
{\hyperref[\detokenize{anomaly/part02/index:complete-rule}]{\sphinxcrossref{\DUrole{std,std-ref}{알람 룰 완성하기}}}}

\end{itemize}


\section{데이터 소스 선정}
\label{\detokenize{anomaly/part02/index:select-datasource}}\label{\detokenize{anomaly/part02/index:id2}}
아래와 같이 알람 룰 만들기 절차를 시작하십시오.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Anomaly 홈 우측 상단에 있는 \sphinxstylestrong{Create Alarm Rule} 버튼을 클릭합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{create_rule_01}.png}
\end{figure}
\end{quote}

\item {} 
모니터링하고자 하는 데이터 소스를 선택합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{choose_data_source_01}.png}
\end{figure}
\end{quote}

\end{enumerate}


\section{모니터링할 지표 선택하기}
\label{\detokenize{anomaly/part02/index:select-columns}}\label{\detokenize{anomaly/part02/index:id3}}
데이터 소스를 선택하면 다음 화면으로 넘어가면서 좌측에 \sphinxstylestrong{Data} 패널이 열립니다. 이 패널을 이용하여 아래와 같이 모니터링할 지표를 선택하십시오.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{Measure} 영역에서 알람을 설정하고자 하는 측정값 컬럼을 선택합니다. 클릭한 측정값 컬럼은 Aggregate 선반에 자동으로 옮겨집니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{choose_metrics_select_measure_01}.png}
\end{figure}
\end{quote}

\item {} 
필요할 경우 기존 컬럼에 수식을 적용하여 사용자 컬럼을 새로 만들 수도 있습니다. \sphinxstylestrong{Measure} 영역의 우측 상단에서 \sphinxincludegraphics{{icon_custom_column}.png} 버튼을 클릭하여 대화 상자를 열고 사용자 컬럼을 설정하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{choose_metrics_select_measure_04}.png}
\end{figure}
\end{quote}

\item {} 
Aggregate 선반에 올려진 각 컬럼의 aggregate 타입 항목을 클릭하여 원하는 타입을 선택합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{choose_metrics_select_measure_02}.png}
\end{figure}
\end{quote}

\item {} 
필요할 경우 차원값 컬럼을 기준으로 aggregate 데이터를 분할할 수 있습니다. \sphinxstylestrong{Dimension} 영역에서 분할의 기준으로 삼을 측정값 컬럼에 마우스 커서를 오버한 후 \sphinxincludegraphics{{icon_split}.png} 버튼을 클릭하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{choose_metrics_select_measure_05}.png}
\end{figure}
\end{quote}

\item {} 
필요할 경우 차원값 컬럼을 기준으로 aggregate 데이터를 필터링할 수 있습니다. \sphinxstylestrong{Dimension} 영역에서 필터를 설정할 측정값 컬럼에 마우스 커서를 오버한 후 \sphinxincludegraphics{{icon_ano_filter}.png} 버튼을 클릭하십시오. 그런 다음, 모니터링하고자 하는 특정 범주들을 선택하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{choose_metrics_add_filter_02}.png}
\end{figure}
\end{quote}

\end{enumerate}


\section{트레이닝 기간 설정하기}
\label{\detokenize{anomaly/part02/index:configure-training}}\label{\detokenize{anomaly/part02/index:id4}}
모니터링할 지표 선택을 마쳤으면, \sphinxstylestrong{Training interval} 패널에서 예측 모델 트레이닝에 사용할 데이터 범위를 선택할 수 있습니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
모델을 트레이닝시키는 데 사용할 데이터 세트의 주기를 \sphinxstylestrong{Granularity} 선택란에서 선택합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{choose_metrics_select_training_interval_01}.png}
\end{figure}
\end{quote}

\item {} 
모델을 트레이닝시키는 데 사용할 데이터 세트의 기간 범위를 설정합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{choose_metrics_select_training_interval_02}.png}
\end{figure}
\end{quote}

\item {} 
모든 설정을 마쳤으면 \sphinxstylestrong{Next}를 클릭합니다.

\end{enumerate}


\section{모델 선택하기}
\label{\detokenize{anomaly/part02/index:select-model}}\label{\detokenize{anomaly/part02/index:id5}}
이제 \sphinxstylestrong{Model} 패널로 넘어가서 어떠한 예측 모델을 사용할지 선택합니다. Anomaly는 주어진 트레이닝 데이터 세트를 이용하여 각각의 모델을 트레이닝시킨 후 그 결과를 산출해줍니다. 아래 두 방법 중 하나를 통해 적합한 예측 모델을 선택하십시오.
\begin{itemize}
\item {} 
기본적으로 우측에 표시되는 정확도 점수(100점 만점)가 가장 높은 모델이 \sphinxstylestrong{Recommend} 표시와 함께 자동 선택됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{choose_model_01}.png}
\end{figure}
\end{quote}

\item {} 
각 모델 항목 위에 마우스 커서를 오버하면 나타나는 상세 정보를 확인하여 가장 적합한 예측 모델을 직접 선택할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{choose_model_03}.png}
\end{figure}
\end{quote}

\end{itemize}


\section{알람 룰 조건 설정하기}
\label{\detokenize{anomaly/part02/index:alarm-rule-settings}}\label{\detokenize{anomaly/part02/index:id6}}
사용할 예측 모델을 선택하였으면, \sphinxstylestrong{Condition} 패널에서 알람이 발생하는 조건을 설정할 수 있습니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
\sphinxstylestrong{Subscribers} 항목의 우측에 있는 \sphinxincludegraphics{{icon_set}.png} 버튼을 클릭하여 대화 상자를 연 후, 알람 발생 시 통보를 받는 대상과 방법을 설정합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{set_alarm_rules_04}.png}
\end{figure}
\end{quote}

\item {} 
아래 각 항목의 설명을 참고하여 알람이 발동되는 시기를 설정합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{set_alarm_rules_01}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{Alarm Start:} 알람을 개시할 때를 설정합니다. 이 설정값에 해당하는 시간 이후부터 알람이 개시됩니다.

\item {} 
\sphinxstylestrong{Alarm Interval:} 알람의 조건이 충족되었을 때 알람을 발생시키는 주기를 설정합니다.

\end{itemize}
\end{quote}

\item {} 
아래 각 항목의 설명을 참고하여 모니터링 대상 데이터의 abnormal score에 따른 알람 발동 조건을 설정합니다. 기본적으로 하나의 조건이 주어지며, \sphinxstylestrong{+ Add Condition} 버튼을 클릭하면 조건을 추가할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{set_alarm_rules_02}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{Severity:} 주어진 조건에 해당하는 알람의 심각도를 설정합니다.

\item {} 
\sphinxstylestrong{Threshold:} abnormal score가 이 설정값을 초과하면 데이터 이상 상태로 간주됩니다.

\item {} 
\sphinxstylestrong{Frequency:} abnormal score가 한계값을 초과하는 빈도가 어떠할 때 알람을 발생시킬지 결정합니다. 예를 들어, "3 within 5 minute"로 설정한 경우에는 abnormal score가 5분 안에 3회 이상 한계값을 초과하면 알람이 발생합니다.

\end{itemize}
\end{quote}

\item {} 
모든 설정을 마쳤으면 \sphinxstylestrong{Next}를 클릭합니다.

\end{enumerate}


\section{알람 룰 완성하기}
\label{\detokenize{anomaly/part02/index:complete-rule}}\label{\detokenize{anomaly/part02/index:id7}}
알람 룰 설정이 끝났으면 아래와 같이 알람 룰 만들기 절차를 마무리합니다.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
알람 룰의 이름과 설명을 기입한 후 \sphinxstylestrong{Done} 버튼을 클릭합니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{complete_alarm_rules_01}.png}
\end{figure}
\end{quote}

\item {} 
생성된 알람 룰은 알람 룰 리스트의 최상단에 노출되고, 첫 알람 수행이 있기 전까지 \sphinxstylestrong{Prepare} 상태로 표시됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{complete_alarm_rules_02}.png}
\end{figure}
\end{quote}

\end{enumerate}


\chapter{통계}
\label{\detokenize{anomaly/part03/index:statistics}}\label{\detokenize{anomaly/part03/index:id1}}\label{\detokenize{anomaly/part03/index::doc}}
\sphinxstylestrong{Statistics} 탭 메뉴에서는 발생한 알람의 전반적인 통계를 보여줍니다. 이 페이지에서는 사용자가 지금까지 발생한 알람의 현황을 다각도로 파악할 수 있도록 중요도, 알람 발생 시기, 알람 룰 등의 다양한 기준으로 통계를 산출하여 제시합니다.

페이지 기본 구성은 다음과 같습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{overview_01}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{Alarm Distribution by Severity:} 심각도별 알람 발생 비중을 보여줍니다.

\item {} 
\sphinxstylestrong{Alarm Count per Time:} 시간대별 알람 빈도를 보여줍니다.

\item {} 
\sphinxstylestrong{Top 5 Subscribers:} 가장 많은 알람을 통보받은 사용자 5명을 보여줍니다.

\item {} 
\sphinxstylestrong{Top 5 Alarm rules:} 가장 많은 알람을 일으킨 알람 룰 5개를 보여줍니다.

\item {} 
\sphinxstylestrong{Latest Alarms:} 가장 최근에 발생한 알람들을 보여줍니다.

\end{itemize}
\end{quote}

페이지 상단의 기간 설정 메뉴를 이용하면 통계를 산출하는 기준 기간을 변경할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{overview_02}.png}
\end{figure}
\end{quote}


\chapter{얄람 룰 내역 열람·수정하기}
\label{\detokenize{anomaly/part04/index:id1}}\label{\detokenize{anomaly/part04/index::doc}}
\sphinxstylestrong{Alarm Rule} 탭 메뉴에서는 등록된 알람 룰을 열람·수정할 수 있습니다. 또한 이 메뉴에서는 선택한 예측 모델에 따라 산출되고 있는 데이터 abnormal score 현황도 쉽게 파악할 수 있습니다.

알람 룰 메뉴는 다음의 두 가지 페이지로 구성되어 있습니다.
\begin{itemize}
\item {} 
{\hyperref[\detokenize{anomaly/part04/index:alarm-rule-list}]{\sphinxcrossref{\DUrole{std,std-ref}{알람 룰 리스트}}}}

\item {} 
{\hyperref[\detokenize{anomaly/part04/index:alarm-rule-details}]{\sphinxcrossref{\DUrole{std,std-ref}{알람 룰 상세}}}}

\end{itemize}


\section{알람 룰 리스트}
\label{\detokenize{anomaly/part04/index:alarm-rule-list}}\label{\detokenize{anomaly/part04/index:id2}}
\sphinxstylestrong{Alarm Rule} 탭으로 들어가면 현재 등록된 알람 룰들을 열거하여 보여줍니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{complete_alarm_rules_021}.png}
\end{figure}
\end{quote}

리스트에 표시되는 정보는 아래와 같으며, 이를 기준으로 열거할 룰을 필터링하거나 검색할 수 있습니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{Current Status:} 해당 룰에 따른 모니터링 결과 상태

\item {} 
\sphinxstylestrong{Alarm Rule Name:} 해당 룰의 이름

\item {} 
\sphinxstylestrong{DataSource:} 모니터링 대상 데이터 소스

\item {} 
\sphinxstylestrong{Measure:} 모니터링 대상 측정값 컬럼

\item {} 
\sphinxstylestrong{Alarm Interval:} 알람 발생 주기

\item {} 
\sphinxstylestrong{Condition:} 해당 룰에 적용된 알람 발생 조건의 개수

\item {} 
\sphinxstylestrong{Alarm:} 해당 룰에 의해 발생한 알람의 수

\item {} 
\sphinxstylestrong{Running:} 해당 룰의 모니터링 활성 여부

\item {} 
\sphinxstylestrong{Updated:} 해당 룰을 마지막으로 업데이트한 시간과 사용자

\end{itemize}


\section{알람 룰 상세}
\label{\detokenize{anomaly/part04/index:alarm-rule-details}}\label{\detokenize{anomaly/part04/index:id3}}
알람 룰 리스트에 열거된 항목 중 하나를 선택하면 해당 알람 룰에 대한 상세 정보를 열람하고 설정을 수정할 수 있습니다. 화면 좌측에서는 모니터링 현황을 시각화하여 보여주고, 우측에는 알람 룰 조건 설정값이 표시됩니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{alarm_rule_detail_01}.png}
\end{figure}
\end{quote}

모니터링 현황 영역 상단에는 화면에 보여주는 모니터링 기간 설정값이 표시되어 있습니다. \sphinxincludegraphics{{icon_period_edit}.png} 아이콘을 클릭하면 기간 설정값을 변경할 수 있습니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{alarm_rule_detail_02}.png}
\end{figure}
\end{quote}

알람 룰 조건 설정 영역에서는 기존에 설정된 알람 룰 설정값을 수정할 수 있습니다. 자세한 내용은 {\hyperref[\detokenize{anomaly/part02/index:alarm-rule-settings}]{\sphinxcrossref{\DUrole{std,std-ref}{알람 룰 조건 설정하기}}}} 항목을 참조하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{alarm_rule_detail_03}.png}
\end{figure}
\end{quote}

우측 끝단에서 \sphinxincludegraphics{{icon_alarm_history}.png} 버튼을 누르면 \sphinxstylestrong{Conditions} 패널이 \sphinxstylestrong{Alarm History} 패널로 전환되어 지금까지 발생한 알람 이력을 보여줍니다(다시 \sphinxincludegraphics{{icon_rule_settings_edit}.png} 버튼을 누르면 \sphinxstylestrong{Conditions} 패널로 되돌아옵니다).
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{alarm_rule_detail_04}.png}
\end{figure}
\end{quote}


\chapter{알람 내역 열람하기}
\label{\detokenize{anomaly/part05/index:id1}}\label{\detokenize{anomaly/part05/index::doc}}
\sphinxstylestrong{Alarm} 탭 메뉴에서는 지금까지 발생한 알람 내역을 확인할 수 있습니다. 알람의 전체적인 현황을 보여주는 {\hyperref[\detokenize{anomaly/part03/index:statistics}]{\sphinxcrossref{\DUrole{std,std-ref}{통계}}}} 페이지와는 다르게 이 메뉴에서는 보다 개별적인 알람들을 열람하고 탐색하는 데 최적화된 UI를 제공합니다.

이 메뉴는 다음의 두 가지 페이지로 구성되어 있습니다.
\begin{itemize}
\item {} 
{\hyperref[\detokenize{anomaly/part05/index:alarm-list}]{\sphinxcrossref{\DUrole{std,std-ref}{알람 리스트}}}}

\item {} 
{\hyperref[\detokenize{anomaly/part05/index:alarm-details}]{\sphinxcrossref{\DUrole{std,std-ref}{알람 상세}}}}

\end{itemize}


\section{알람 리스트}
\label{\detokenize{anomaly/part05/index:alarm-list}}\label{\detokenize{anomaly/part05/index:id2}}
\sphinxstylestrong{Alarm} 탭으로 들어가면 현재까지 발생한 알람들을 열거하여 보여줍니다. 화면 상단에 있는 \sphinxstylestrong{Alarm rule} / \sphinxstylestrong{Timeline} 선택 박스를 이용하여, 알람 리스트를 알람 룰 기준으로 정렬할 수도 있고, 발생한 시간 기준으로 정렬할 수도 있습니다.
\begin{itemize}
\item {} 
\sphinxstylestrong{Alarm rule} (알람 룰 기준으로 정렬)
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{alarm_list_01}.png}
\end{figure}
\end{quote}

\item {} 
\sphinxstylestrong{Timeline} (발생 시간 기준으로 정렬)
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{alarm_list_03}.png}
\end{figure}
\end{quote}

\end{itemize}

카테고리 맨 끝에 있는 \sphinxstylestrong{+ Load more}를 클릭하면 해당 카테고리 내 더 많은 알람 항목을 보여줍니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{alarm_list_02}.png}
\end{figure}
\end{quote}


\section{알람 상세}
\label{\detokenize{anomaly/part05/index:alarm-details}}\label{\detokenize{anomaly/part05/index:id3}}
알람 리스트에 열거된 항목 중 하나를 선택하면 해당 알람에 대한 상세 정보를 열람할 수 있습니다. 아래는 알람 상세 페이지의 각 영역별 설명입니다.


\subsection{Alarm Info 영역}
\label{\detokenize{anomaly/part05/index:alarm-info}}
이 영역에서는 해당 알람의 심각도와 발생 시각, 그리고 이 알람을 발생시킨 룰의 설정값을 보여줍니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{alarm_detail_01}.png}
\end{figure}
\end{quote}


\subsection{알람 현황 일람 상자}
\label{\detokenize{anomaly/part05/index:id4}}
이 영역에서는 해당 알람의 발생 현황을 보여줍니다. 정해진 주기에 따라 알람이 연속적으로 발생하면 1개의 알람 항목으로 계속 유지됩니다. 아래 그림 예시에서는 알람이 4번의 주기 동안 연속적으로 발생하였고(\sphinxstylestrong{Alarms}), 주기가 1분이었기 때문에 4건의 알람이 총 4분 동안 지속된 것입니다(\sphinxstylestrong{Elapsed Time}).
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{alarm_detail_02}.png}
\end{figure}
\end{quote}


\subsection{Alarm History 영역}
\label{\detokenize{anomaly/part05/index:alarm-history}}
이 영역에서는 해당 알람에 적용된 알람 룰에 의해 발생한 알람의 이력을 보여줍니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{alarm_detail_03}.png}
\end{figure}
\end{quote}


\subsection{Chart View 탭}
\label{\detokenize{anomaly/part05/index:chart-view}}
이 탭 영역에서는 해당 알람 구간 내에서 모니터링한 aggregate 데이터의 abnormal score 추이를 차트로 보여줍니다. 여기서는 각 조건별 점수 한계값에 도달하여 상응하는 알람(\sphinxcode{\sphinxupquote{Critical}}, \sphinxcode{\sphinxupquote{Major}}, \sphinxcode{\sphinxupquote{Moderate}}, \sphinxcode{\sphinxupquote{Low}})을 일으킨 발생 건도 보고해줍니다. 차트 산출 방식에 관해서는 {\hyperref[\detokenize{anomaly/part01/index:basic-principles}]{\sphinxcrossref{\DUrole{std,std-ref}{기본 원리}}}} 항목을 참조하십시오.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{alarm_detail_04}.png}
\end{figure}
\begin{itemize}
\item {} 
\sphinxstylestrong{Total abnormal score:} 알람 룰에 포함된 모든 측정값 컬럼에 대한 abnormal score를 보여줍니다.

\item {} 
\sphinxstylestrong{Chart by measures:} 알람 룰에 포함된 각 개별 측정값 컬럼 데이터의 예측치와 실제치의 추이를 보여줍니다.

\end{itemize}
\end{quote}


\subsection{Table View 탭}
\label{\detokenize{anomaly/part05/index:table-view}}
이 탭 영역에서는 각 알람 발생 건별로 데이터 실제치와 예측치, 그리고 abnormal score를 보여줍니다.
\begin{quote}

\begin{figure}[H]
\centering

\noindent\sphinxincludegraphics{{alarm_detail_05}.png}
\end{figure}
\end{quote}



\renewcommand{\indexname}{색인}
\printindex
\end{document}